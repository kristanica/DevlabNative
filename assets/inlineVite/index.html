<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simple Code Editor with Output</title>
    <script type="module" crossorigin>
      (function () {
        const e = document.createElement("link").relList;
        if (e && e.supports && e.supports("modulepreload")) return;
        for (const r of document.querySelectorAll('link[rel="modulepreload"]'))
          i(r);
        new MutationObserver((r) => {
          for (const s of r)
            if (s.type === "childList")
              for (const o of s.addedNodes)
                o.tagName === "LINK" && o.rel === "modulepreload" && i(o);
        }).observe(document, { childList: !0, subtree: !0 });
        function t(r) {
          const s = {};
          return (
            r.integrity && (s.integrity = r.integrity),
            r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
            r.crossOrigin === "use-credentials"
              ? (s.credentials = "include")
              : r.crossOrigin === "anonymous"
              ? (s.credentials = "omit")
              : (s.credentials = "same-origin"),
            s
          );
        }
        function i(r) {
          if (r.ep) return;
          r.ep = !0;
          const s = t(r);
          fetch(r.href, s);
        }
      })();
      let Cs = [],
        qh = [];
      (() => {
        let n =
          "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o"
            .split(",")
            .map((e) => (e ? parseInt(e, 36) : 1));
        for (let e = 0, t = 0; e < n.length; e++)
          (e % 2 ? qh : Cs).push((t = t + n[e]));
      })();
      function kd(n) {
        if (n < 768) return !1;
        for (let e = 0, t = Cs.length; ; ) {
          let i = (e + t) >> 1;
          if (n < Cs[i]) t = i;
          else if (n >= qh[i]) e = i + 1;
          else return !0;
          if (e == t) return !1;
        }
      }
      function Ql(n) {
        return n >= 127462 && n <= 127487;
      }
      const Sl = 8205;
      function $d(n, e, t = !0, i = !0) {
        return (t ? Wh : Pd)(n, e, i);
      }
      function Wh(n, e, t) {
        if (e == n.length) return e;
        e && Lh(n.charCodeAt(e)) && jh(n.charCodeAt(e - 1)) && e--;
        let i = Gr(n, e);
        for (e += yl(i); e < n.length; ) {
          let r = Gr(n, e);
          if (i == Sl || r == Sl || (t && kd(r))) (e += yl(r)), (i = r);
          else if (Ql(r)) {
            let s = 0,
              o = e - 2;
            for (; o >= 0 && Ql(Gr(n, o)); ) s++, (o -= 2);
            if (s % 2 == 0) break;
            e += 2;
          } else break;
        }
        return e;
      }
      function Pd(n, e, t) {
        for (; e > 0; ) {
          let i = Wh(n, e - 2, t);
          if (i < e) return i;
          e--;
        }
        return 0;
      }
      function Gr(n, e) {
        let t = n.charCodeAt(e);
        if (!jh(t) || e + 1 == n.length) return t;
        let i = n.charCodeAt(e + 1);
        return Lh(i) ? ((t - 55296) << 10) + (i - 56320) + 65536 : t;
      }
      function Lh(n) {
        return n >= 56320 && n < 57344;
      }
      function jh(n) {
        return n >= 55296 && n < 56320;
      }
      function yl(n) {
        return n < 65536 ? 1 : 2;
      }
      class E {
        lineAt(e) {
          if (e < 0 || e > this.length)
            throw new RangeError(
              `Invalid position ${e} in document of length ${this.length}`
            );
          return this.lineInner(e, !1, 1, 0);
        }
        line(e) {
          if (e < 1 || e > this.lines)
            throw new RangeError(
              `Invalid line number ${e} in ${this.lines}-line document`
            );
          return this.lineInner(e, !0, 1, 0);
        }
        replace(e, t, i) {
          [e, t] = oi(this, e, t);
          let r = [];
          return (
            this.decompose(0, e, r, 2),
            i.length && i.decompose(0, i.length, r, 3),
            this.decompose(t, this.length, r, 1),
            Ke.from(r, this.length - (t - e) + i.length)
          );
        }
        append(e) {
          return this.replace(this.length, this.length, e);
        }
        slice(e, t = this.length) {
          [e, t] = oi(this, e, t);
          let i = [];
          return this.decompose(e, t, i, 0), Ke.from(i, t - e);
        }
        eq(e) {
          if (e == this) return !0;
          if (e.length != this.length || e.lines != this.lines) return !1;
          let t = this.scanIdentical(e, 1),
            i = this.length - this.scanIdentical(e, -1),
            r = new Mi(this),
            s = new Mi(e);
          for (let o = t, l = t; ; ) {
            if (
              (r.next(o),
              s.next(o),
              (o = 0),
              r.lineBreak != s.lineBreak ||
                r.done != s.done ||
                r.value != s.value)
            )
              return !1;
            if (((l += r.value.length), r.done || l >= i)) return !0;
          }
        }
        iter(e = 1) {
          return new Mi(this, e);
        }
        iterRange(e, t = this.length) {
          return new Bh(this, e, t);
        }
        iterLines(e, t) {
          let i;
          if (e == null) i = this.iter();
          else {
            t == null && (t = this.lines + 1);
            let r = this.line(e).from;
            i = this.iterRange(
              r,
              Math.max(
                r,
                t == this.lines + 1
                  ? this.length
                  : t <= 1
                  ? 0
                  : this.line(t - 1).to
              )
            );
          }
          return new Ih(i);
        }
        toString() {
          return this.sliceString(0);
        }
        toJSON() {
          let e = [];
          return this.flatten(e), e;
        }
        constructor() {}
        static of(e) {
          if (e.length == 0)
            throw new RangeError("A document must have at least one line");
          return e.length == 1 && !e[0]
            ? E.empty
            : e.length <= 32
            ? new ee(e)
            : Ke.from(ee.split(e, []));
        }
      }
      class ee extends E {
        constructor(e, t = vd(e)) {
          super(), (this.text = e), (this.length = t);
        }
        get lines() {
          return this.text.length;
        }
        get children() {
          return null;
        }
        lineInner(e, t, i, r) {
          for (let s = 0; ; s++) {
            let o = this.text[s],
              l = r + o.length;
            if ((t ? i : l) >= e) return new Td(r, l, i, o);
            (r = l + 1), i++;
          }
        }
        decompose(e, t, i, r) {
          let s =
            e <= 0 && t >= this.length
              ? this
              : new ee(
                  bl(this.text, e, t),
                  Math.min(t, this.length) - Math.max(0, e)
                );
          if (r & 1) {
            let o = i.pop(),
              l = En(s.text, o.text.slice(), 0, s.length);
            if (l.length <= 32) i.push(new ee(l, o.length + s.length));
            else {
              let a = l.length >> 1;
              i.push(new ee(l.slice(0, a)), new ee(l.slice(a)));
            }
          } else i.push(s);
        }
        replace(e, t, i) {
          if (!(i instanceof ee)) return super.replace(e, t, i);
          [e, t] = oi(this, e, t);
          let r = En(this.text, En(i.text, bl(this.text, 0, e)), t),
            s = this.length + i.length - (t - e);
          return r.length <= 32 ? new ee(r, s) : Ke.from(ee.split(r, []), s);
        }
        sliceString(
          e,
          t = this.length,
          i = `
`
        ) {
          [e, t] = oi(this, e, t);
          let r = "";
          for (let s = 0, o = 0; s <= t && o < this.text.length; o++) {
            let l = this.text[o],
              a = s + l.length;
            s > e && o && (r += i),
              e < a && t > s && (r += l.slice(Math.max(0, e - s), t - s)),
              (s = a + 1);
          }
          return r;
        }
        flatten(e) {
          for (let t of this.text) e.push(t);
        }
        scanIdentical() {
          return 0;
        }
        static split(e, t) {
          let i = [],
            r = -1;
          for (let s of e)
            i.push(s),
              (r += s.length + 1),
              i.length == 32 && (t.push(new ee(i, r)), (i = []), (r = -1));
          return r > -1 && t.push(new ee(i, r)), t;
        }
      }
      class Ke extends E {
        constructor(e, t) {
          super(), (this.children = e), (this.length = t), (this.lines = 0);
          for (let i of e) this.lines += i.lines;
        }
        lineInner(e, t, i, r) {
          for (let s = 0; ; s++) {
            let o = this.children[s],
              l = r + o.length,
              a = i + o.lines - 1;
            if ((t ? a : l) >= e) return o.lineInner(e, t, i, r);
            (r = l + 1), (i = a + 1);
          }
        }
        decompose(e, t, i, r) {
          for (let s = 0, o = 0; o <= t && s < this.children.length; s++) {
            let l = this.children[s],
              a = o + l.length;
            if (e <= a && t >= o) {
              let h = r & ((o <= e ? 1 : 0) | (a >= t ? 2 : 0));
              o >= e && a <= t && !h
                ? i.push(l)
                : l.decompose(e - o, t - o, i, h);
            }
            o = a + 1;
          }
        }
        replace(e, t, i) {
          if ((([e, t] = oi(this, e, t)), i.lines < this.lines))
            for (let r = 0, s = 0; r < this.children.length; r++) {
              let o = this.children[r],
                l = s + o.length;
              if (e >= s && t <= l) {
                let a = o.replace(e - s, t - s, i),
                  h = this.lines - o.lines + a.lines;
                if (a.lines < h >> 4 && a.lines > h >> 6) {
                  let c = this.children.slice();
                  return (
                    (c[r] = a), new Ke(c, this.length - (t - e) + i.length)
                  );
                }
                return super.replace(s, l, a);
              }
              s = l + 1;
            }
          return super.replace(e, t, i);
        }
        sliceString(
          e,
          t = this.length,
          i = `
`
        ) {
          [e, t] = oi(this, e, t);
          let r = "";
          for (let s = 0, o = 0; s < this.children.length && o <= t; s++) {
            let l = this.children[s],
              a = o + l.length;
            o > e && s && (r += i),
              e < a && t > o && (r += l.sliceString(e - o, t - o, i)),
              (o = a + 1);
          }
          return r;
        }
        flatten(e) {
          for (let t of this.children) t.flatten(e);
        }
        scanIdentical(e, t) {
          if (!(e instanceof Ke)) return 0;
          let i = 0,
            [r, s, o, l] =
              t > 0
                ? [0, 0, this.children.length, e.children.length]
                : [this.children.length - 1, e.children.length - 1, -1, -1];
          for (; ; r += t, s += t) {
            if (r == o || s == l) return i;
            let a = this.children[r],
              h = e.children[s];
            if (a != h) return i + a.scanIdentical(h, t);
            i += a.length + 1;
          }
        }
        static from(e, t = e.reduce((i, r) => i + r.length + 1, -1)) {
          let i = 0;
          for (let d of e) i += d.lines;
          if (i < 32) {
            let d = [];
            for (let O of e) O.flatten(d);
            return new ee(d, t);
          }
          let r = Math.max(32, i >> 5),
            s = r << 1,
            o = r >> 1,
            l = [],
            a = 0,
            h = -1,
            c = [];
          function f(d) {
            let O;
            if (d.lines > s && d instanceof Ke) for (let m of d.children) f(m);
            else
              d.lines > o && (a > o || !a)
                ? (u(), l.push(d))
                : d instanceof ee &&
                  a &&
                  (O = c[c.length - 1]) instanceof ee &&
                  d.lines + O.lines <= 32
                ? ((a += d.lines),
                  (h += d.length + 1),
                  (c[c.length - 1] = new ee(
                    O.text.concat(d.text),
                    O.length + 1 + d.length
                  )))
                : (a + d.lines > r && u(),
                  (a += d.lines),
                  (h += d.length + 1),
                  c.push(d));
          }
          function u() {
            a != 0 &&
              (l.push(c.length == 1 ? c[0] : Ke.from(c, h)),
              (h = -1),
              (a = c.length = 0));
          }
          for (let d of e) f(d);
          return u(), l.length == 1 ? l[0] : new Ke(l, t);
        }
      }
      E.empty = new ee([""], 0);
      function vd(n) {
        let e = -1;
        for (let t of n) e += t.length + 1;
        return e;
      }
      function En(n, e, t = 0, i = 1e9) {
        for (let r = 0, s = 0, o = !0; s < n.length && r <= i; s++) {
          let l = n[s],
            a = r + l.length;
          a >= t &&
            (a > i && (l = l.slice(0, i - r)),
            r < t && (l = l.slice(t - r)),
            o ? ((e[e.length - 1] += l), (o = !1)) : e.push(l)),
            (r = a + 1);
        }
        return e;
      }
      function bl(n, e, t) {
        return En(n, [""], e, t);
      }
      class Mi {
        constructor(e, t = 1) {
          (this.dir = t),
            (this.done = !1),
            (this.lineBreak = !1),
            (this.value = ""),
            (this.nodes = [e]),
            (this.offsets = [
              t > 0
                ? 1
                : (e instanceof ee ? e.text.length : e.children.length) << 1,
            ]);
        }
        nextInner(e, t) {
          for (this.done = this.lineBreak = !1; ; ) {
            let i = this.nodes.length - 1,
              r = this.nodes[i],
              s = this.offsets[i],
              o = s >> 1,
              l = r instanceof ee ? r.text.length : r.children.length;
            if (o == (t > 0 ? l : 0)) {
              if (i == 0) return (this.done = !0), (this.value = ""), this;
              t > 0 && this.offsets[i - 1]++,
                this.nodes.pop(),
                this.offsets.pop();
            } else if ((s & 1) == (t > 0 ? 0 : 1)) {
              if (((this.offsets[i] += t), e == 0))
                return (
                  (this.lineBreak = !0),
                  (this.value = `
`),
                  this
                );
              e--;
            } else if (r instanceof ee) {
              let a = r.text[o + (t < 0 ? -1 : 0)];
              if (((this.offsets[i] += t), a.length > Math.max(0, e)))
                return (
                  (this.value =
                    e == 0 ? a : t > 0 ? a.slice(e) : a.slice(0, a.length - e)),
                  this
                );
              e -= a.length;
            } else {
              let a = r.children[o + (t < 0 ? -1 : 0)];
              e > a.length
                ? ((e -= a.length), (this.offsets[i] += t))
                : (t < 0 && this.offsets[i]--,
                  this.nodes.push(a),
                  this.offsets.push(
                    t > 0
                      ? 1
                      : (a instanceof ee ? a.text.length : a.children.length) <<
                          1
                  ));
            }
          }
        }
        next(e = 0) {
          return (
            e < 0 && (this.nextInner(-e, -this.dir), (e = this.value.length)),
            this.nextInner(e, this.dir)
          );
        }
      }
      class Bh {
        constructor(e, t, i) {
          (this.value = ""),
            (this.done = !1),
            (this.cursor = new Mi(e, t > i ? -1 : 1)),
            (this.pos = t > i ? e.length : 0),
            (this.from = Math.min(t, i)),
            (this.to = Math.max(t, i));
        }
        nextInner(e, t) {
          if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
            return (this.value = ""), (this.done = !0), this;
          e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
          let i = t < 0 ? this.pos - this.from : this.to - this.pos;
          e > i && (e = i), (i -= e);
          let { value: r } = this.cursor.next(e);
          return (
            (this.pos += (r.length + e) * t),
            (this.value =
              r.length <= i
                ? r
                : t < 0
                ? r.slice(r.length - i)
                : r.slice(0, i)),
            (this.done = !this.value),
            this
          );
        }
        next(e = 0) {
          return (
            e < 0
              ? (e = Math.max(e, this.from - this.pos))
              : e > 0 && (e = Math.min(e, this.to - this.pos)),
            this.nextInner(e, this.cursor.dir)
          );
        }
        get lineBreak() {
          return this.cursor.lineBreak && this.value != "";
        }
      }
      class Ih {
        constructor(e) {
          (this.inner = e),
            (this.afterBreak = !0),
            (this.value = ""),
            (this.done = !1);
        }
        next(e = 0) {
          let { done: t, lineBreak: i, value: r } = this.inner.next(e);
          return (
            t && this.afterBreak
              ? ((this.value = ""), (this.afterBreak = !1))
              : t
              ? ((this.done = !0), (this.value = ""))
              : i
              ? this.afterBreak
                ? (this.value = "")
                : ((this.afterBreak = !0), this.next())
              : ((this.value = r), (this.afterBreak = !1)),
            this
          );
        }
        get lineBreak() {
          return !1;
        }
      }
      typeof Symbol < "u" &&
        ((E.prototype[Symbol.iterator] = function () {
          return this.iter();
        }),
        (Mi.prototype[Symbol.iterator] =
          Bh.prototype[Symbol.iterator] =
          Ih.prototype[Symbol.iterator] =
            function () {
              return this;
            }));
      class Td {
        constructor(e, t, i, r) {
          (this.from = e), (this.to = t), (this.number = i), (this.text = r);
        }
        get length() {
          return this.to - this.from;
        }
      }
      function oi(n, e, t) {
        return (
          (e = Math.max(0, Math.min(n.length, e))),
          [e, Math.max(e, Math.min(n.length, t))]
        );
      }
      function fe(n, e, t = !0, i = !0) {
        return $d(n, e, t, i);
      }
      function Cd(n) {
        return n >= 56320 && n < 57344;
      }
      function Zd(n) {
        return n >= 55296 && n < 56320;
      }
      function be(n, e) {
        let t = n.charCodeAt(e);
        if (!Zd(t) || e + 1 == n.length) return t;
        let i = n.charCodeAt(e + 1);
        return Cd(i) ? ((t - 55296) << 10) + (i - 56320) + 65536 : t;
      }
      function Co(n) {
        return n <= 65535
          ? String.fromCharCode(n)
          : ((n -= 65536),
            String.fromCharCode((n >> 10) + 55296, (n & 1023) + 56320));
      }
      function Je(n) {
        return n < 65536 ? 1 : 2;
      }
      const Zs = /\r\n?|\n/;
      var ce = (function (n) {
        return (
          (n[(n.Simple = 0)] = "Simple"),
          (n[(n.TrackDel = 1)] = "TrackDel"),
          (n[(n.TrackBefore = 2)] = "TrackBefore"),
          (n[(n.TrackAfter = 3)] = "TrackAfter"),
          n
        );
      })(ce || (ce = {}));
      class rt {
        constructor(e) {
          this.sections = e;
        }
        get length() {
          let e = 0;
          for (let t = 0; t < this.sections.length; t += 2)
            e += this.sections[t];
          return e;
        }
        get newLength() {
          let e = 0;
          for (let t = 0; t < this.sections.length; t += 2) {
            let i = this.sections[t + 1];
            e += i < 0 ? this.sections[t] : i;
          }
          return e;
        }
        get empty() {
          return (
            this.sections.length == 0 ||
            (this.sections.length == 2 && this.sections[1] < 0)
          );
        }
        iterGaps(e) {
          for (let t = 0, i = 0, r = 0; t < this.sections.length; ) {
            let s = this.sections[t++],
              o = this.sections[t++];
            o < 0 ? (e(i, r, s), (r += s)) : (r += o), (i += s);
          }
        }
        iterChangedRanges(e, t = !1) {
          As(this, e, t);
        }
        get invertedDesc() {
          let e = [];
          for (let t = 0; t < this.sections.length; ) {
            let i = this.sections[t++],
              r = this.sections[t++];
            r < 0 ? e.push(i, r) : e.push(r, i);
          }
          return new rt(e);
        }
        composeDesc(e) {
          return this.empty ? e : e.empty ? this : Gh(this, e);
        }
        mapDesc(e, t = !1) {
          return e.empty ? this : Xs(this, e, t);
        }
        mapPos(e, t = -1, i = ce.Simple) {
          let r = 0,
            s = 0;
          for (let o = 0; o < this.sections.length; ) {
            let l = this.sections[o++],
              a = this.sections[o++],
              h = r + l;
            if (a < 0) {
              if (h > e) return s + (e - r);
              s += l;
            } else {
              if (
                i != ce.Simple &&
                h >= e &&
                ((i == ce.TrackDel && r < e && h > e) ||
                  (i == ce.TrackBefore && r < e) ||
                  (i == ce.TrackAfter && h > e))
              )
                return null;
              if (h > e || (h == e && t < 0 && !l))
                return e == r || t < 0 ? s : s + a;
              s += a;
            }
            r = h;
          }
          if (e > r)
            throw new RangeError(
              `Position ${e} is out of range for changeset of length ${r}`
            );
          return s;
        }
        touchesRange(e, t = e) {
          for (let i = 0, r = 0; i < this.sections.length && r <= t; ) {
            let s = this.sections[i++],
              o = this.sections[i++],
              l = r + s;
            if (o >= 0 && r <= t && l >= e)
              return r < e && l > t ? "cover" : !0;
            r = l;
          }
          return !1;
        }
        toString() {
          let e = "";
          for (let t = 0; t < this.sections.length; ) {
            let i = this.sections[t++],
              r = this.sections[t++];
            e += (e ? " " : "") + i + (r >= 0 ? ":" + r : "");
          }
          return e;
        }
        toJSON() {
          return this.sections;
        }
        static fromJSON(e) {
          if (
            !Array.isArray(e) ||
            e.length % 2 ||
            e.some((t) => typeof t != "number")
          )
            throw new RangeError("Invalid JSON representation of ChangeDesc");
          return new rt(e);
        }
        static create(e) {
          return new rt(e);
        }
      }
      class re extends rt {
        constructor(e, t) {
          super(e), (this.inserted = t);
        }
        apply(e) {
          if (this.length != e.length)
            throw new RangeError(
              "Applying change set to a document with the wrong length"
            );
          return (
            As(this, (t, i, r, s, o) => (e = e.replace(r, r + (i - t), o)), !1),
            e
          );
        }
        mapDesc(e, t = !1) {
          return Xs(this, e, t, !0);
        }
        invert(e) {
          let t = this.sections.slice(),
            i = [];
          for (let r = 0, s = 0; r < t.length; r += 2) {
            let o = t[r],
              l = t[r + 1];
            if (l >= 0) {
              (t[r] = l), (t[r + 1] = o);
              let a = r >> 1;
              for (; i.length < a; ) i.push(E.empty);
              i.push(o ? e.slice(s, s + o) : E.empty);
            }
            s += o;
          }
          return new re(t, i);
        }
        compose(e) {
          return this.empty ? e : e.empty ? this : Gh(this, e, !0);
        }
        map(e, t = !1) {
          return e.empty ? this : Xs(this, e, t, !0);
        }
        iterChanges(e, t = !1) {
          As(this, e, t);
        }
        get desc() {
          return rt.create(this.sections);
        }
        filter(e) {
          let t = [],
            i = [],
            r = [],
            s = new Vi(this);
          e: for (let o = 0, l = 0; ; ) {
            let a = o == e.length ? 1e9 : e[o++];
            for (; l < a || (l == a && s.len == 0); ) {
              if (s.done) break e;
              let c = Math.min(s.len, a - l);
              ue(r, c, -1);
              let f = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
              ue(t, c, f), f > 0 && wt(i, t, s.text), s.forward(c), (l += c);
            }
            let h = e[o++];
            for (; l < h; ) {
              if (s.done) break e;
              let c = Math.min(s.len, h - l);
              ue(t, c, -1),
                ue(r, c, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0),
                s.forward(c),
                (l += c);
            }
          }
          return { changes: new re(t, i), filtered: rt.create(r) };
        }
        toJSON() {
          let e = [];
          for (let t = 0; t < this.sections.length; t += 2) {
            let i = this.sections[t],
              r = this.sections[t + 1];
            r < 0
              ? e.push(i)
              : r == 0
              ? e.push([i])
              : e.push([i].concat(this.inserted[t >> 1].toJSON()));
          }
          return e;
        }
        static of(e, t, i) {
          let r = [],
            s = [],
            o = 0,
            l = null;
          function a(c = !1) {
            if (!c && !r.length) return;
            o < t && ue(r, t - o, -1);
            let f = new re(r, s);
            (l = l ? l.compose(f.map(l)) : f), (r = []), (s = []), (o = 0);
          }
          function h(c) {
            if (Array.isArray(c)) for (let f of c) h(f);
            else if (c instanceof re) {
              if (c.length != t)
                throw new RangeError(
                  `Mismatched change set length (got ${c.length}, expected ${t})`
                );
              a(), (l = l ? l.compose(c.map(l)) : c);
            } else {
              let { from: f, to: u = f, insert: d } = c;
              if (f > u || f < 0 || u > t)
                throw new RangeError(
                  `Invalid change range ${f} to ${u} (in doc of length ${t})`
                );
              let O = d
                  ? typeof d == "string"
                    ? E.of(d.split(i || Zs))
                    : d
                  : E.empty,
                m = O.length;
              if (f == u && m == 0) return;
              f < o && a(),
                f > o && ue(r, f - o, -1),
                ue(r, u - f, m),
                wt(s, r, O),
                (o = u);
            }
          }
          return h(e), a(!l), l;
        }
        static empty(e) {
          return new re(e ? [e, -1] : [], []);
        }
        static fromJSON(e) {
          if (!Array.isArray(e))
            throw new RangeError("Invalid JSON representation of ChangeSet");
          let t = [],
            i = [];
          for (let r = 0; r < e.length; r++) {
            let s = e[r];
            if (typeof s == "number") t.push(s, -1);
            else {
              if (
                !Array.isArray(s) ||
                typeof s[0] != "number" ||
                s.some((o, l) => l && typeof o != "string")
              )
                throw new RangeError(
                  "Invalid JSON representation of ChangeSet"
                );
              if (s.length == 1) t.push(s[0], 0);
              else {
                for (; i.length < r; ) i.push(E.empty);
                (i[r] = E.of(s.slice(1))), t.push(s[0], i[r].length);
              }
            }
          }
          return new re(t, i);
        }
        static createSet(e, t) {
          return new re(e, t);
        }
      }
      function ue(n, e, t, i = !1) {
        if (e == 0 && t <= 0) return;
        let r = n.length - 2;
        r >= 0 && t <= 0 && t == n[r + 1]
          ? (n[r] += e)
          : r >= 0 && e == 0 && n[r] == 0
          ? (n[r + 1] += t)
          : i
          ? ((n[r] += e), (n[r + 1] += t))
          : n.push(e, t);
      }
      function wt(n, e, t) {
        if (t.length == 0) return;
        let i = (e.length - 2) >> 1;
        if (i < n.length) n[n.length - 1] = n[n.length - 1].append(t);
        else {
          for (; n.length < i; ) n.push(E.empty);
          n.push(t);
        }
      }
      function As(n, e, t) {
        let i = n.inserted;
        for (let r = 0, s = 0, o = 0; o < n.sections.length; ) {
          let l = n.sections[o++],
            a = n.sections[o++];
          if (a < 0) (r += l), (s += l);
          else {
            let h = r,
              c = s,
              f = E.empty;
            for (
              ;
              (h += l),
                (c += a),
                a && i && (f = f.append(i[(o - 2) >> 1])),
                !(t || o == n.sections.length || n.sections[o + 1] < 0);

            )
              (l = n.sections[o++]), (a = n.sections[o++]);
            e(r, h, s, c, f), (r = h), (s = c);
          }
        }
      }
      function Xs(n, e, t, i = !1) {
        let r = [],
          s = i ? [] : null,
          o = new Vi(n),
          l = new Vi(e);
        for (let a = -1; ; ) {
          if ((o.done && l.len) || (l.done && o.len))
            throw new Error("Mismatched change set lengths");
          if (o.ins == -1 && l.ins == -1) {
            let h = Math.min(o.len, l.len);
            ue(r, h, -1), o.forward(h), l.forward(h);
          } else if (
            l.ins >= 0 &&
            (o.ins < 0 ||
              a == o.i ||
              (o.off == 0 && (l.len < o.len || (l.len == o.len && !t))))
          ) {
            let h = l.len;
            for (ue(r, l.ins, -1); h; ) {
              let c = Math.min(o.len, h);
              o.ins >= 0 &&
                a < o.i &&
                o.len <= c &&
                (ue(r, 0, o.ins), s && wt(s, r, o.text), (a = o.i)),
                o.forward(c),
                (h -= c);
            }
            l.next();
          } else if (o.ins >= 0) {
            let h = 0,
              c = o.len;
            for (; c; )
              if (l.ins == -1) {
                let f = Math.min(c, l.len);
                (h += f), (c -= f), l.forward(f);
              } else if (l.ins == 0 && l.len < c) (c -= l.len), l.next();
              else break;
            ue(r, h, a < o.i ? o.ins : 0),
              s && a < o.i && wt(s, r, o.text),
              (a = o.i),
              o.forward(o.len - c);
          } else {
            if (o.done && l.done) return s ? re.createSet(r, s) : rt.create(r);
            throw new Error("Mismatched change set lengths");
          }
        }
      }
      function Gh(n, e, t = !1) {
        let i = [],
          r = t ? [] : null,
          s = new Vi(n),
          o = new Vi(e);
        for (let l = !1; ; ) {
          if (s.done && o.done) return r ? re.createSet(i, r) : rt.create(i);
          if (s.ins == 0) ue(i, s.len, 0, l), s.next();
          else if (o.len == 0 && !o.done)
            ue(i, 0, o.ins, l), r && wt(r, i, o.text), o.next();
          else {
            if (s.done || o.done)
              throw new Error("Mismatched change set lengths");
            {
              let a = Math.min(s.len2, o.len),
                h = i.length;
              if (s.ins == -1) {
                let c = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
                ue(i, a, c, l), r && c && wt(r, i, o.text);
              } else
                o.ins == -1
                  ? (ue(i, s.off ? 0 : s.len, a, l),
                    r && wt(r, i, s.textBit(a)))
                  : (ue(i, s.off ? 0 : s.len, o.off ? 0 : o.ins, l),
                    r && !o.off && wt(r, i, o.text));
              (l =
                (s.ins > a || (o.ins >= 0 && o.len > a)) &&
                (l || i.length > h)),
                s.forward2(a),
                o.forward(a);
            }
          }
        }
      }
      class Vi {
        constructor(e) {
          (this.set = e), (this.i = 0), this.next();
        }
        next() {
          let { sections: e } = this.set;
          this.i < e.length
            ? ((this.len = e[this.i++]), (this.ins = e[this.i++]))
            : ((this.len = 0), (this.ins = -2)),
            (this.off = 0);
        }
        get done() {
          return this.ins == -2;
        }
        get len2() {
          return this.ins < 0 ? this.len : this.ins;
        }
        get text() {
          let { inserted: e } = this.set,
            t = (this.i - 2) >> 1;
          return t >= e.length ? E.empty : e[t];
        }
        textBit(e) {
          let { inserted: t } = this.set,
            i = (this.i - 2) >> 1;
          return i >= t.length && !e
            ? E.empty
            : t[i].slice(this.off, e == null ? void 0 : this.off + e);
        }
        forward(e) {
          e == this.len ? this.next() : ((this.len -= e), (this.off += e));
        }
        forward2(e) {
          this.ins == -1
            ? this.forward(e)
            : e == this.ins
            ? this.next()
            : ((this.ins -= e), (this.off += e));
        }
      }
      class Et {
        constructor(e, t, i) {
          (this.from = e), (this.to = t), (this.flags = i);
        }
        get anchor() {
          return this.flags & 32 ? this.to : this.from;
        }
        get head() {
          return this.flags & 32 ? this.from : this.to;
        }
        get empty() {
          return this.from == this.to;
        }
        get assoc() {
          return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
        }
        get bidiLevel() {
          let e = this.flags & 7;
          return e == 7 ? null : e;
        }
        get goalColumn() {
          let e = this.flags >> 6;
          return e == 16777215 ? void 0 : e;
        }
        map(e, t = -1) {
          let i, r;
          return (
            this.empty
              ? (i = r = e.mapPos(this.from, t))
              : ((i = e.mapPos(this.from, 1)), (r = e.mapPos(this.to, -1))),
            i == this.from && r == this.to ? this : new Et(i, r, this.flags)
          );
        }
        extend(e, t = e) {
          if (e <= this.anchor && t >= this.anchor) return S.range(e, t);
          let i = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
          return S.range(this.anchor, i);
        }
        eq(e, t = !1) {
          return (
            this.anchor == e.anchor &&
            this.head == e.head &&
            (!t || !this.empty || this.assoc == e.assoc)
          );
        }
        toJSON() {
          return { anchor: this.anchor, head: this.head };
        }
        static fromJSON(e) {
          if (!e || typeof e.anchor != "number" || typeof e.head != "number")
            throw new RangeError(
              "Invalid JSON representation for SelectionRange"
            );
          return S.range(e.anchor, e.head);
        }
        static create(e, t, i) {
          return new Et(e, t, i);
        }
      }
      class S {
        constructor(e, t) {
          (this.ranges = e), (this.mainIndex = t);
        }
        map(e, t = -1) {
          return e.empty
            ? this
            : S.create(
                this.ranges.map((i) => i.map(e, t)),
                this.mainIndex
              );
        }
        eq(e, t = !1) {
          if (
            this.ranges.length != e.ranges.length ||
            this.mainIndex != e.mainIndex
          )
            return !1;
          for (let i = 0; i < this.ranges.length; i++)
            if (!this.ranges[i].eq(e.ranges[i], t)) return !1;
          return !0;
        }
        get main() {
          return this.ranges[this.mainIndex];
        }
        asSingle() {
          return this.ranges.length == 1 ? this : new S([this.main], 0);
        }
        addRange(e, t = !0) {
          return S.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1);
        }
        replaceRange(e, t = this.mainIndex) {
          let i = this.ranges.slice();
          return (i[t] = e), S.create(i, this.mainIndex);
        }
        toJSON() {
          return {
            ranges: this.ranges.map((e) => e.toJSON()),
            main: this.mainIndex,
          };
        }
        static fromJSON(e) {
          if (
            !e ||
            !Array.isArray(e.ranges) ||
            typeof e.main != "number" ||
            e.main >= e.ranges.length
          )
            throw new RangeError(
              "Invalid JSON representation for EditorSelection"
            );
          return new S(
            e.ranges.map((t) => Et.fromJSON(t)),
            e.main
          );
        }
        static single(e, t = e) {
          return new S([S.range(e, t)], 0);
        }
        static create(e, t = 0) {
          if (e.length == 0)
            throw new RangeError("A selection needs at least one range");
          for (let i = 0, r = 0; r < e.length; r++) {
            let s = e[r];
            if (s.empty ? s.from <= i : s.from < i)
              return S.normalized(e.slice(), t);
            i = s.to;
          }
          return new S(e, t);
        }
        static cursor(e, t = 0, i, r) {
          return Et.create(
            e,
            e,
            (t == 0 ? 0 : t < 0 ? 8 : 16) |
              (i == null ? 7 : Math.min(6, i)) |
              ((r ?? 16777215) << 6)
          );
        }
        static range(e, t, i, r) {
          let s = ((i ?? 16777215) << 6) | (r == null ? 7 : Math.min(6, r));
          return t < e
            ? Et.create(t, e, 48 | s)
            : Et.create(e, t, (t > e ? 8 : 0) | s);
        }
        static normalized(e, t = 0) {
          let i = e[t];
          e.sort((r, s) => r.from - s.from), (t = e.indexOf(i));
          for (let r = 1; r < e.length; r++) {
            let s = e[r],
              o = e[r - 1];
            if (s.empty ? s.from <= o.to : s.from < o.to) {
              let l = o.from,
                a = Math.max(s.to, o.to);
              r <= t && t--,
                e.splice(
                  --r,
                  2,
                  s.anchor > s.head ? S.range(a, l) : S.range(l, a)
                );
            }
          }
          return new S(e, t);
        }
      }
      function Nh(n, e) {
        for (let t of n.ranges)
          if (t.to > e)
            throw new RangeError("Selection points outside of document");
      }
      let Zo = 0;
      class C {
        constructor(e, t, i, r, s) {
          (this.combine = e),
            (this.compareInput = t),
            (this.compare = i),
            (this.isStatic = r),
            (this.id = Zo++),
            (this.default = e([])),
            (this.extensions = typeof s == "function" ? s(this) : s);
        }
        get reader() {
          return this;
        }
        static define(e = {}) {
          return new C(
            e.combine || ((t) => t),
            e.compareInput || ((t, i) => t === i),
            e.compare || (e.combine ? (t, i) => t === i : Ao),
            !!e.static,
            e.enables
          );
        }
        of(e) {
          return new _n([], this, 0, e);
        }
        compute(e, t) {
          if (this.isStatic) throw new Error("Can't compute a static facet");
          return new _n(e, this, 1, t);
        }
        computeN(e, t) {
          if (this.isStatic) throw new Error("Can't compute a static facet");
          return new _n(e, this, 2, t);
        }
        from(e, t) {
          return t || (t = (i) => i), this.compute([e], (i) => t(i.field(e)));
        }
      }
      function Ao(n, e) {
        return (
          n == e || (n.length == e.length && n.every((t, i) => t === e[i]))
        );
      }
      class _n {
        constructor(e, t, i, r) {
          (this.dependencies = e),
            (this.facet = t),
            (this.type = i),
            (this.value = r),
            (this.id = Zo++);
        }
        dynamicSlot(e) {
          var t;
          let i = this.value,
            r = this.facet.compareInput,
            s = this.id,
            o = e[s] >> 1,
            l = this.type == 2,
            a = !1,
            h = !1,
            c = [];
          for (let f of this.dependencies)
            f == "doc"
              ? (a = !0)
              : f == "selection"
              ? (h = !0)
              : (((t = e[f.id]) !== null && t !== void 0 ? t : 1) & 1) == 0 &&
                c.push(e[f.id]);
          return {
            create(f) {
              return (f.values[o] = i(f)), 1;
            },
            update(f, u) {
              if (
                (a && u.docChanged) ||
                (h && (u.docChanged || u.selection)) ||
                Rs(f, c)
              ) {
                let d = i(f);
                if (l ? !xl(d, f.values[o], r) : !r(d, f.values[o]))
                  return (f.values[o] = d), 1;
              }
              return 0;
            },
            reconfigure: (f, u) => {
              let d,
                O = u.config.address[s];
              if (O != null) {
                let m = er(u, O);
                if (
                  this.dependencies.every((g) =>
                    g instanceof C
                      ? u.facet(g) === f.facet(g)
                      : g instanceof oe
                      ? u.field(g, !1) == f.field(g, !1)
                      : !0
                  ) ||
                  (l ? xl((d = i(f)), m, r) : r((d = i(f)), m))
                )
                  return (f.values[o] = m), 0;
              } else d = i(f);
              return (f.values[o] = d), 1;
            },
          };
        }
      }
      function xl(n, e, t) {
        if (n.length != e.length) return !1;
        for (let i = 0; i < n.length; i++) if (!t(n[i], e[i])) return !1;
        return !0;
      }
      function Rs(n, e) {
        let t = !1;
        for (let i of e) Yi(n, i) & 1 && (t = !0);
        return t;
      }
      function Ad(n, e, t) {
        let i = t.map((a) => n[a.id]),
          r = t.map((a) => a.type),
          s = i.filter((a) => !(a & 1)),
          o = n[e.id] >> 1;
        function l(a) {
          let h = [];
          for (let c = 0; c < i.length; c++) {
            let f = er(a, i[c]);
            if (r[c] == 2) for (let u of f) h.push(u);
            else h.push(f);
          }
          return e.combine(h);
        }
        return {
          create(a) {
            for (let h of i) Yi(a, h);
            return (a.values[o] = l(a)), 1;
          },
          update(a, h) {
            if (!Rs(a, s)) return 0;
            let c = l(a);
            return e.compare(c, a.values[o]) ? 0 : ((a.values[o] = c), 1);
          },
          reconfigure(a, h) {
            let c = Rs(a, i),
              f = h.config.facets[e.id],
              u = h.facet(e);
            if (f && !c && Ao(t, f)) return (a.values[o] = u), 0;
            let d = l(a);
            return e.compare(d, u)
              ? ((a.values[o] = u), 0)
              : ((a.values[o] = d), 1);
          },
        };
      }
      const pn = C.define({ static: !0 });
      class oe {
        constructor(e, t, i, r, s) {
          (this.id = e),
            (this.createF = t),
            (this.updateF = i),
            (this.compareF = r),
            (this.spec = s),
            (this.provides = void 0);
        }
        static define(e) {
          let t = new oe(
            Zo++,
            e.create,
            e.update,
            e.compare || ((i, r) => i === r),
            e
          );
          return e.provide && (t.provides = e.provide(t)), t;
        }
        create(e) {
          let t = e.facet(pn).find((i) => i.field == this);
          return (t?.create || this.createF)(e);
        }
        slot(e) {
          let t = e[this.id] >> 1;
          return {
            create: (i) => ((i.values[t] = this.create(i)), 1),
            update: (i, r) => {
              let s = i.values[t],
                o = this.updateF(s, r);
              return this.compareF(s, o) ? 0 : ((i.values[t] = o), 1);
            },
            reconfigure: (i, r) => {
              let s = i.facet(pn),
                o = r.facet(pn),
                l;
              return (l = s.find((a) => a.field == this)) &&
                l != o.find((a) => a.field == this)
                ? ((i.values[t] = l.create(i)), 1)
                : r.config.address[this.id] != null
                ? ((i.values[t] = r.field(this)), 0)
                : ((i.values[t] = this.create(i)), 1);
            },
          };
        }
        init(e) {
          return [this, pn.of({ field: this, create: e })];
        }
        get extension() {
          return this;
        }
      }
      const zt = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
      function bi(n) {
        return (e) => new Uh(e, n);
      }
      const Xt = {
        highest: bi(zt.highest),
        high: bi(zt.high),
        default: bi(zt.default),
        low: bi(zt.low),
        lowest: bi(zt.lowest),
      };
      class Uh {
        constructor(e, t) {
          (this.inner = e), (this.prec = t);
        }
      }
      class Cr {
        of(e) {
          return new Ms(this, e);
        }
        reconfigure(e) {
          return Cr.reconfigure.of({ compartment: this, extension: e });
        }
        get(e) {
          return e.config.compartments.get(this);
        }
      }
      class Ms {
        constructor(e, t) {
          (this.compartment = e), (this.inner = t);
        }
      }
      class Jn {
        constructor(e, t, i, r, s, o) {
          for (
            this.base = e,
              this.compartments = t,
              this.dynamicSlots = i,
              this.address = r,
              this.staticValues = s,
              this.facets = o,
              this.statusTemplate = [];
            this.statusTemplate.length < i.length;

          )
            this.statusTemplate.push(0);
        }
        staticFacet(e) {
          let t = this.address[e.id];
          return t == null ? e.default : this.staticValues[t >> 1];
        }
        static resolve(e, t, i) {
          let r = [],
            s = Object.create(null),
            o = new Map();
          for (let u of Xd(e, t, o))
            u instanceof oe
              ? r.push(u)
              : (s[u.facet.id] || (s[u.facet.id] = [])).push(u);
          let l = Object.create(null),
            a = [],
            h = [];
          for (let u of r) (l[u.id] = h.length << 1), h.push((d) => u.slot(d));
          let c = i?.config.facets;
          for (let u in s) {
            let d = s[u],
              O = d[0].facet,
              m = (c && c[u]) || [];
            if (d.every((g) => g.type == 0))
              if (((l[O.id] = (a.length << 1) | 1), Ao(m, d)))
                a.push(i.facet(O));
              else {
                let g = O.combine(d.map((Q) => Q.value));
                a.push(i && O.compare(g, i.facet(O)) ? i.facet(O) : g);
              }
            else {
              for (let g of d)
                g.type == 0
                  ? ((l[g.id] = (a.length << 1) | 1), a.push(g.value))
                  : ((l[g.id] = h.length << 1),
                    h.push((Q) => g.dynamicSlot(Q)));
              (l[O.id] = h.length << 1), h.push((g) => Ad(g, O, d));
            }
          }
          let f = h.map((u) => u(l));
          return new Jn(e, o, f, l, a, s);
        }
      }
      function Xd(n, e, t) {
        let i = [[], [], [], [], []],
          r = new Map();
        function s(o, l) {
          let a = r.get(o);
          if (a != null) {
            if (a <= l) return;
            let h = i[a].indexOf(o);
            h > -1 && i[a].splice(h, 1),
              o instanceof Ms && t.delete(o.compartment);
          }
          if ((r.set(o, l), Array.isArray(o))) for (let h of o) s(h, l);
          else if (o instanceof Ms) {
            if (t.has(o.compartment))
              throw new RangeError(
                "Duplicate use of compartment in extensions"
              );
            let h = e.get(o.compartment) || o.inner;
            t.set(o.compartment, h), s(h, l);
          } else if (o instanceof Uh) s(o.inner, o.prec);
          else if (o instanceof oe)
            i[l].push(o), o.provides && s(o.provides, l);
          else if (o instanceof _n)
            i[l].push(o),
              o.facet.extensions && s(o.facet.extensions, zt.default);
          else {
            let h = o.extension;
            if (!h)
              throw new Error(
                `Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`
              );
            s(h, l);
          }
        }
        return s(n, zt.default), i.reduce((o, l) => o.concat(l));
      }
      function Yi(n, e) {
        if (e & 1) return 2;
        let t = e >> 1,
          i = n.status[t];
        if (i == 4)
          throw new Error("Cyclic dependency between fields and/or facets");
        if (i & 2) return i;
        n.status[t] = 4;
        let r = n.computeSlot(n, n.config.dynamicSlots[t]);
        return (n.status[t] = 2 | r);
      }
      function er(n, e) {
        return e & 1 ? n.config.staticValues[e >> 1] : n.values[e >> 1];
      }
      const Fh = C.define(),
        Ys = C.define({ combine: (n) => n.some((e) => e), static: !0 }),
        Hh = C.define({
          combine: (n) => (n.length ? n[0] : void 0),
          static: !0,
        }),
        Kh = C.define(),
        Jh = C.define(),
        ec = C.define(),
        tc = C.define({ combine: (n) => (n.length ? n[0] : !1) });
      class Qt {
        constructor(e, t) {
          (this.type = e), (this.value = t);
        }
        static define() {
          return new Rd();
        }
      }
      class Rd {
        of(e) {
          return new Qt(this, e);
        }
      }
      class Md {
        constructor(e) {
          this.map = e;
        }
        of(e) {
          return new R(this, e);
        }
      }
      class R {
        constructor(e, t) {
          (this.type = e), (this.value = t);
        }
        map(e) {
          let t = this.type.map(this.value, e);
          return t === void 0
            ? void 0
            : t == this.value
            ? this
            : new R(this.type, t);
        }
        is(e) {
          return this.type == e;
        }
        static define(e = {}) {
          return new Md(e.map || ((t) => t));
        }
        static mapEffects(e, t) {
          if (!e.length) return e;
          let i = [];
          for (let r of e) {
            let s = r.map(t);
            s && i.push(s);
          }
          return i;
        }
      }
      R.reconfigure = R.define();
      R.appendConfig = R.define();
      class ie {
        constructor(e, t, i, r, s, o) {
          (this.startState = e),
            (this.changes = t),
            (this.selection = i),
            (this.effects = r),
            (this.annotations = s),
            (this.scrollIntoView = o),
            (this._doc = null),
            (this._state = null),
            i && Nh(i, t.newLength),
            s.some((l) => l.type == ie.time) ||
              (this.annotations = s.concat(ie.time.of(Date.now())));
        }
        static create(e, t, i, r, s, o) {
          return new ie(e, t, i, r, s, o);
        }
        get newDoc() {
          return (
            this._doc || (this._doc = this.changes.apply(this.startState.doc))
          );
        }
        get newSelection() {
          return this.selection || this.startState.selection.map(this.changes);
        }
        get state() {
          return (
            this._state || this.startState.applyTransaction(this), this._state
          );
        }
        annotation(e) {
          for (let t of this.annotations) if (t.type == e) return t.value;
        }
        get docChanged() {
          return !this.changes.empty;
        }
        get reconfigured() {
          return this.startState.config != this.state.config;
        }
        isUserEvent(e) {
          let t = this.annotation(ie.userEvent);
          return !!(
            t &&
            (t == e ||
              (t.length > e.length &&
                t.slice(0, e.length) == e &&
                t[e.length] == "."))
          );
        }
      }
      ie.time = Qt.define();
      ie.userEvent = Qt.define();
      ie.addToHistory = Qt.define();
      ie.remote = Qt.define();
      function Yd(n, e) {
        let t = [];
        for (let i = 0, r = 0; ; ) {
          let s, o;
          if (i < n.length && (r == e.length || e[r] >= n[i]))
            (s = n[i++]), (o = n[i++]);
          else if (r < e.length) (s = e[r++]), (o = e[r++]);
          else return t;
          !t.length || t[t.length - 1] < s
            ? t.push(s, o)
            : t[t.length - 1] < o && (t[t.length - 1] = o);
        }
      }
      function ic(n, e, t) {
        var i;
        let r, s, o;
        return (
          t
            ? ((r = e.changes),
              (s = re.empty(e.changes.length)),
              (o = n.changes.compose(e.changes)))
            : ((r = e.changes.map(n.changes)),
              (s = n.changes.mapDesc(e.changes, !0)),
              (o = n.changes.compose(r))),
          {
            changes: o,
            selection: e.selection
              ? e.selection.map(s)
              : (i = n.selection) === null || i === void 0
              ? void 0
              : i.map(r),
            effects: R.mapEffects(n.effects, r).concat(
              R.mapEffects(e.effects, s)
            ),
            annotations: n.annotations.length
              ? n.annotations.concat(e.annotations)
              : e.annotations,
            scrollIntoView: n.scrollIntoView || e.scrollIntoView,
          }
        );
      }
      function zs(n, e, t) {
        let i = e.selection,
          r = ei(e.annotations);
        return (
          e.userEvent && (r = r.concat(ie.userEvent.of(e.userEvent))),
          {
            changes:
              e.changes instanceof re
                ? e.changes
                : re.of(e.changes || [], t, n.facet(Hh)),
            selection: i && (i instanceof S ? i : S.single(i.anchor, i.head)),
            effects: ei(e.effects),
            annotations: r,
            scrollIntoView: !!e.scrollIntoView,
          }
        );
      }
      function nc(n, e, t) {
        let i = zs(n, e.length ? e[0] : {}, n.doc.length);
        e.length && e[0].filter === !1 && (t = !1);
        for (let s = 1; s < e.length; s++) {
          e[s].filter === !1 && (t = !1);
          let o = !!e[s].sequential;
          i = ic(i, zs(n, e[s], o ? i.changes.newLength : n.doc.length), o);
        }
        let r = ie.create(
          n,
          i.changes,
          i.selection,
          i.effects,
          i.annotations,
          i.scrollIntoView
        );
        return Dd(t ? zd(r) : r);
      }
      function zd(n) {
        let e = n.startState,
          t = !0;
        for (let r of e.facet(Kh)) {
          let s = r(n);
          if (s === !1) {
            t = !1;
            break;
          }
          Array.isArray(s) && (t = t === !0 ? s : Yd(t, s));
        }
        if (t !== !0) {
          let r, s;
          if (t === !1)
            (s = n.changes.invertedDesc), (r = re.empty(e.doc.length));
          else {
            let o = n.changes.filter(t);
            (r = o.changes), (s = o.filtered.mapDesc(o.changes).invertedDesc);
          }
          n = ie.create(
            e,
            r,
            n.selection && n.selection.map(s),
            R.mapEffects(n.effects, s),
            n.annotations,
            n.scrollIntoView
          );
        }
        let i = e.facet(Jh);
        for (let r = i.length - 1; r >= 0; r--) {
          let s = i[r](n);
          s instanceof ie
            ? (n = s)
            : Array.isArray(s) && s.length == 1 && s[0] instanceof ie
            ? (n = s[0])
            : (n = nc(e, ei(s), !1));
        }
        return n;
      }
      function Dd(n) {
        let e = n.startState,
          t = e.facet(ec),
          i = n;
        for (let r = t.length - 1; r >= 0; r--) {
          let s = t[r](n);
          s &&
            Object.keys(s).length &&
            (i = ic(i, zs(e, s, n.changes.newLength), !0));
        }
        return i == n
          ? n
          : ie.create(
              e,
              n.changes,
              n.selection,
              i.effects,
              i.annotations,
              i.scrollIntoView
            );
      }
      const Ed = [];
      function ei(n) {
        return n == null ? Ed : Array.isArray(n) ? n : [n];
      }
      var H = (function (n) {
        return (
          (n[(n.Word = 0)] = "Word"),
          (n[(n.Space = 1)] = "Space"),
          (n[(n.Other = 2)] = "Other"),
          n
        );
      })(H || (H = {}));
      const _d =
        /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
      let Ds;
      try {
        Ds = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
      } catch {}
      function Vd(n) {
        if (Ds) return Ds.test(n);
        for (let e = 0; e < n.length; e++) {
          let t = n[e];
          if (
            /\w/.test(t) ||
            (t > "" && (t.toUpperCase() != t.toLowerCase() || _d.test(t)))
          )
            return !0;
        }
        return !1;
      }
      function qd(n) {
        return (e) => {
          if (!/\S/.test(e)) return H.Space;
          if (Vd(e)) return H.Word;
          for (let t = 0; t < n.length; t++)
            if (e.indexOf(n[t]) > -1) return H.Word;
          return H.Other;
        };
      }
      class _ {
        constructor(e, t, i, r, s, o) {
          (this.config = e),
            (this.doc = t),
            (this.selection = i),
            (this.values = r),
            (this.status = e.statusTemplate.slice()),
            (this.computeSlot = s),
            o && (o._state = this);
          for (let l = 0; l < this.config.dynamicSlots.length; l++)
            Yi(this, l << 1);
          this.computeSlot = null;
        }
        field(e, t = !0) {
          let i = this.config.address[e.id];
          if (i == null) {
            if (t) throw new RangeError("Field is not present in this state");
            return;
          }
          return Yi(this, i), er(this, i);
        }
        update(...e) {
          return nc(this, e, !0);
        }
        applyTransaction(e) {
          let t = this.config,
            { base: i, compartments: r } = t;
          for (let l of e.effects)
            l.is(Cr.reconfigure)
              ? (t &&
                  ((r = new Map()),
                  t.compartments.forEach((a, h) => r.set(h, a)),
                  (t = null)),
                r.set(l.value.compartment, l.value.extension))
              : l.is(R.reconfigure)
              ? ((t = null), (i = l.value))
              : l.is(R.appendConfig) &&
                ((t = null), (i = ei(i).concat(l.value)));
          let s;
          t
            ? (s = e.startState.values.slice())
            : ((t = Jn.resolve(i, r, this)),
              (s = new _(
                t,
                this.doc,
                this.selection,
                t.dynamicSlots.map(() => null),
                (a, h) => h.reconfigure(a, this),
                null
              ).values));
          let o = e.startState.facet(Ys)
            ? e.newSelection
            : e.newSelection.asSingle();
          new _(t, e.newDoc, o, s, (l, a) => a.update(l, e), e);
        }
        replaceSelection(e) {
          return (
            typeof e == "string" && (e = this.toText(e)),
            this.changeByRange((t) => ({
              changes: { from: t.from, to: t.to, insert: e },
              range: S.cursor(t.from + e.length),
            }))
          );
        }
        changeByRange(e) {
          let t = this.selection,
            i = e(t.ranges[0]),
            r = this.changes(i.changes),
            s = [i.range],
            o = ei(i.effects);
          for (let l = 1; l < t.ranges.length; l++) {
            let a = e(t.ranges[l]),
              h = this.changes(a.changes),
              c = h.map(r);
            for (let u = 0; u < l; u++) s[u] = s[u].map(c);
            let f = r.mapDesc(h, !0);
            s.push(a.range.map(f)),
              (r = r.compose(c)),
              (o = R.mapEffects(o, c).concat(R.mapEffects(ei(a.effects), f)));
          }
          return {
            changes: r,
            selection: S.create(s, t.mainIndex),
            effects: o,
          };
        }
        changes(e = []) {
          return e instanceof re
            ? e
            : re.of(e, this.doc.length, this.facet(_.lineSeparator));
        }
        toText(e) {
          return E.of(e.split(this.facet(_.lineSeparator) || Zs));
        }
        sliceDoc(e = 0, t = this.doc.length) {
          return this.doc.sliceString(e, t, this.lineBreak);
        }
        facet(e) {
          let t = this.config.address[e.id];
          return t == null ? e.default : (Yi(this, t), er(this, t));
        }
        toJSON(e) {
          let t = { doc: this.sliceDoc(), selection: this.selection.toJSON() };
          if (e)
            for (let i in e) {
              let r = e[i];
              r instanceof oe &&
                this.config.address[r.id] != null &&
                (t[i] = r.spec.toJSON(this.field(e[i]), this));
            }
          return t;
        }
        static fromJSON(e, t = {}, i) {
          if (!e || typeof e.doc != "string")
            throw new RangeError("Invalid JSON representation for EditorState");
          let r = [];
          if (i) {
            for (let s in i)
              if (Object.prototype.hasOwnProperty.call(e, s)) {
                let o = i[s],
                  l = e[s];
                r.push(o.init((a) => o.spec.fromJSON(l, a)));
              }
          }
          return _.create({
            doc: e.doc,
            selection: S.fromJSON(e.selection),
            extensions: t.extensions ? r.concat([t.extensions]) : r,
          });
        }
        static create(e = {}) {
          let t = Jn.resolve(e.extensions || [], new Map()),
            i =
              e.doc instanceof E
                ? e.doc
                : E.of(
                    (e.doc || "").split(t.staticFacet(_.lineSeparator) || Zs)
                  ),
            r = e.selection
              ? e.selection instanceof S
                ? e.selection
                : S.single(e.selection.anchor, e.selection.head)
              : S.single(0);
          return (
            Nh(r, i.length),
            t.staticFacet(Ys) || (r = r.asSingle()),
            new _(
              t,
              i,
              r,
              t.dynamicSlots.map(() => null),
              (s, o) => o.create(s),
              null
            )
          );
        }
        get tabSize() {
          return this.facet(_.tabSize);
        }
        get lineBreak() {
          return (
            this.facet(_.lineSeparator) ||
            `
`
          );
        }
        get readOnly() {
          return this.facet(tc);
        }
        phrase(e, ...t) {
          for (let i of this.facet(_.phrases))
            if (Object.prototype.hasOwnProperty.call(i, e)) {
              e = i[e];
              break;
            }
          return (
            t.length &&
              (e = e.replace(/\$(\$|\d*)/g, (i, r) => {
                if (r == "$") return "$";
                let s = +(r || 1);
                return !s || s > t.length ? i : t[s - 1];
              })),
            e
          );
        }
        languageDataAt(e, t, i = -1) {
          let r = [];
          for (let s of this.facet(Fh))
            for (let o of s(this, t, i))
              Object.prototype.hasOwnProperty.call(o, e) && r.push(o[e]);
          return r;
        }
        charCategorizer(e) {
          return qd(this.languageDataAt("wordChars", e).join(""));
        }
        wordAt(e) {
          let { text: t, from: i, length: r } = this.doc.lineAt(e),
            s = this.charCategorizer(e),
            o = e - i,
            l = e - i;
          for (; o > 0; ) {
            let a = fe(t, o, !1);
            if (s(t.slice(a, o)) != H.Word) break;
            o = a;
          }
          for (; l < r; ) {
            let a = fe(t, l);
            if (s(t.slice(l, a)) != H.Word) break;
            l = a;
          }
          return o == l ? null : S.range(o + i, l + i);
        }
      }
      _.allowMultipleSelections = Ys;
      _.tabSize = C.define({ combine: (n) => (n.length ? n[0] : 4) });
      _.lineSeparator = Hh;
      _.readOnly = tc;
      _.phrases = C.define({
        compare(n, e) {
          let t = Object.keys(n),
            i = Object.keys(e);
          return t.length == i.length && t.every((r) => n[r] == e[r]);
        },
      });
      _.languageData = Fh;
      _.changeFilter = Kh;
      _.transactionFilter = Jh;
      _.transactionExtender = ec;
      Cr.reconfigure = R.define();
      function lt(n, e, t = {}) {
        let i = {};
        for (let r of n)
          for (let s of Object.keys(r)) {
            let o = r[s],
              l = i[s];
            if (l === void 0) i[s] = o;
            else if (!(l === o || o === void 0))
              if (Object.hasOwnProperty.call(t, s)) i[s] = t[s](l, o);
              else throw new Error("Config merge conflict for field " + s);
          }
        for (let r in e) i[r] === void 0 && (i[r] = e[r]);
        return i;
      }
      class qt {
        eq(e) {
          return this == e;
        }
        range(e, t = e) {
          return Es.create(e, t, this);
        }
      }
      qt.prototype.startSide = qt.prototype.endSide = 0;
      qt.prototype.point = !1;
      qt.prototype.mapMode = ce.TrackDel;
      let Es = class rc {
        constructor(e, t, i) {
          (this.from = e), (this.to = t), (this.value = i);
        }
        static create(e, t, i) {
          return new rc(e, t, i);
        }
      };
      function _s(n, e) {
        return n.from - e.from || n.value.startSide - e.value.startSide;
      }
      class Xo {
        constructor(e, t, i, r) {
          (this.from = e), (this.to = t), (this.value = i), (this.maxPoint = r);
        }
        get length() {
          return this.to[this.to.length - 1];
        }
        findIndex(e, t, i, r = 0) {
          let s = i ? this.to : this.from;
          for (let o = r, l = s.length; ; ) {
            if (o == l) return o;
            let a = (o + l) >> 1,
              h =
                s[a] - e ||
                (i ? this.value[a].endSide : this.value[a].startSide) - t;
            if (a == o) return h >= 0 ? o : l;
            h >= 0 ? (l = a) : (o = a + 1);
          }
        }
        between(e, t, i, r) {
          for (
            let s = this.findIndex(t, -1e9, !0),
              o = this.findIndex(i, 1e9, !1, s);
            s < o;
            s++
          )
            if (r(this.from[s] + e, this.to[s] + e, this.value[s]) === !1)
              return !1;
        }
        map(e, t) {
          let i = [],
            r = [],
            s = [],
            o = -1,
            l = -1;
          for (let a = 0; a < this.value.length; a++) {
            let h = this.value[a],
              c = this.from[a] + e,
              f = this.to[a] + e,
              u,
              d;
            if (c == f) {
              let O = t.mapPos(c, h.startSide, h.mapMode);
              if (
                O == null ||
                ((u = d = O),
                h.startSide != h.endSide &&
                  ((d = t.mapPos(c, h.endSide)), d < u))
              )
                continue;
            } else if (
              ((u = t.mapPos(c, h.startSide)),
              (d = t.mapPos(f, h.endSide)),
              u > d || (u == d && h.startSide > 0 && h.endSide <= 0))
            )
              continue;
            (d - u || h.endSide - h.startSide) < 0 ||
              (o < 0 && (o = u),
              h.point && (l = Math.max(l, d - u)),
              i.push(h),
              r.push(u - o),
              s.push(d - o));
          }
          return { mapped: i.length ? new Xo(r, s, i, l) : null, pos: o };
        }
      }
      class V {
        constructor(e, t, i, r) {
          (this.chunkPos = e),
            (this.chunk = t),
            (this.nextLayer = i),
            (this.maxPoint = r);
        }
        static create(e, t, i, r) {
          return new V(e, t, i, r);
        }
        get length() {
          let e = this.chunk.length - 1;
          return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
        }
        get size() {
          if (this.isEmpty) return 0;
          let e = this.nextLayer.size;
          for (let t of this.chunk) e += t.value.length;
          return e;
        }
        chunkEnd(e) {
          return this.chunkPos[e] + this.chunk[e].length;
        }
        update(e) {
          let {
              add: t = [],
              sort: i = !1,
              filterFrom: r = 0,
              filterTo: s = this.length,
            } = e,
            o = e.filter;
          if (t.length == 0 && !o) return this;
          if ((i && (t = t.slice().sort(_s)), this.isEmpty))
            return t.length ? V.of(t) : this;
          let l = new sc(this, null, -1).goto(0),
            a = 0,
            h = [],
            c = new pt();
          for (; l.value || a < t.length; )
            if (
              a < t.length &&
              (l.from - t[a].from || l.startSide - t[a].value.startSide) >= 0
            ) {
              let f = t[a++];
              c.addInner(f.from, f.to, f.value) || h.push(f);
            } else
              l.rangeIndex == 1 &&
              l.chunkIndex < this.chunk.length &&
              (a == t.length || this.chunkEnd(l.chunkIndex) < t[a].from) &&
              (!o ||
                r > this.chunkEnd(l.chunkIndex) ||
                s < this.chunkPos[l.chunkIndex]) &&
              c.addChunk(this.chunkPos[l.chunkIndex], this.chunk[l.chunkIndex])
                ? l.nextChunk()
                : ((!o || r > l.to || s < l.from || o(l.from, l.to, l.value)) &&
                    (c.addInner(l.from, l.to, l.value) ||
                      h.push(Es.create(l.from, l.to, l.value))),
                  l.next());
          return c.finishInner(
            this.nextLayer.isEmpty && !h.length
              ? V.empty
              : this.nextLayer.update({
                  add: h,
                  filter: o,
                  filterFrom: r,
                  filterTo: s,
                })
          );
        }
        map(e) {
          if (e.empty || this.isEmpty) return this;
          let t = [],
            i = [],
            r = -1;
          for (let o = 0; o < this.chunk.length; o++) {
            let l = this.chunkPos[o],
              a = this.chunk[o],
              h = e.touchesRange(l, l + a.length);
            if (h === !1)
              (r = Math.max(r, a.maxPoint)), t.push(a), i.push(e.mapPos(l));
            else if (h === !0) {
              let { mapped: c, pos: f } = a.map(l, e);
              c && ((r = Math.max(r, c.maxPoint)), t.push(c), i.push(f));
            }
          }
          let s = this.nextLayer.map(e);
          return t.length == 0 ? s : new V(i, t, s || V.empty, r);
        }
        between(e, t, i) {
          if (!this.isEmpty) {
            for (let r = 0; r < this.chunk.length; r++) {
              let s = this.chunkPos[r],
                o = this.chunk[r];
              if (
                t >= s &&
                e <= s + o.length &&
                o.between(s, e - s, t - s, i) === !1
              )
                return;
            }
            this.nextLayer.between(e, t, i);
          }
        }
        iter(e = 0) {
          return qi.from([this]).goto(e);
        }
        get isEmpty() {
          return this.nextLayer == this;
        }
        static iter(e, t = 0) {
          return qi.from(e).goto(t);
        }
        static compare(e, t, i, r, s = -1) {
          let o = e.filter(
              (f) => f.maxPoint > 0 || (!f.isEmpty && f.maxPoint >= s)
            ),
            l = t.filter(
              (f) => f.maxPoint > 0 || (!f.isEmpty && f.maxPoint >= s)
            ),
            a = wl(o, l, i),
            h = new xi(o, a, s),
            c = new xi(l, a, s);
          i.iterGaps((f, u, d) => kl(h, f, c, u, d, r)),
            i.empty && i.length == 0 && kl(h, 0, c, 0, 0, r);
        }
        static eq(e, t, i = 0, r) {
          r == null && (r = 999999999);
          let s = e.filter((c) => !c.isEmpty && t.indexOf(c) < 0),
            o = t.filter((c) => !c.isEmpty && e.indexOf(c) < 0);
          if (s.length != o.length) return !1;
          if (!s.length) return !0;
          let l = wl(s, o),
            a = new xi(s, l, 0).goto(i),
            h = new xi(o, l, 0).goto(i);
          for (;;) {
            if (
              a.to != h.to ||
              !Vs(a.active, h.active) ||
              (a.point && (!h.point || !a.point.eq(h.point)))
            )
              return !1;
            if (a.to > r) return !0;
            a.next(), h.next();
          }
        }
        static spans(e, t, i, r, s = -1) {
          let o = new xi(e, null, s).goto(t),
            l = t,
            a = o.openStart;
          for (;;) {
            let h = Math.min(o.to, i);
            if (o.point) {
              let c = o.activeForPoint(o.to),
                f =
                  o.pointFrom < t
                    ? c.length + 1
                    : o.point.startSide < 0
                    ? c.length
                    : Math.min(c.length, a);
              r.point(l, h, o.point, c, f, o.pointRank),
                (a = Math.min(o.openEnd(h), c.length));
            } else h > l && (r.span(l, h, o.active, a), (a = o.openEnd(h)));
            if (o.to > i) return a + (o.point && o.to > i ? 1 : 0);
            (l = o.to), o.next();
          }
        }
        static of(e, t = !1) {
          let i = new pt();
          for (let r of e instanceof Es ? [e] : t ? Wd(e) : e)
            i.add(r.from, r.to, r.value);
          return i.finish();
        }
        static join(e) {
          if (!e.length) return V.empty;
          let t = e[e.length - 1];
          for (let i = e.length - 2; i >= 0; i--)
            for (let r = e[i]; r != V.empty; r = r.nextLayer)
              t = new V(
                r.chunkPos,
                r.chunk,
                t,
                Math.max(r.maxPoint, t.maxPoint)
              );
          return t;
        }
      }
      V.empty = new V([], [], null, -1);
      function Wd(n) {
        if (n.length > 1)
          for (let e = n[0], t = 1; t < n.length; t++) {
            let i = n[t];
            if (_s(e, i) > 0) return n.slice().sort(_s);
            e = i;
          }
        return n;
      }
      V.empty.nextLayer = V.empty;
      class pt {
        finishChunk(e) {
          this.chunks.push(
            new Xo(this.from, this.to, this.value, this.maxPoint)
          ),
            this.chunkPos.push(this.chunkStart),
            (this.chunkStart = -1),
            (this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint)),
            (this.maxPoint = -1),
            e && ((this.from = []), (this.to = []), (this.value = []));
        }
        constructor() {
          (this.chunks = []),
            (this.chunkPos = []),
            (this.chunkStart = -1),
            (this.last = null),
            (this.lastFrom = -1e9),
            (this.lastTo = -1e9),
            (this.from = []),
            (this.to = []),
            (this.value = []),
            (this.maxPoint = -1),
            (this.setMaxPoint = -1),
            (this.nextLayer = null);
        }
        add(e, t, i) {
          this.addInner(e, t, i) ||
            (this.nextLayer || (this.nextLayer = new pt())).add(e, t, i);
        }
        addInner(e, t, i) {
          let r = e - this.lastTo || i.startSide - this.last.endSide;
          if (
            r <= 0 &&
            (e - this.lastFrom || i.startSide - this.last.startSide) < 0
          )
            throw new Error(
              "Ranges must be added sorted by `from` position and `startSide`"
            );
          return r < 0
            ? !1
            : (this.from.length == 250 && this.finishChunk(!0),
              this.chunkStart < 0 && (this.chunkStart = e),
              this.from.push(e - this.chunkStart),
              this.to.push(t - this.chunkStart),
              (this.last = i),
              (this.lastFrom = e),
              (this.lastTo = t),
              this.value.push(i),
              i.point && (this.maxPoint = Math.max(this.maxPoint, t - e)),
              !0);
        }
        addChunk(e, t) {
          if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
            return !1;
          this.from.length && this.finishChunk(!0),
            (this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint)),
            this.chunks.push(t),
            this.chunkPos.push(e);
          let i = t.value.length - 1;
          return (
            (this.last = t.value[i]),
            (this.lastFrom = t.from[i] + e),
            (this.lastTo = t.to[i] + e),
            !0
          );
        }
        finish() {
          return this.finishInner(V.empty);
        }
        finishInner(e) {
          if (
            (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
          )
            return e;
          let t = V.create(
            this.chunkPos,
            this.chunks,
            this.nextLayer ? this.nextLayer.finishInner(e) : e,
            this.setMaxPoint
          );
          return (this.from = null), t;
        }
      }
      function wl(n, e, t) {
        let i = new Map();
        for (let s of n)
          for (let o = 0; o < s.chunk.length; o++)
            s.chunk[o].maxPoint <= 0 && i.set(s.chunk[o], s.chunkPos[o]);
        let r = new Set();
        for (let s of e)
          for (let o = 0; o < s.chunk.length; o++) {
            let l = i.get(s.chunk[o]);
            l != null &&
              (t ? t.mapPos(l) : l) == s.chunkPos[o] &&
              !t?.touchesRange(l, l + s.chunk[o].length) &&
              r.add(s.chunk[o]);
          }
        return r;
      }
      class sc {
        constructor(e, t, i, r = 0) {
          (this.layer = e),
            (this.skip = t),
            (this.minPoint = i),
            (this.rank = r);
        }
        get startSide() {
          return this.value ? this.value.startSide : 0;
        }
        get endSide() {
          return this.value ? this.value.endSide : 0;
        }
        goto(e, t = -1e9) {
          return (
            (this.chunkIndex = this.rangeIndex = 0),
            this.gotoInner(e, t, !1),
            this
          );
        }
        gotoInner(e, t, i) {
          for (; this.chunkIndex < this.layer.chunk.length; ) {
            let r = this.layer.chunk[this.chunkIndex];
            if (
              !(
                (this.skip && this.skip.has(r)) ||
                this.layer.chunkEnd(this.chunkIndex) < e ||
                r.maxPoint < this.minPoint
              )
            )
              break;
            this.chunkIndex++, (i = !1);
          }
          if (this.chunkIndex < this.layer.chunk.length) {
            let r = this.layer.chunk[this.chunkIndex].findIndex(
              e - this.layer.chunkPos[this.chunkIndex],
              t,
              !0
            );
            (!i || this.rangeIndex < r) && this.setRangeIndex(r);
          }
          this.next();
        }
        forward(e, t) {
          (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0);
        }
        next() {
          for (;;)
            if (this.chunkIndex == this.layer.chunk.length) {
              (this.from = this.to = 1e9), (this.value = null);
              break;
            } else {
              let e = this.layer.chunkPos[this.chunkIndex],
                t = this.layer.chunk[this.chunkIndex],
                i = e + t.from[this.rangeIndex];
              if (
                ((this.from = i),
                (this.to = e + t.to[this.rangeIndex]),
                (this.value = t.value[this.rangeIndex]),
                this.setRangeIndex(this.rangeIndex + 1),
                this.minPoint < 0 ||
                  (this.value.point && this.to - this.from >= this.minPoint))
              )
                break;
            }
        }
        setRangeIndex(e) {
          if (e == this.layer.chunk[this.chunkIndex].value.length) {
            if ((this.chunkIndex++, this.skip))
              for (
                ;
                this.chunkIndex < this.layer.chunk.length &&
                this.skip.has(this.layer.chunk[this.chunkIndex]);

              )
                this.chunkIndex++;
            this.rangeIndex = 0;
          } else this.rangeIndex = e;
        }
        nextChunk() {
          this.chunkIndex++, (this.rangeIndex = 0), this.next();
        }
        compare(e) {
          return (
            this.from - e.from ||
            this.startSide - e.startSide ||
            this.rank - e.rank ||
            this.to - e.to ||
            this.endSide - e.endSide
          );
        }
      }
      class qi {
        constructor(e) {
          this.heap = e;
        }
        static from(e, t = null, i = -1) {
          let r = [];
          for (let s = 0; s < e.length; s++)
            for (let o = e[s]; !o.isEmpty; o = o.nextLayer)
              o.maxPoint >= i && r.push(new sc(o, t, i, s));
          return r.length == 1 ? r[0] : new qi(r);
        }
        get startSide() {
          return this.value ? this.value.startSide : 0;
        }
        goto(e, t = -1e9) {
          for (let i of this.heap) i.goto(e, t);
          for (let i = this.heap.length >> 1; i >= 0; i--) Nr(this.heap, i);
          return this.next(), this;
        }
        forward(e, t) {
          for (let i of this.heap) i.forward(e, t);
          for (let i = this.heap.length >> 1; i >= 0; i--) Nr(this.heap, i);
          (this.to - e || this.value.endSide - t) < 0 && this.next();
        }
        next() {
          if (this.heap.length == 0)
            (this.from = this.to = 1e9), (this.value = null), (this.rank = -1);
          else {
            let e = this.heap[0];
            (this.from = e.from),
              (this.to = e.to),
              (this.value = e.value),
              (this.rank = e.rank),
              e.value && e.next(),
              Nr(this.heap, 0);
          }
        }
      }
      function Nr(n, e) {
        for (let t = n[e]; ; ) {
          let i = (e << 1) + 1;
          if (i >= n.length) break;
          let r = n[i];
          if (
            (i + 1 < n.length &&
              r.compare(n[i + 1]) >= 0 &&
              ((r = n[i + 1]), i++),
            t.compare(r) < 0)
          )
            break;
          (n[i] = t), (n[e] = r), (e = i);
        }
      }
      class xi {
        constructor(e, t, i) {
          (this.minPoint = i),
            (this.active = []),
            (this.activeTo = []),
            (this.activeRank = []),
            (this.minActive = -1),
            (this.point = null),
            (this.pointFrom = 0),
            (this.pointRank = 0),
            (this.to = -1e9),
            (this.endSide = 0),
            (this.openStart = -1),
            (this.cursor = qi.from(e, t, i));
        }
        goto(e, t = -1e9) {
          return (
            this.cursor.goto(e, t),
            (this.active.length =
              this.activeTo.length =
              this.activeRank.length =
                0),
            (this.minActive = -1),
            (this.to = e),
            (this.endSide = t),
            (this.openStart = -1),
            this.next(),
            this
          );
        }
        forward(e, t) {
          for (
            ;
            this.minActive > -1 &&
            (this.activeTo[this.minActive] - e ||
              this.active[this.minActive].endSide - t) < 0;

          )
            this.removeActive(this.minActive);
          this.cursor.forward(e, t);
        }
        removeActive(e) {
          mn(this.active, e),
            mn(this.activeTo, e),
            mn(this.activeRank, e),
            (this.minActive = $l(this.active, this.activeTo));
        }
        addActive(e) {
          let t = 0,
            { value: i, to: r, rank: s } = this.cursor;
          for (
            ;
            t < this.activeRank.length &&
            (s - this.activeRank[t] || r - this.activeTo[t]) > 0;

          )
            t++;
          gn(this.active, t, i),
            gn(this.activeTo, t, r),
            gn(this.activeRank, t, s),
            e && gn(e, t, this.cursor.from),
            (this.minActive = $l(this.active, this.activeTo));
        }
        next() {
          let e = this.to,
            t = this.point;
          this.point = null;
          let i = this.openStart < 0 ? [] : null;
          for (;;) {
            let r = this.minActive;
            if (
              r > -1 &&
              (this.activeTo[r] - this.cursor.from ||
                this.active[r].endSide - this.cursor.startSide) < 0
            ) {
              if (this.activeTo[r] > e) {
                (this.to = this.activeTo[r]),
                  (this.endSide = this.active[r].endSide);
                break;
              }
              this.removeActive(r), i && mn(i, r);
            } else if (this.cursor.value)
              if (this.cursor.from > e) {
                (this.to = this.cursor.from),
                  (this.endSide = this.cursor.startSide);
                break;
              } else {
                let s = this.cursor.value;
                if (!s.point) this.addActive(i), this.cursor.next();
                else if (
                  t &&
                  this.cursor.to == this.to &&
                  this.cursor.from < this.cursor.to
                )
                  this.cursor.next();
                else {
                  (this.point = s),
                    (this.pointFrom = this.cursor.from),
                    (this.pointRank = this.cursor.rank),
                    (this.to = this.cursor.to),
                    (this.endSide = s.endSide),
                    this.cursor.next(),
                    this.forward(this.to, this.endSide);
                  break;
                }
              }
            else {
              this.to = this.endSide = 1e9;
              break;
            }
          }
          if (i) {
            this.openStart = 0;
            for (let r = i.length - 1; r >= 0 && i[r] < e; r--)
              this.openStart++;
          }
        }
        activeForPoint(e) {
          if (!this.active.length) return this.active;
          let t = [];
          for (
            let i = this.active.length - 1;
            i >= 0 && !(this.activeRank[i] < this.pointRank);
            i--
          )
            (this.activeTo[i] > e ||
              (this.activeTo[i] == e &&
                this.active[i].endSide >= this.point.endSide)) &&
              t.push(this.active[i]);
          return t.reverse();
        }
        openEnd(e) {
          let t = 0;
          for (
            let i = this.activeTo.length - 1;
            i >= 0 && this.activeTo[i] > e;
            i--
          )
            t++;
          return t;
        }
      }
      function kl(n, e, t, i, r, s) {
        n.goto(e), t.goto(i);
        let o = i + r,
          l = i,
          a = i - e;
        for (;;) {
          let h = n.to + a - t.to,
            c = h || n.endSide - t.endSide,
            f = c < 0 ? n.to + a : t.to,
            u = Math.min(f, o);
          if (
            (n.point || t.point
              ? (n.point &&
                  t.point &&
                  (n.point == t.point || n.point.eq(t.point)) &&
                  Vs(n.activeForPoint(n.to), t.activeForPoint(t.to))) ||
                s.comparePoint(l, u, n.point, t.point)
              : u > l &&
                !Vs(n.active, t.active) &&
                s.compareRange(l, u, n.active, t.active),
            f > o)
          )
            break;
          (h || n.openEnd != t.openEnd) && s.boundChange && s.boundChange(f),
            (l = f),
            c <= 0 && n.next(),
            c >= 0 && t.next();
        }
      }
      function Vs(n, e) {
        if (n.length != e.length) return !1;
        for (let t = 0; t < n.length; t++)
          if (n[t] != e[t] && !n[t].eq(e[t])) return !1;
        return !0;
      }
      function mn(n, e) {
        for (let t = e, i = n.length - 1; t < i; t++) n[t] = n[t + 1];
        n.pop();
      }
      function gn(n, e, t) {
        for (let i = n.length - 1; i >= e; i--) n[i + 1] = n[i];
        n[e] = t;
      }
      function $l(n, e) {
        let t = -1,
          i = 1e9;
        for (let r = 0; r < e.length; r++)
          (e[r] - i || n[r].endSide - n[t].endSide) < 0 &&
            ((t = r), (i = e[r]));
        return t;
      }
      function gi(n, e, t = n.length) {
        let i = 0;
        for (let r = 0; r < t && r < n.length; )
          n.charCodeAt(r) == 9
            ? ((i += e - (i % e)), r++)
            : (i++, (r = fe(n, r)));
        return i;
      }
      function qs(n, e, t, i) {
        for (let r = 0, s = 0; ; ) {
          if (s >= e) return r;
          if (r == n.length) break;
          (s += n.charCodeAt(r) == 9 ? t - (s % t) : 1), (r = fe(n, r));
        }
        return i === !0 ? -1 : n.length;
      }
      const Ws = "",
        Pl = typeof Symbol > "u" ? "__" + Ws : Symbol.for(Ws),
        Ls =
          typeof Symbol > "u"
            ? "__styleSet" + Math.floor(Math.random() * 1e8)
            : Symbol("styleSet"),
        vl =
          typeof globalThis < "u"
            ? globalThis
            : typeof window < "u"
            ? window
            : {};
      class vt {
        constructor(e, t) {
          this.rules = [];
          let { finish: i } = t || {};
          function r(o) {
            return /^@/.test(o) ? [o] : o.split(/,\s*/);
          }
          function s(o, l, a, h) {
            let c = [],
              f = /^@(\w+)\b/.exec(o[0]),
              u = f && f[1] == "keyframes";
            if (f && l == null) return a.push(o[0] + ";");
            for (let d in l) {
              let O = l[d];
              if (/&/.test(d))
                s(
                  d
                    .split(/,\s*/)
                    .map((m) => o.map((g) => m.replace(/&/, g)))
                    .reduce((m, g) => m.concat(g)),
                  O,
                  a
                );
              else if (O && typeof O == "object") {
                if (!f)
                  throw new RangeError(
                    "The value of a property (" +
                      d +
                      ") should be a primitive value."
                  );
                s(r(d), O, c, u);
              } else
                O != null &&
                  c.push(
                    d
                      .replace(/_.*/, "")
                      .replace(/[A-Z]/g, (m) => "-" + m.toLowerCase()) +
                      ": " +
                      O +
                      ";"
                  );
            }
            (c.length || u) &&
              a.push(
                (i && !f && !h ? o.map(i) : o).join(", ") +
                  " {" +
                  c.join(" ") +
                  "}"
              );
          }
          for (let o in e) s(r(o), e[o], this.rules);
        }
        getRules() {
          return this.rules.join(`
`);
        }
        static newName() {
          let e = vl[Pl] || 1;
          return (vl[Pl] = e + 1), Ws + e.toString(36);
        }
        static mount(e, t, i) {
          let r = e[Ls],
            s = i && i.nonce;
          r ? s && r.setNonce(s) : (r = new Ld(e, s)),
            r.mount(Array.isArray(t) ? t : [t], e);
        }
      }
      let Tl = new Map();
      class Ld {
        constructor(e, t) {
          let i = e.ownerDocument || e,
            r = i.defaultView;
          if (!e.head && e.adoptedStyleSheets && r.CSSStyleSheet) {
            let s = Tl.get(i);
            if (s) return (e[Ls] = s);
            (this.sheet = new r.CSSStyleSheet()), Tl.set(i, this);
          } else
            (this.styleTag = i.createElement("style")),
              t && this.styleTag.setAttribute("nonce", t);
          (this.modules = []), (e[Ls] = this);
        }
        mount(e, t) {
          let i = this.sheet,
            r = 0,
            s = 0;
          for (let o = 0; o < e.length; o++) {
            let l = e[o],
              a = this.modules.indexOf(l);
            if (
              (a < s && a > -1 && (this.modules.splice(a, 1), s--, (a = -1)),
              a == -1)
            ) {
              if ((this.modules.splice(s++, 0, l), i))
                for (let h = 0; h < l.rules.length; h++)
                  i.insertRule(l.rules[h], r++);
            } else {
              for (; s < a; ) r += this.modules[s++].rules.length;
              (r += l.rules.length), s++;
            }
          }
          if (i)
            t.adoptedStyleSheets.indexOf(this.sheet) < 0 &&
              (t.adoptedStyleSheets = [this.sheet, ...t.adoptedStyleSheets]);
          else {
            let o = "";
            for (let a = 0; a < this.modules.length; a++)
              o +=
                this.modules[a].getRules() +
                `
`;
            this.styleTag.textContent = o;
            let l = t.head || t;
            this.styleTag.parentNode != l &&
              l.insertBefore(this.styleTag, l.firstChild);
          }
        }
        setNonce(e) {
          this.styleTag &&
            this.styleTag.getAttribute("nonce") != e &&
            this.styleTag.setAttribute("nonce", e);
        }
      }
      var Tt = {
          8: "Backspace",
          9: "Tab",
          10: "Enter",
          12: "NumLock",
          13: "Enter",
          16: "Shift",
          17: "Control",
          18: "Alt",
          20: "CapsLock",
          27: "Escape",
          32: " ",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "ArrowLeft",
          38: "ArrowUp",
          39: "ArrowRight",
          40: "ArrowDown",
          44: "PrintScreen",
          45: "Insert",
          46: "Delete",
          59: ";",
          61: "=",
          91: "Meta",
          92: "Meta",
          106: "*",
          107: "+",
          108: ",",
          109: "-",
          110: ".",
          111: "/",
          144: "NumLock",
          145: "ScrollLock",
          160: "Shift",
          161: "Shift",
          162: "Control",
          163: "Control",
          164: "Alt",
          165: "Alt",
          173: "-",
          186: ";",
          187: "=",
          188: ",",
          189: "-",
          190: ".",
          191: "/",
          192: "`",
          219: "[",
          220: "\\",
          221: "]",
          222: "'",
        },
        Wi = {
          48: ")",
          49: "!",
          50: "@",
          51: "#",
          52: "$",
          53: "%",
          54: "^",
          55: "&",
          56: "*",
          57: "(",
          59: ":",
          61: "+",
          173: "_",
          186: ":",
          187: "+",
          188: "<",
          189: "_",
          190: ">",
          191: "?",
          192: "~",
          219: "{",
          220: "|",
          221: "}",
          222: '"',
        },
        jd = typeof navigator < "u" && /Mac/.test(navigator.platform),
        Bd =
          typeof navigator < "u" &&
          /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(
            navigator.userAgent
          );
      for (var he = 0; he < 10; he++) Tt[48 + he] = Tt[96 + he] = String(he);
      for (var he = 1; he <= 24; he++) Tt[he + 111] = "F" + he;
      for (var he = 65; he <= 90; he++)
        (Tt[he] = String.fromCharCode(he + 32)),
          (Wi[he] = String.fromCharCode(he));
      for (var Ur in Tt) Wi.hasOwnProperty(Ur) || (Wi[Ur] = Tt[Ur]);
      function Id(n) {
        var e =
            (jd && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey) ||
            (Bd && n.shiftKey && n.key && n.key.length == 1) ||
            n.key == "Unidentified",
          t =
            (!e && n.key) ||
            (n.shiftKey ? Wi : Tt)[n.keyCode] ||
            n.key ||
            "Unidentified";
        return (
          t == "Esc" && (t = "Escape"),
          t == "Del" && (t = "Delete"),
          t == "Left" && (t = "ArrowLeft"),
          t == "Up" && (t = "ArrowUp"),
          t == "Right" && (t = "ArrowRight"),
          t == "Down" && (t = "ArrowDown"),
          t
        );
      }
      function j() {
        var n = arguments[0];
        typeof n == "string" && (n = document.createElement(n));
        var e = 1,
          t = arguments[1];
        if (
          t &&
          typeof t == "object" &&
          t.nodeType == null &&
          !Array.isArray(t)
        ) {
          for (var i in t)
            if (Object.prototype.hasOwnProperty.call(t, i)) {
              var r = t[i];
              typeof r == "string"
                ? n.setAttribute(i, r)
                : r != null && (n[i] = r);
            }
          e++;
        }
        for (; e < arguments.length; e++) oc(n, arguments[e]);
        return n;
      }
      function oc(n, e) {
        if (typeof e == "string") n.appendChild(document.createTextNode(e));
        else if (e != null)
          if (e.nodeType != null) n.appendChild(e);
          else if (Array.isArray(e))
            for (var t = 0; t < e.length; t++) oc(n, e[t]);
          else throw new RangeError("Unsupported child node: " + e);
      }
      function Li(n) {
        let e;
        return (
          n.nodeType == 11
            ? (e = n.getSelection ? n : n.ownerDocument)
            : (e = n),
          e.getSelection()
        );
      }
      function js(n, e) {
        return e
          ? n == e || n.contains(e.nodeType != 1 ? e.parentNode : e)
          : !1;
      }
      function Vn(n, e) {
        if (!e.anchorNode) return !1;
        try {
          return js(n, e.anchorNode);
        } catch {
          return !1;
        }
      }
      function ji(n) {
        return n.nodeType == 3
          ? Lt(n, 0, n.nodeValue.length).getClientRects()
          : n.nodeType == 1
          ? n.getClientRects()
          : [];
      }
      function zi(n, e, t, i) {
        return t ? Cl(n, e, t, i, -1) || Cl(n, e, t, i, 1) : !1;
      }
      function Wt(n) {
        for (var e = 0; ; e++) if (((n = n.previousSibling), !n)) return e;
      }
      function tr(n) {
        return (
          n.nodeType == 1 &&
          /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(n.nodeName)
        );
      }
      function Cl(n, e, t, i, r) {
        for (;;) {
          if (n == t && e == i) return !0;
          if (e == (r < 0 ? 0 : ot(n))) {
            if (n.nodeName == "DIV") return !1;
            let s = n.parentNode;
            if (!s || s.nodeType != 1) return !1;
            (e = Wt(n) + (r < 0 ? 0 : 1)), (n = s);
          } else if (n.nodeType == 1) {
            if (
              ((n = n.childNodes[e + (r < 0 ? -1 : 0)]),
              n.nodeType == 1 && n.contentEditable == "false")
            )
              return !1;
            e = r < 0 ? ot(n) : 0;
          } else return !1;
        }
      }
      function ot(n) {
        return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
      }
      function Zr(n, e) {
        let t = e ? n.left : n.right;
        return { left: t, right: t, top: n.top, bottom: n.bottom };
      }
      function Gd(n) {
        let e = n.visualViewport;
        return e
          ? { left: 0, right: e.width, top: 0, bottom: e.height }
          : { left: 0, right: n.innerWidth, top: 0, bottom: n.innerHeight };
      }
      function lc(n, e) {
        let t = e.width / n.offsetWidth,
          i = e.height / n.offsetHeight;
        return (
          ((t > 0.995 && t < 1.005) ||
            !isFinite(t) ||
            Math.abs(e.width - n.offsetWidth) < 1) &&
            (t = 1),
          ((i > 0.995 && i < 1.005) ||
            !isFinite(i) ||
            Math.abs(e.height - n.offsetHeight) < 1) &&
            (i = 1),
          { scaleX: t, scaleY: i }
        );
      }
      function Nd(n, e, t, i, r, s, o, l) {
        let a = n.ownerDocument,
          h = a.defaultView || window;
        for (let c = n, f = !1; c && !f; )
          if (c.nodeType == 1) {
            let u,
              d = c == a.body,
              O = 1,
              m = 1;
            if (d) u = Gd(h);
            else {
              if (
                (/^(fixed|sticky)$/.test(getComputedStyle(c).position) &&
                  (f = !0),
                c.scrollHeight <= c.clientHeight &&
                  c.scrollWidth <= c.clientWidth)
              ) {
                c = c.assignedSlot || c.parentNode;
                continue;
              }
              let y = c.getBoundingClientRect();
              ({ scaleX: O, scaleY: m } = lc(c, y)),
                (u = {
                  left: y.left,
                  right: y.left + c.clientWidth * O,
                  top: y.top,
                  bottom: y.top + c.clientHeight * m,
                });
            }
            let g = 0,
              Q = 0;
            if (r == "nearest")
              e.top < u.top
                ? ((Q = e.top - (u.top + o)),
                  t > 0 &&
                    e.bottom > u.bottom + Q &&
                    (Q = e.bottom - u.bottom + o))
                : e.bottom > u.bottom &&
                  ((Q = e.bottom - u.bottom + o),
                  t < 0 && e.top - Q < u.top && (Q = e.top - (u.top + o)));
            else {
              let y = e.bottom - e.top,
                x = u.bottom - u.top;
              Q =
                (r == "center" && y <= x
                  ? e.top + y / 2 - x / 2
                  : r == "start" || (r == "center" && t < 0)
                  ? e.top - o
                  : e.bottom - x + o) - u.top;
            }
            if (
              (i == "nearest"
                ? e.left < u.left
                  ? ((g = e.left - (u.left + s)),
                    t > 0 &&
                      e.right > u.right + g &&
                      (g = e.right - u.right + s))
                  : e.right > u.right &&
                    ((g = e.right - u.right + s),
                    t < 0 && e.left < u.left + g && (g = e.left - (u.left + s)))
                : (g =
                    (i == "center"
                      ? e.left + (e.right - e.left) / 2 - (u.right - u.left) / 2
                      : (i == "start") == l
                      ? e.left - s
                      : e.right - (u.right - u.left) + s) - u.left),
              g || Q)
            )
              if (d) h.scrollBy(g, Q);
              else {
                let y = 0,
                  x = 0;
                if (Q) {
                  let k = c.scrollTop;
                  (c.scrollTop += Q / m), (x = (c.scrollTop - k) * m);
                }
                if (g) {
                  let k = c.scrollLeft;
                  (c.scrollLeft += g / O), (y = (c.scrollLeft - k) * O);
                }
                (e = {
                  left: e.left - y,
                  top: e.top - x,
                  right: e.right - y,
                  bottom: e.bottom - x,
                }),
                  y && Math.abs(y - g) < 1 && (i = "nearest"),
                  x && Math.abs(x - Q) < 1 && (r = "nearest");
              }
            if (d) break;
            (e.top < u.top ||
              e.bottom > u.bottom ||
              e.left < u.left ||
              e.right > u.right) &&
              (e = {
                left: Math.max(e.left, u.left),
                right: Math.min(e.right, u.right),
                top: Math.max(e.top, u.top),
                bottom: Math.min(e.bottom, u.bottom),
              }),
              (c = c.assignedSlot || c.parentNode);
          } else if (c.nodeType == 11) c = c.host;
          else break;
      }
      function Ud(n) {
        let e = n.ownerDocument,
          t,
          i;
        for (let r = n.parentNode; r && !(r == e.body || (t && i)); )
          if (r.nodeType == 1)
            !i && r.scrollHeight > r.clientHeight && (i = r),
              !t && r.scrollWidth > r.clientWidth && (t = r),
              (r = r.assignedSlot || r.parentNode);
          else if (r.nodeType == 11) r = r.host;
          else break;
        return { x: t, y: i };
      }
      class Fd {
        constructor() {
          (this.anchorNode = null),
            (this.anchorOffset = 0),
            (this.focusNode = null),
            (this.focusOffset = 0);
        }
        eq(e) {
          return (
            this.anchorNode == e.anchorNode &&
            this.anchorOffset == e.anchorOffset &&
            this.focusNode == e.focusNode &&
            this.focusOffset == e.focusOffset
          );
        }
        setRange(e) {
          let { anchorNode: t, focusNode: i } = e;
          this.set(
            t,
            Math.min(e.anchorOffset, t ? ot(t) : 0),
            i,
            Math.min(e.focusOffset, i ? ot(i) : 0)
          );
        }
        set(e, t, i, r) {
          (this.anchorNode = e),
            (this.anchorOffset = t),
            (this.focusNode = i),
            (this.focusOffset = r);
        }
      }
      let Gt = null;
      function ac(n) {
        if (n.setActive) return n.setActive();
        if (Gt) return n.focus(Gt);
        let e = [];
        for (
          let t = n;
          t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument);
          t = t.parentNode
        );
        if (
          (n.focus(
            Gt == null
              ? {
                  get preventScroll() {
                    return (Gt = { preventScroll: !0 }), !0;
                  },
                }
              : void 0
          ),
          !Gt)
        ) {
          Gt = !1;
          for (let t = 0; t < e.length; ) {
            let i = e[t++],
              r = e[t++],
              s = e[t++];
            i.scrollTop != r && (i.scrollTop = r),
              i.scrollLeft != s && (i.scrollLeft = s);
          }
        }
      }
      let Zl;
      function Lt(n, e, t = e) {
        let i = Zl || (Zl = document.createRange());
        return i.setEnd(n, t), i.setStart(n, e), i;
      }
      function ti(n, e, t, i) {
        let r = { key: e, code: e, keyCode: t, which: t, cancelable: !0 };
        i &&
          ({
            altKey: r.altKey,
            ctrlKey: r.ctrlKey,
            shiftKey: r.shiftKey,
            metaKey: r.metaKey,
          } = i);
        let s = new KeyboardEvent("keydown", r);
        (s.synthetic = !0), n.dispatchEvent(s);
        let o = new KeyboardEvent("keyup", r);
        return (
          (o.synthetic = !0),
          n.dispatchEvent(o),
          s.defaultPrevented || o.defaultPrevented
        );
      }
      function Hd(n) {
        for (; n; ) {
          if (n && (n.nodeType == 9 || (n.nodeType == 11 && n.host))) return n;
          n = n.assignedSlot || n.parentNode;
        }
        return null;
      }
      function hc(n) {
        for (; n.attributes.length; ) n.removeAttributeNode(n.attributes[0]);
      }
      function Kd(n, e) {
        let t = e.focusNode,
          i = e.focusOffset;
        if (!t || e.anchorNode != t || e.anchorOffset != i) return !1;
        for (i = Math.min(i, ot(t)); ; )
          if (i) {
            if (t.nodeType != 1) return !1;
            let r = t.childNodes[i - 1];
            r.contentEditable == "false" ? i-- : ((t = r), (i = ot(t)));
          } else {
            if (t == n) return !0;
            (i = Wt(t)), (t = t.parentNode);
          }
      }
      function cc(n) {
        return n.scrollTop > Math.max(1, n.scrollHeight - n.clientHeight - 4);
      }
      function fc(n, e) {
        for (let t = n, i = e; ; ) {
          if (t.nodeType == 3 && i > 0) return { node: t, offset: i };
          if (t.nodeType == 1 && i > 0) {
            if (t.contentEditable == "false") return null;
            (t = t.childNodes[i - 1]), (i = ot(t));
          } else if (t.parentNode && !tr(t)) (i = Wt(t)), (t = t.parentNode);
          else return null;
        }
      }
      function uc(n, e) {
        for (let t = n, i = e; ; ) {
          if (t.nodeType == 3 && i < t.nodeValue.length)
            return { node: t, offset: i };
          if (t.nodeType == 1 && i < t.childNodes.length) {
            if (t.contentEditable == "false") return null;
            (t = t.childNodes[i]), (i = 0);
          } else if (t.parentNode && !tr(t))
            (i = Wt(t) + 1), (t = t.parentNode);
          else return null;
        }
      }
      class de {
        constructor(e, t, i = !0) {
          (this.node = e), (this.offset = t), (this.precise = i);
        }
        static before(e, t) {
          return new de(e.parentNode, Wt(e), t);
        }
        static after(e, t) {
          return new de(e.parentNode, Wt(e) + 1, t);
        }
      }
      const Ro = [];
      class I {
        constructor() {
          (this.parent = null), (this.dom = null), (this.flags = 2);
        }
        get overrideDOMText() {
          return null;
        }
        get posAtStart() {
          return this.parent ? this.parent.posBefore(this) : 0;
        }
        get posAtEnd() {
          return this.posAtStart + this.length;
        }
        posBefore(e) {
          let t = this.posAtStart;
          for (let i of this.children) {
            if (i == e) return t;
            t += i.length + i.breakAfter;
          }
          throw new RangeError("Invalid child in posBefore");
        }
        posAfter(e) {
          return this.posBefore(e) + e.length;
        }
        sync(e, t) {
          if (this.flags & 2) {
            let i = this.dom,
              r = null,
              s;
            for (let o of this.children) {
              if (o.flags & 7) {
                if (!o.dom && (s = r ? r.nextSibling : i.firstChild)) {
                  let l = I.get(s);
                  (!l || (!l.parent && l.canReuseDOM(o))) && o.reuseDOM(s);
                }
                o.sync(e, t), (o.flags &= -8);
              }
              if (
                ((s = r ? r.nextSibling : i.firstChild),
                t &&
                  !t.written &&
                  t.node == i &&
                  s != o.dom &&
                  (t.written = !0),
                o.dom.parentNode == i)
              )
                for (; s && s != o.dom; ) s = Al(s);
              else i.insertBefore(o.dom, s);
              r = o.dom;
            }
            for (
              s = r ? r.nextSibling : i.firstChild,
                s && t && t.node == i && (t.written = !0);
              s;

            )
              s = Al(s);
          } else if (this.flags & 1)
            for (let i of this.children)
              i.flags & 7 && (i.sync(e, t), (i.flags &= -8));
        }
        reuseDOM(e) {}
        localPosFromDOM(e, t) {
          let i;
          if (e == this.dom) i = this.dom.childNodes[t];
          else {
            let r = ot(e) == 0 ? 0 : t == 0 ? -1 : 1;
            for (;;) {
              let s = e.parentNode;
              if (s == this.dom) break;
              r == 0 &&
                s.firstChild != s.lastChild &&
                (e == s.firstChild ? (r = -1) : (r = 1)),
                (e = s);
            }
            r < 0 ? (i = e) : (i = e.nextSibling);
          }
          if (i == this.dom.firstChild) return 0;
          for (; i && !I.get(i); ) i = i.nextSibling;
          if (!i) return this.length;
          for (let r = 0, s = 0; ; r++) {
            let o = this.children[r];
            if (o.dom == i) return s;
            s += o.length + o.breakAfter;
          }
        }
        domBoundsAround(e, t, i = 0) {
          let r = -1,
            s = -1,
            o = -1,
            l = -1;
          for (let a = 0, h = i, c = i; a < this.children.length; a++) {
            let f = this.children[a],
              u = h + f.length;
            if (h < e && u > t) return f.domBoundsAround(e, t, h);
            if (
              (u >= e && r == -1 && ((r = a), (s = h)),
              h > t && f.dom.parentNode == this.dom)
            ) {
              (o = a), (l = c);
              break;
            }
            (c = u), (h = u + f.breakAfter);
          }
          return {
            from: s,
            to: l < 0 ? i + this.length : l,
            startDOM:
              (r ? this.children[r - 1].dom.nextSibling : null) ||
              this.dom.firstChild,
            endDOM:
              o < this.children.length && o >= 0 ? this.children[o].dom : null,
          };
        }
        markDirty(e = !1) {
          (this.flags |= 2), this.markParentsDirty(e);
        }
        markParentsDirty(e) {
          for (let t = this.parent; t; t = t.parent) {
            if ((e && (t.flags |= 2), t.flags & 1)) return;
            (t.flags |= 1), (e = !1);
          }
        }
        setParent(e) {
          this.parent != e &&
            ((this.parent = e), this.flags & 7 && this.markParentsDirty(!0));
        }
        setDOM(e) {
          this.dom != e &&
            (this.dom && (this.dom.cmView = null),
            (this.dom = e),
            (e.cmView = this));
        }
        get rootView() {
          for (let e = this; ; ) {
            let t = e.parent;
            if (!t) return e;
            e = t;
          }
        }
        replaceChildren(e, t, i = Ro) {
          this.markDirty();
          for (let r = e; r < t; r++) {
            let s = this.children[r];
            s.parent == this && i.indexOf(s) < 0 && s.destroy();
          }
          i.length < 250
            ? this.children.splice(e, t - e, ...i)
            : (this.children = [].concat(
                this.children.slice(0, e),
                i,
                this.children.slice(t)
              ));
          for (let r = 0; r < i.length; r++) i[r].setParent(this);
        }
        ignoreMutation(e) {
          return !1;
        }
        ignoreEvent(e) {
          return !1;
        }
        childCursor(e = this.length) {
          return new dc(this.children, e, this.children.length);
        }
        childPos(e, t = 1) {
          return this.childCursor().findPos(e, t);
        }
        toString() {
          let e = this.constructor.name.replace("View", "");
          return (
            e +
            (this.children.length
              ? "(" + this.children.join() + ")"
              : this.length
              ? "[" + (e == "Text" ? this.text : this.length) + "]"
              : "") +
            (this.breakAfter ? "#" : "")
          );
        }
        static get(e) {
          return e.cmView;
        }
        get isEditable() {
          return !0;
        }
        get isWidget() {
          return !1;
        }
        get isHidden() {
          return !1;
        }
        merge(e, t, i, r, s, o) {
          return !1;
        }
        become(e) {
          return !1;
        }
        canReuseDOM(e) {
          return (
            e.constructor == this.constructor && !((this.flags | e.flags) & 8)
          );
        }
        getSide() {
          return 0;
        }
        destroy() {
          for (let e of this.children) e.parent == this && e.destroy();
          this.parent = null;
        }
      }
      I.prototype.breakAfter = 0;
      function Al(n) {
        let e = n.nextSibling;
        return n.parentNode.removeChild(n), e;
      }
      class dc {
        constructor(e, t, i) {
          (this.children = e), (this.pos = t), (this.i = i), (this.off = 0);
        }
        findPos(e, t = 1) {
          for (;;) {
            if (
              e > this.pos ||
              (e == this.pos &&
                (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
            )
              return (this.off = e - this.pos), this;
            let i = this.children[--this.i];
            this.pos -= i.length + i.breakAfter;
          }
        }
      }
      function Oc(n, e, t, i, r, s, o, l, a) {
        let { children: h } = n,
          c = h.length ? h[e] : null,
          f = s.length ? s[s.length - 1] : null,
          u = f ? f.breakAfter : o;
        if (
          !(
            e == i &&
            c &&
            !o &&
            !u &&
            s.length < 2 &&
            c.merge(t, r, s.length ? f : null, t == 0, l, a)
          )
        ) {
          if (i < h.length) {
            let d = h[i];
            d && (r < d.length || (d.breakAfter && f?.breakAfter))
              ? (e == i && ((d = d.split(r)), (r = 0)),
                !u && f && d.merge(0, r, f, !0, 0, a)
                  ? (s[s.length - 1] = d)
                  : ((r || (d.children.length && !d.children[0].length)) &&
                      d.merge(0, r, null, !1, 0, a),
                    s.push(d)))
              : d?.breakAfter && (f ? (f.breakAfter = 1) : (o = 1)),
              i++;
          }
          for (
            c &&
            ((c.breakAfter = o),
            t > 0 &&
              (!o && s.length && c.merge(t, c.length, s[0], !1, l, 0)
                ? (c.breakAfter = s.shift().breakAfter)
                : (t < c.length ||
                    (c.children.length &&
                      c.children[c.children.length - 1].length == 0)) &&
                  c.merge(t, c.length, null, !1, l, 0),
              e++));
            e < i && s.length;

          )
            if (h[i - 1].become(s[s.length - 1]))
              i--, s.pop(), (a = s.length ? 0 : l);
            else if (h[e].become(s[0])) e++, s.shift(), (l = s.length ? 0 : a);
            else break;
          !s.length &&
            e &&
            i < h.length &&
            !h[e - 1].breakAfter &&
            h[i].merge(0, 0, h[e - 1], !1, l, a) &&
            e--,
            (e < i || s.length) && n.replaceChildren(e, i, s);
        }
      }
      function pc(n, e, t, i, r, s) {
        let o = n.childCursor(),
          { i: l, off: a } = o.findPos(t, 1),
          { i: h, off: c } = o.findPos(e, -1),
          f = e - t;
        for (let u of i) f += u.length;
        (n.length += f), Oc(n, h, c, l, a, i, 0, r, s);
      }
      let xe =
          typeof navigator < "u"
            ? navigator
            : { userAgent: "", vendor: "", platform: "" },
        Bs =
          typeof document < "u" ? document : { documentElement: { style: {} } };
      const Is = /Edge\/(\d+)/.exec(xe.userAgent),
        mc = /MSIE \d/.test(xe.userAgent),
        Gs = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(xe.userAgent),
        Ar = !!(mc || Gs || Is),
        Xl = !Ar && /gecko\/(\d+)/i.test(xe.userAgent),
        Fr = !Ar && /Chrome\/(\d+)/.exec(xe.userAgent),
        Jd = "webkitFontSmoothing" in Bs.documentElement.style,
        gc = !Ar && /Apple Computer/.test(xe.vendor),
        Rl = gc && (/Mobile\/\w+/.test(xe.userAgent) || xe.maxTouchPoints > 2);
      var T = {
        mac: Rl || /Mac/.test(xe.platform),
        windows: /Win/.test(xe.platform),
        linux: /Linux|X11/.test(xe.platform),
        ie: Ar,
        ie_version: mc ? Bs.documentMode || 6 : Gs ? +Gs[1] : Is ? +Is[1] : 0,
        gecko: Xl,
        gecko_version: Xl
          ? +(/Firefox\/(\d+)/.exec(xe.userAgent) || [0, 0])[1]
          : 0,
        chrome: !!Fr,
        chrome_version: Fr ? +Fr[1] : 0,
        ios: Rl,
        android: /Android\b/.test(xe.userAgent),
        safari: gc,
        webkit_version: Jd
          ? +(/\bAppleWebKit\/(\d+)/.exec(xe.userAgent) || [0, 0])[1]
          : 0,
        tabSize:
          Bs.documentElement.style.tabSize != null
            ? "tab-size"
            : "-moz-tab-size",
      };
      const eO = 256;
      class Le extends I {
        constructor(e) {
          super(), (this.text = e);
        }
        get length() {
          return this.text.length;
        }
        createDOM(e) {
          this.setDOM(e || document.createTextNode(this.text));
        }
        sync(e, t) {
          this.dom || this.createDOM(),
            this.dom.nodeValue != this.text &&
              (t && t.node == this.dom && (t.written = !0),
              (this.dom.nodeValue = this.text));
        }
        reuseDOM(e) {
          e.nodeType == 3 && this.createDOM(e);
        }
        merge(e, t, i) {
          return this.flags & 8 ||
            (i &&
              (!(i instanceof Le) ||
                this.length - (t - e) + i.length > eO ||
                i.flags & 8))
            ? !1
            : ((this.text =
                this.text.slice(0, e) + (i ? i.text : "") + this.text.slice(t)),
              this.markDirty(),
              !0);
        }
        split(e) {
          let t = new Le(this.text.slice(e));
          return (
            (this.text = this.text.slice(0, e)),
            this.markDirty(),
            (t.flags |= this.flags & 8),
            t
          );
        }
        localPosFromDOM(e, t) {
          return e == this.dom ? t : t ? this.text.length : 0;
        }
        domAtPos(e) {
          return new de(this.dom, e);
        }
        domBoundsAround(e, t, i) {
          return {
            from: i,
            to: i + this.length,
            startDOM: this.dom,
            endDOM: this.dom.nextSibling,
          };
        }
        coordsAt(e, t) {
          return tO(this.dom, e, t);
        }
      }
      class mt extends I {
        constructor(e, t = [], i = 0) {
          super(), (this.mark = e), (this.children = t), (this.length = i);
          for (let r of t) r.setParent(this);
        }
        setAttrs(e) {
          if (
            (hc(e),
            this.mark.class && (e.className = this.mark.class),
            this.mark.attrs)
          )
            for (let t in this.mark.attrs)
              e.setAttribute(t, this.mark.attrs[t]);
          return e;
        }
        canReuseDOM(e) {
          return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
        }
        reuseDOM(e) {
          e.nodeName == this.mark.tagName.toUpperCase() &&
            (this.setDOM(e), (this.flags |= 6));
        }
        sync(e, t) {
          this.dom
            ? this.flags & 4 && this.setAttrs(this.dom)
            : this.setDOM(
                this.setAttrs(document.createElement(this.mark.tagName))
              ),
            super.sync(e, t);
        }
        merge(e, t, i, r, s, o) {
          return i &&
            (!(i instanceof mt && i.mark.eq(this.mark)) ||
              (e && s <= 0) ||
              (t < this.length && o <= 0))
            ? !1
            : (pc(this, e, t, i ? i.children.slice() : [], s - 1, o - 1),
              this.markDirty(),
              !0);
        }
        split(e) {
          let t = [],
            i = 0,
            r = -1,
            s = 0;
          for (let l of this.children) {
            let a = i + l.length;
            a > e && t.push(i < e ? l.split(e - i) : l),
              r < 0 && i >= e && (r = s),
              (i = a),
              s++;
          }
          let o = this.length - e;
          return (
            (this.length = e),
            r > -1 && ((this.children.length = r), this.markDirty()),
            new mt(this.mark, t, o)
          );
        }
        domAtPos(e) {
          return Qc(this, e);
        }
        coordsAt(e, t) {
          return yc(this, e, t);
        }
      }
      function tO(n, e, t) {
        let i = n.nodeValue.length;
        e > i && (e = i);
        let r = e,
          s = e,
          o = 0;
        (e == 0 && t < 0) || (e == i && t >= 0)
          ? T.chrome ||
            T.gecko ||
            (e ? (r--, (o = 1)) : s < i && (s++, (o = -1)))
          : t < 0
          ? r--
          : s < i && s++;
        let l = Lt(n, r, s).getClientRects();
        if (!l.length) return null;
        let a = l[(o ? o < 0 : t >= 0) ? 0 : l.length - 1];
        return (
          T.safari &&
            !o &&
            a.width == 0 &&
            (a = Array.prototype.find.call(l, (h) => h.width) || a),
          o ? Zr(a, o < 0) : a || null
        );
      }
      class kt extends I {
        static create(e, t, i) {
          return new kt(e, t, i);
        }
        constructor(e, t, i) {
          super(),
            (this.widget = e),
            (this.length = t),
            (this.side = i),
            (this.prevWidget = null);
        }
        split(e) {
          let t = kt.create(this.widget, this.length - e, this.side);
          return (this.length -= e), t;
        }
        sync(e) {
          (!this.dom || !this.widget.updateDOM(this.dom, e)) &&
            (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom),
            (this.prevWidget = null),
            this.setDOM(this.widget.toDOM(e)),
            this.widget.editable || (this.dom.contentEditable = "false"));
        }
        getSide() {
          return this.side;
        }
        merge(e, t, i, r, s, o) {
          return i &&
            (!(i instanceof kt) ||
              !this.widget.compare(i.widget) ||
              (e > 0 && s <= 0) ||
              (t < this.length && o <= 0))
            ? !1
            : ((this.length = e + (i ? i.length : 0) + (this.length - t)), !0);
        }
        become(e) {
          return e instanceof kt &&
            e.side == this.side &&
            this.widget.constructor == e.widget.constructor
            ? (this.widget.compare(e.widget) || this.markDirty(!0),
              this.dom && !this.prevWidget && (this.prevWidget = this.widget),
              (this.widget = e.widget),
              (this.length = e.length),
              !0)
            : !1;
        }
        ignoreMutation() {
          return !0;
        }
        ignoreEvent(e) {
          return this.widget.ignoreEvent(e);
        }
        get overrideDOMText() {
          if (this.length == 0) return E.empty;
          let e = this;
          for (; e.parent; ) e = e.parent;
          let { view: t } = e,
            i = t && t.state.doc,
            r = this.posAtStart;
          return i ? i.slice(r, r + this.length) : E.empty;
        }
        domAtPos(e) {
          return (this.length ? e == 0 : this.side > 0)
            ? de.before(this.dom)
            : de.after(this.dom, e == this.length);
        }
        domBoundsAround() {
          return null;
        }
        coordsAt(e, t) {
          let i = this.widget.coordsAt(this.dom, e, t);
          if (i) return i;
          let r = this.dom.getClientRects(),
            s = null;
          if (!r.length) return null;
          let o = this.side ? this.side < 0 : e > 0;
          for (
            let l = o ? r.length - 1 : 0;
            (s = r[l]),
              !(e > 0 ? l == 0 : l == r.length - 1 || s.top < s.bottom);
            l += o ? -1 : 1
          );
          return Zr(s, !o);
        }
        get isEditable() {
          return !1;
        }
        get isWidget() {
          return !0;
        }
        get isHidden() {
          return this.widget.isHidden;
        }
        destroy() {
          super.destroy(), this.dom && this.widget.destroy(this.dom);
        }
      }
      class li extends I {
        constructor(e) {
          super(), (this.side = e);
        }
        get length() {
          return 0;
        }
        merge() {
          return !1;
        }
        become(e) {
          return e instanceof li && e.side == this.side;
        }
        split() {
          return new li(this.side);
        }
        sync() {
          if (!this.dom) {
            let e = document.createElement("img");
            (e.className = "cm-widgetBuffer"),
              e.setAttribute("aria-hidden", "true"),
              this.setDOM(e);
          }
        }
        getSide() {
          return this.side;
        }
        domAtPos(e) {
          return this.side > 0 ? de.before(this.dom) : de.after(this.dom);
        }
        localPosFromDOM() {
          return 0;
        }
        domBoundsAround() {
          return null;
        }
        coordsAt(e) {
          return this.dom.getBoundingClientRect();
        }
        get overrideDOMText() {
          return E.empty;
        }
        get isHidden() {
          return !0;
        }
      }
      Le.prototype.children =
        kt.prototype.children =
        li.prototype.children =
          Ro;
      function Qc(n, e) {
        let t = n.dom,
          { children: i } = n,
          r = 0;
        for (let s = 0; r < i.length; r++) {
          let o = i[r],
            l = s + o.length;
          if (!(l == s && o.getSide() <= 0)) {
            if (e > s && e < l && o.dom.parentNode == t)
              return o.domAtPos(e - s);
            if (e <= s) break;
            s = l;
          }
        }
        for (let s = r; s > 0; s--) {
          let o = i[s - 1];
          if (o.dom.parentNode == t) return o.domAtPos(o.length);
        }
        for (let s = r; s < i.length; s++) {
          let o = i[s];
          if (o.dom.parentNode == t) return o.domAtPos(0);
        }
        return new de(t, 0);
      }
      function Sc(n, e, t) {
        let i,
          { children: r } = n;
        t > 0 &&
        e instanceof mt &&
        r.length &&
        (i = r[r.length - 1]) instanceof mt &&
        i.mark.eq(e.mark)
          ? Sc(i, e.children[0], t - 1)
          : (r.push(e), e.setParent(n)),
          (n.length += e.length);
      }
      function yc(n, e, t) {
        let i = null,
          r = -1,
          s = null,
          o = -1;
        function l(h, c) {
          for (let f = 0, u = 0; f < h.children.length && u <= c; f++) {
            let d = h.children[f],
              O = u + d.length;
            O >= c &&
              (d.children.length
                ? l(d, c - u)
                : (!s || (s.isHidden && (t > 0 || nO(s, d)))) &&
                  (O > c || (u == O && d.getSide() > 0))
                ? ((s = d), (o = c - u))
                : (u < c || (u == O && d.getSide() < 0 && !d.isHidden)) &&
                  ((i = d), (r = c - u))),
              (u = O);
          }
        }
        l(n, e);
        let a = (t < 0 ? i : s) || i || s;
        return a ? a.coordsAt(Math.max(0, a == i ? r : o), t) : iO(n);
      }
      function iO(n) {
        let e = n.dom.lastChild;
        if (!e) return n.dom.getBoundingClientRect();
        let t = ji(e);
        return t[t.length - 1] || null;
      }
      function nO(n, e) {
        let t = n.coordsAt(0, 1),
          i = e.coordsAt(0, 1);
        return t && i && i.top < t.bottom;
      }
      function Ns(n, e) {
        for (let t in n)
          t == "class" && e.class
            ? (e.class += " " + n.class)
            : t == "style" && e.style
            ? (e.style += ";" + n.style)
            : (e[t] = n[t]);
        return e;
      }
      const Ml = Object.create(null);
      function ir(n, e, t) {
        if (n == e) return !0;
        n || (n = Ml), e || (e = Ml);
        let i = Object.keys(n),
          r = Object.keys(e);
        if (
          i.length - (t && i.indexOf(t) > -1 ? 1 : 0) !=
          r.length - (t && r.indexOf(t) > -1 ? 1 : 0)
        )
          return !1;
        for (let s of i)
          if (s != t && (r.indexOf(s) == -1 || n[s] !== e[s])) return !1;
        return !0;
      }
      function Us(n, e, t) {
        let i = !1;
        if (e)
          for (let r in e)
            (t && r in t) ||
              ((i = !0),
              r == "style" ? (n.style.cssText = "") : n.removeAttribute(r));
        if (t)
          for (let r in t)
            (e && e[r] == t[r]) ||
              ((i = !0),
              r == "style"
                ? (n.style.cssText = t[r])
                : n.setAttribute(r, t[r]));
        return i;
      }
      function rO(n) {
        let e = Object.create(null);
        for (let t = 0; t < n.attributes.length; t++) {
          let i = n.attributes[t];
          e[i.name] = i.value;
        }
        return e;
      }
      class St {
        eq(e) {
          return !1;
        }
        updateDOM(e, t) {
          return !1;
        }
        compare(e) {
          return this == e || (this.constructor == e.constructor && this.eq(e));
        }
        get estimatedHeight() {
          return -1;
        }
        get lineBreaks() {
          return 0;
        }
        ignoreEvent(e) {
          return !0;
        }
        coordsAt(e, t, i) {
          return null;
        }
        get isHidden() {
          return !1;
        }
        get editable() {
          return !1;
        }
        destroy(e) {}
      }
      var ge = (function (n) {
        return (
          (n[(n.Text = 0)] = "Text"),
          (n[(n.WidgetBefore = 1)] = "WidgetBefore"),
          (n[(n.WidgetAfter = 2)] = "WidgetAfter"),
          (n[(n.WidgetRange = 3)] = "WidgetRange"),
          n
        );
      })(ge || (ge = {}));
      class A extends qt {
        constructor(e, t, i, r) {
          super(),
            (this.startSide = e),
            (this.endSide = t),
            (this.widget = i),
            (this.spec = r);
        }
        get heightRelevant() {
          return !1;
        }
        static mark(e) {
          return new on(e);
        }
        static widget(e) {
          let t = Math.max(-1e4, Math.min(1e4, e.side || 0)),
            i = !!e.block;
          return (
            (t +=
              i && !e.inlineOrder ? (t > 0 ? 3e8 : -4e8) : t > 0 ? 1e8 : -1e8),
            new Ct(e, t, t, i, e.widget || null, !1)
          );
        }
        static replace(e) {
          let t = !!e.block,
            i,
            r;
          if (e.isBlockGap) (i = -5e8), (r = 4e8);
          else {
            let { start: s, end: o } = bc(e, t);
            (i = (s ? (t ? -3e8 : -1) : 5e8) - 1),
              (r = (o ? (t ? 2e8 : 1) : -6e8) + 1);
          }
          return new Ct(e, i, r, t, e.widget || null, !0);
        }
        static line(e) {
          return new ln(e);
        }
        static set(e, t = !1) {
          return V.of(e, t);
        }
        hasHeight() {
          return this.widget ? this.widget.estimatedHeight > -1 : !1;
        }
      }
      A.none = V.empty;
      class on extends A {
        constructor(e) {
          let { start: t, end: i } = bc(e);
          super(t ? -1 : 5e8, i ? 1 : -6e8, null, e),
            (this.tagName = e.tagName || "span"),
            (this.class = e.class || ""),
            (this.attrs = e.attributes || null);
        }
        eq(e) {
          var t, i;
          return (
            this == e ||
            (e instanceof on &&
              this.tagName == e.tagName &&
              (this.class ||
                ((t = this.attrs) === null || t === void 0
                  ? void 0
                  : t.class)) ==
                (e.class ||
                  ((i = e.attrs) === null || i === void 0
                    ? void 0
                    : i.class)) &&
              ir(this.attrs, e.attrs, "class"))
          );
        }
        range(e, t = e) {
          if (e >= t) throw new RangeError("Mark decorations may not be empty");
          return super.range(e, t);
        }
      }
      on.prototype.point = !1;
      class ln extends A {
        constructor(e) {
          super(-2e8, -2e8, null, e);
        }
        eq(e) {
          return (
            e instanceof ln &&
            this.spec.class == e.spec.class &&
            ir(this.spec.attributes, e.spec.attributes)
          );
        }
        range(e, t = e) {
          if (t != e)
            throw new RangeError("Line decoration ranges must be zero-length");
          return super.range(e, t);
        }
      }
      ln.prototype.mapMode = ce.TrackBefore;
      ln.prototype.point = !0;
      class Ct extends A {
        constructor(e, t, i, r, s, o) {
          super(t, i, s, e),
            (this.block = r),
            (this.isReplace = o),
            (this.mapMode = r
              ? t <= 0
                ? ce.TrackBefore
                : ce.TrackAfter
              : ce.TrackDel);
        }
        get type() {
          return this.startSide != this.endSide
            ? ge.WidgetRange
            : this.startSide <= 0
            ? ge.WidgetBefore
            : ge.WidgetAfter;
        }
        get heightRelevant() {
          return (
            this.block ||
            (!!this.widget &&
              (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0))
          );
        }
        eq(e) {
          return (
            e instanceof Ct &&
            sO(this.widget, e.widget) &&
            this.block == e.block &&
            this.startSide == e.startSide &&
            this.endSide == e.endSide
          );
        }
        range(e, t = e) {
          if (
            this.isReplace &&
            (e > t || (e == t && this.startSide > 0 && this.endSide <= 0))
          )
            throw new RangeError("Invalid range for replacement decoration");
          if (!this.isReplace && t != e)
            throw new RangeError(
              "Widget decorations can only have zero-length ranges"
            );
          return super.range(e, t);
        }
      }
      Ct.prototype.point = !0;
      function bc(n, e = !1) {
        let { inclusiveStart: t, inclusiveEnd: i } = n;
        return (
          t == null && (t = n.inclusive),
          i == null && (i = n.inclusive),
          { start: t ?? e, end: i ?? e }
        );
      }
      function sO(n, e) {
        return n == e || !!(n && e && n.compare(e));
      }
      function qn(n, e, t, i = 0) {
        let r = t.length - 1;
        r >= 0 && t[r] + i >= n ? (t[r] = Math.max(t[r], e)) : t.push(n, e);
      }
      class te extends I {
        constructor() {
          super(...arguments),
            (this.children = []),
            (this.length = 0),
            (this.prevAttrs = void 0),
            (this.attrs = null),
            (this.breakAfter = 0);
        }
        merge(e, t, i, r, s, o) {
          if (i) {
            if (!(i instanceof te)) return !1;
            this.dom || i.transferDOM(this);
          }
          return (
            r && this.setDeco(i ? i.attrs : null),
            pc(this, e, t, i ? i.children.slice() : [], s, o),
            !0
          );
        }
        split(e) {
          let t = new te();
          if (((t.breakAfter = this.breakAfter), this.length == 0)) return t;
          let { i, off: r } = this.childPos(e);
          r &&
            (t.append(this.children[i].split(r), 0),
            this.children[i].merge(r, this.children[i].length, null, !1, 0, 0),
            i++);
          for (let s = i; s < this.children.length; s++)
            t.append(this.children[s], 0);
          for (; i > 0 && this.children[i - 1].length == 0; )
            this.children[--i].destroy();
          return (
            (this.children.length = i), this.markDirty(), (this.length = e), t
          );
        }
        transferDOM(e) {
          this.dom &&
            (this.markDirty(),
            e.setDOM(this.dom),
            (e.prevAttrs =
              this.prevAttrs === void 0 ? this.attrs : this.prevAttrs),
            (this.prevAttrs = void 0),
            (this.dom = null));
        }
        setDeco(e) {
          ir(this.attrs, e) ||
            (this.dom && ((this.prevAttrs = this.attrs), this.markDirty()),
            (this.attrs = e));
        }
        append(e, t) {
          Sc(this, e, t);
        }
        addLineDeco(e) {
          let t = e.spec.attributes,
            i = e.spec.class;
          t && (this.attrs = Ns(t, this.attrs || {})),
            i && (this.attrs = Ns({ class: i }, this.attrs || {}));
        }
        domAtPos(e) {
          return Qc(this, e);
        }
        reuseDOM(e) {
          e.nodeName == "DIV" && (this.setDOM(e), (this.flags |= 6));
        }
        sync(e, t) {
          var i;
          this.dom
            ? this.flags & 4 &&
              (hc(this.dom),
              (this.dom.className = "cm-line"),
              (this.prevAttrs = this.attrs ? null : void 0))
            : (this.setDOM(document.createElement("div")),
              (this.dom.className = "cm-line"),
              (this.prevAttrs = this.attrs ? null : void 0)),
            this.prevAttrs !== void 0 &&
              (Us(this.dom, this.prevAttrs, this.attrs),
              this.dom.classList.add("cm-line"),
              (this.prevAttrs = void 0)),
            super.sync(e, t);
          let r = this.dom.lastChild;
          for (; r && I.get(r) instanceof mt; ) r = r.lastChild;
          if (
            !r ||
            !this.length ||
            (r.nodeName != "BR" &&
              ((i = I.get(r)) === null || i === void 0
                ? void 0
                : i.isEditable) == !1 &&
              (!T.ios || !this.children.some((s) => s instanceof Le)))
          ) {
            let s = document.createElement("BR");
            (s.cmIgnore = !0), this.dom.appendChild(s);
          }
        }
        measureTextSize() {
          if (this.children.length == 0 || this.length > 20) return null;
          let e = 0,
            t;
          for (let i of this.children) {
            if (!(i instanceof Le) || /[^ -~]/.test(i.text)) return null;
            let r = ji(i.dom);
            if (r.length != 1) return null;
            (e += r[0].width), (t = r[0].height);
          }
          return e
            ? {
                lineHeight: this.dom.getBoundingClientRect().height,
                charWidth: e / this.length,
                textHeight: t,
              }
            : null;
        }
        coordsAt(e, t) {
          let i = yc(this, e, t);
          if (!this.children.length && i && this.parent) {
            let { heightOracle: r } = this.parent.view.viewState,
              s = i.bottom - i.top;
            if (Math.abs(s - r.lineHeight) < 2 && r.textHeight < s) {
              let o = (s - r.textHeight) / 2;
              return {
                top: i.top + o,
                bottom: i.bottom - o,
                left: i.left,
                right: i.left,
              };
            }
          }
          return i;
        }
        become(e) {
          return (
            e instanceof te &&
            this.children.length == 0 &&
            e.children.length == 0 &&
            ir(this.attrs, e.attrs) &&
            this.breakAfter == e.breakAfter
          );
        }
        covers() {
          return !0;
        }
        static find(e, t) {
          for (let i = 0, r = 0; i < e.children.length; i++) {
            let s = e.children[i],
              o = r + s.length;
            if (o >= t) {
              if (s instanceof te) return s;
              if (o > t) break;
            }
            r = o + s.breakAfter;
          }
          return null;
        }
      }
      class dt extends I {
        constructor(e, t, i) {
          super(),
            (this.widget = e),
            (this.length = t),
            (this.deco = i),
            (this.breakAfter = 0),
            (this.prevWidget = null);
        }
        merge(e, t, i, r, s, o) {
          return i &&
            (!(i instanceof dt) ||
              !this.widget.compare(i.widget) ||
              (e > 0 && s <= 0) ||
              (t < this.length && o <= 0))
            ? !1
            : ((this.length = e + (i ? i.length : 0) + (this.length - t)), !0);
        }
        domAtPos(e) {
          return e == 0
            ? de.before(this.dom)
            : de.after(this.dom, e == this.length);
        }
        split(e) {
          let t = this.length - e;
          this.length = e;
          let i = new dt(this.widget, t, this.deco);
          return (i.breakAfter = this.breakAfter), i;
        }
        get children() {
          return Ro;
        }
        sync(e) {
          (!this.dom || !this.widget.updateDOM(this.dom, e)) &&
            (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom),
            (this.prevWidget = null),
            this.setDOM(this.widget.toDOM(e)),
            this.widget.editable || (this.dom.contentEditable = "false"));
        }
        get overrideDOMText() {
          return this.parent
            ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd)
            : E.empty;
        }
        domBoundsAround() {
          return null;
        }
        become(e) {
          return e instanceof dt &&
            e.widget.constructor == this.widget.constructor
            ? (e.widget.compare(this.widget) || this.markDirty(!0),
              this.dom && !this.prevWidget && (this.prevWidget = this.widget),
              (this.widget = e.widget),
              (this.length = e.length),
              (this.deco = e.deco),
              (this.breakAfter = e.breakAfter),
              !0)
            : !1;
        }
        ignoreMutation() {
          return !0;
        }
        ignoreEvent(e) {
          return this.widget.ignoreEvent(e);
        }
        get isEditable() {
          return !1;
        }
        get isWidget() {
          return !0;
        }
        coordsAt(e, t) {
          let i = this.widget.coordsAt(this.dom, e, t);
          return (
            i ||
            (this.widget instanceof Fs
              ? null
              : Zr(
                  this.dom.getBoundingClientRect(),
                  this.length ? e == 0 : t <= 0
                ))
          );
        }
        destroy() {
          super.destroy(), this.dom && this.widget.destroy(this.dom);
        }
        covers(e) {
          let { startSide: t, endSide: i } = this.deco;
          return t == i ? !1 : e < 0 ? t < 0 : i > 0;
        }
      }
      class Fs extends St {
        constructor(e) {
          super(), (this.height = e);
        }
        toDOM() {
          let e = document.createElement("div");
          return (e.className = "cm-gap"), this.updateDOM(e), e;
        }
        eq(e) {
          return e.height == this.height;
        }
        updateDOM(e) {
          return (e.style.height = this.height + "px"), !0;
        }
        get editable() {
          return !0;
        }
        get estimatedHeight() {
          return this.height;
        }
        ignoreEvent() {
          return !1;
        }
      }
      class Di {
        constructor(e, t, i, r) {
          (this.doc = e),
            (this.pos = t),
            (this.end = i),
            (this.disallowBlockEffectsFor = r),
            (this.content = []),
            (this.curLine = null),
            (this.breakAtStart = 0),
            (this.pendingBuffer = 0),
            (this.bufferMarks = []),
            (this.atCursorPos = !0),
            (this.openStart = -1),
            (this.openEnd = -1),
            (this.text = ""),
            (this.textOff = 0),
            (this.cursor = e.iter()),
            (this.skip = t);
        }
        posCovered() {
          if (this.content.length == 0)
            return (
              !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos
            );
          let e = this.content[this.content.length - 1];
          return !(e.breakAfter || (e instanceof dt && e.deco.endSide < 0));
        }
        getLine() {
          return (
            this.curLine ||
              (this.content.push((this.curLine = new te())),
              (this.atCursorPos = !0)),
            this.curLine
          );
        }
        flushBuffer(e = this.bufferMarks) {
          this.pendingBuffer &&
            (this.curLine.append(Qn(new li(-1), e), e.length),
            (this.pendingBuffer = 0));
        }
        addBlockWidget(e) {
          this.flushBuffer(), (this.curLine = null), this.content.push(e);
        }
        finish(e) {
          this.pendingBuffer && e <= this.bufferMarks.length
            ? this.flushBuffer()
            : (this.pendingBuffer = 0),
            !this.posCovered() &&
              !(
                e &&
                this.content.length &&
                this.content[this.content.length - 1] instanceof dt
              ) &&
              this.getLine();
        }
        buildText(e, t, i) {
          for (; e > 0; ) {
            if (this.textOff == this.text.length) {
              let {
                value: s,
                lineBreak: o,
                done: l,
              } = this.cursor.next(this.skip);
              if (((this.skip = 0), l))
                throw new Error(
                  "Ran out of text content when drawing inline views"
                );
              if (o) {
                this.posCovered() || this.getLine(),
                  this.content.length
                    ? (this.content[this.content.length - 1].breakAfter = 1)
                    : (this.breakAtStart = 1),
                  this.flushBuffer(),
                  (this.curLine = null),
                  (this.atCursorPos = !0),
                  e--;
                continue;
              } else (this.text = s), (this.textOff = 0);
            }
            let r = Math.min(this.text.length - this.textOff, e, 512);
            this.flushBuffer(t.slice(t.length - i)),
              this.getLine().append(
                Qn(new Le(this.text.slice(this.textOff, this.textOff + r)), t),
                i
              ),
              (this.atCursorPos = !0),
              (this.textOff += r),
              (e -= r),
              (i = 0);
          }
        }
        span(e, t, i, r) {
          this.buildText(t - e, i, r),
            (this.pos = t),
            this.openStart < 0 && (this.openStart = r);
        }
        point(e, t, i, r, s, o) {
          if (this.disallowBlockEffectsFor[o] && i instanceof Ct) {
            if (i.block)
              throw new RangeError(
                "Block decorations may not be specified via plugins"
              );
            if (t > this.doc.lineAt(this.pos).to)
              throw new RangeError(
                "Decorations that replace line breaks may not be specified via plugins"
              );
          }
          let l = t - e;
          if (i instanceof Ct)
            if (i.block)
              i.startSide > 0 && !this.posCovered() && this.getLine(),
                this.addBlockWidget(new dt(i.widget || ai.block, l, i));
            else {
              let a = kt.create(i.widget || ai.inline, l, l ? 0 : i.startSide),
                h =
                  this.atCursorPos &&
                  !a.isEditable &&
                  s <= r.length &&
                  (e < t || i.startSide > 0),
                c =
                  !a.isEditable && (e < t || s > r.length || i.startSide <= 0),
                f = this.getLine();
              this.pendingBuffer == 2 &&
                !h &&
                !a.isEditable &&
                (this.pendingBuffer = 0),
                this.flushBuffer(r),
                h &&
                  (f.append(Qn(new li(1), r), s),
                  (s = r.length + Math.max(0, s - r.length))),
                f.append(Qn(a, r), s),
                (this.atCursorPos = c),
                (this.pendingBuffer = c ? (e < t || s > r.length ? 1 : 2) : 0),
                this.pendingBuffer && (this.bufferMarks = r.slice());
            }
          else
            this.doc.lineAt(this.pos).from == this.pos &&
              this.getLine().addLineDeco(i);
          l &&
            (this.textOff + l <= this.text.length
              ? (this.textOff += l)
              : ((this.skip += l - (this.text.length - this.textOff)),
                (this.text = ""),
                (this.textOff = 0)),
            (this.pos = t)),
            this.openStart < 0 && (this.openStart = s);
        }
        static build(e, t, i, r, s) {
          let o = new Di(e, t, i, s);
          return (
            (o.openEnd = V.spans(r, t, i, o)),
            o.openStart < 0 && (o.openStart = o.openEnd),
            o.finish(o.openEnd),
            o
          );
        }
      }
      function Qn(n, e) {
        for (let t of e) n = new mt(t, [n], n.length);
        return n;
      }
      class ai extends St {
        constructor(e) {
          super(), (this.tag = e);
        }
        eq(e) {
          return e.tag == this.tag;
        }
        toDOM() {
          return document.createElement(this.tag);
        }
        updateDOM(e) {
          return e.nodeName.toLowerCase() == this.tag;
        }
        get isHidden() {
          return !0;
        }
      }
      ai.inline = new ai("span");
      ai.block = new ai("div");
      var F = (function (n) {
        return (n[(n.LTR = 0)] = "LTR"), (n[(n.RTL = 1)] = "RTL"), n;
      })(F || (F = {}));
      const jt = F.LTR,
        Mo = F.RTL;
      function xc(n) {
        let e = [];
        for (let t = 0; t < n.length; t++) e.push(1 << +n[t]);
        return e;
      }
      const oO = xc(
          "88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"
        ),
        lO = xc(
          "4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"
        ),
        Hs = Object.create(null),
        Ne = [];
      for (let n of ["()", "[]", "{}"]) {
        let e = n.charCodeAt(0),
          t = n.charCodeAt(1);
        (Hs[e] = t), (Hs[t] = -e);
      }
      function wc(n) {
        return n <= 247
          ? oO[n]
          : 1424 <= n && n <= 1524
          ? 2
          : 1536 <= n && n <= 1785
          ? lO[n - 1536]
          : 1774 <= n && n <= 2220
          ? 4
          : 8192 <= n && n <= 8204
          ? 256
          : 64336 <= n && n <= 65023
          ? 4
          : 1;
      }
      const aO = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
      class $t {
        get dir() {
          return this.level % 2 ? Mo : jt;
        }
        constructor(e, t, i) {
          (this.from = e), (this.to = t), (this.level = i);
        }
        side(e, t) {
          return (this.dir == t) == e ? this.to : this.from;
        }
        forward(e, t) {
          return e == (this.dir == t);
        }
        static find(e, t, i, r) {
          let s = -1;
          for (let o = 0; o < e.length; o++) {
            let l = e[o];
            if (l.from <= t && l.to >= t) {
              if (l.level == i) return o;
              (s < 0 ||
                (r != 0
                  ? r < 0
                    ? l.from < t
                    : l.to > t
                  : e[s].level > l.level)) &&
                (s = o);
            }
          }
          if (s < 0) throw new RangeError("Index out of range");
          return s;
        }
      }
      function kc(n, e) {
        if (n.length != e.length) return !1;
        for (let t = 0; t < n.length; t++) {
          let i = n[t],
            r = e[t];
          if (
            i.from != r.from ||
            i.to != r.to ||
            i.direction != r.direction ||
            !kc(i.inner, r.inner)
          )
            return !1;
        }
        return !0;
      }
      const B = [];
      function hO(n, e, t, i, r) {
        for (let s = 0; s <= i.length; s++) {
          let o = s ? i[s - 1].to : e,
            l = s < i.length ? i[s].from : t,
            a = s ? 256 : r;
          for (let h = o, c = a, f = a; h < l; h++) {
            let u = wc(n.charCodeAt(h));
            u == 512 ? (u = c) : u == 8 && f == 4 && (u = 16),
              (B[h] = u == 4 ? 2 : u),
              u & 7 && (f = u),
              (c = u);
          }
          for (let h = o, c = a, f = a; h < l; h++) {
            let u = B[h];
            if (u == 128)
              h < l - 1 && c == B[h + 1] && c & 24
                ? (u = B[h] = c)
                : (B[h] = 256);
            else if (u == 64) {
              let d = h + 1;
              for (; d < l && B[d] == 64; ) d++;
              let O =
                (h && c == 8) || (d < t && B[d] == 8) ? (f == 1 ? 1 : 8) : 256;
              for (let m = h; m < d; m++) B[m] = O;
              h = d - 1;
            } else u == 8 && f == 1 && (B[h] = 1);
            (c = u), u & 7 && (f = u);
          }
        }
      }
      function cO(n, e, t, i, r) {
        let s = r == 1 ? 2 : 1;
        for (let o = 0, l = 0, a = 0; o <= i.length; o++) {
          let h = o ? i[o - 1].to : e,
            c = o < i.length ? i[o].from : t;
          for (let f = h, u, d, O; f < c; f++)
            if ((d = Hs[(u = n.charCodeAt(f))]))
              if (d < 0) {
                for (let m = l - 3; m >= 0; m -= 3)
                  if (Ne[m + 1] == -d) {
                    let g = Ne[m + 2],
                      Q = g & 2 ? r : g & 4 ? (g & 1 ? s : r) : 0;
                    Q && (B[f] = B[Ne[m]] = Q), (l = m);
                    break;
                  }
              } else {
                if (Ne.length == 189) break;
                (Ne[l++] = f), (Ne[l++] = u), (Ne[l++] = a);
              }
            else if ((O = B[f]) == 2 || O == 1) {
              let m = O == r;
              a = m ? 0 : 1;
              for (let g = l - 3; g >= 0; g -= 3) {
                let Q = Ne[g + 2];
                if (Q & 2) break;
                if (m) Ne[g + 2] |= 2;
                else {
                  if (Q & 4) break;
                  Ne[g + 2] |= 4;
                }
              }
            }
        }
      }
      function fO(n, e, t, i) {
        for (let r = 0, s = i; r <= t.length; r++) {
          let o = r ? t[r - 1].to : n,
            l = r < t.length ? t[r].from : e;
          for (let a = o; a < l; ) {
            let h = B[a];
            if (h == 256) {
              let c = a + 1;
              for (;;)
                if (c == l) {
                  if (r == t.length) break;
                  (c = t[r++].to), (l = r < t.length ? t[r].from : e);
                } else if (B[c] == 256) c++;
                else break;
              let f = s == 1,
                u = (c < e ? B[c] : i) == 1,
                d = f == u ? (f ? 1 : 2) : i;
              for (let O = c, m = r, g = m ? t[m - 1].to : n; O > a; )
                O == g && ((O = t[--m].from), (g = m ? t[m - 1].to : n)),
                  (B[--O] = d);
              a = c;
            } else (s = h), a++;
          }
        }
      }
      function Ks(n, e, t, i, r, s, o) {
        let l = i % 2 ? 2 : 1;
        if (i % 2 == r % 2)
          for (let a = e, h = 0; a < t; ) {
            let c = !0,
              f = !1;
            if (h == s.length || a < s[h].from) {
              let m = B[a];
              m != l && ((c = !1), (f = m == 16));
            }
            let u = !c && l == 1 ? [] : null,
              d = c ? i : i + 1,
              O = a;
            e: for (;;)
              if (h < s.length && O == s[h].from) {
                if (f) break e;
                let m = s[h];
                if (!c)
                  for (let g = m.to, Q = h + 1; ; ) {
                    if (g == t) break e;
                    if (Q < s.length && s[Q].from == g) g = s[Q++].to;
                    else {
                      if (B[g] == l) break e;
                      break;
                    }
                  }
                if ((h++, u)) u.push(m);
                else {
                  m.from > a && o.push(new $t(a, m.from, d));
                  let g = (m.direction == jt) != !(d % 2);
                  Js(n, g ? i + 1 : i, r, m.inner, m.from, m.to, o), (a = m.to);
                }
                O = m.to;
              } else {
                if (O == t || (c ? B[O] != l : B[O] == l)) break;
                O++;
              }
            u ? Ks(n, a, O, i + 1, r, u, o) : a < O && o.push(new $t(a, O, d)),
              (a = O);
          }
        else
          for (let a = t, h = s.length; a > e; ) {
            let c = !0,
              f = !1;
            if (!h || a > s[h - 1].to) {
              let m = B[a - 1];
              m != l && ((c = !1), (f = m == 16));
            }
            let u = !c && l == 1 ? [] : null,
              d = c ? i : i + 1,
              O = a;
            e: for (;;)
              if (h && O == s[h - 1].to) {
                if (f) break e;
                let m = s[--h];
                if (!c)
                  for (let g = m.from, Q = h; ; ) {
                    if (g == e) break e;
                    if (Q && s[Q - 1].to == g) g = s[--Q].from;
                    else {
                      if (B[g - 1] == l) break e;
                      break;
                    }
                  }
                if (u) u.push(m);
                else {
                  m.to < a && o.push(new $t(m.to, a, d));
                  let g = (m.direction == jt) != !(d % 2);
                  Js(n, g ? i + 1 : i, r, m.inner, m.from, m.to, o),
                    (a = m.from);
                }
                O = m.from;
              } else {
                if (O == e || (c ? B[O - 1] != l : B[O - 1] == l)) break;
                O--;
              }
            u ? Ks(n, O, a, i + 1, r, u, o) : O < a && o.push(new $t(O, a, d)),
              (a = O);
          }
      }
      function Js(n, e, t, i, r, s, o) {
        let l = e % 2 ? 2 : 1;
        hO(n, r, s, i, l),
          cO(n, r, s, i, l),
          fO(r, s, i, l),
          Ks(n, r, s, e, t, i, o);
      }
      function uO(n, e, t) {
        if (!n) return [new $t(0, 0, e == Mo ? 1 : 0)];
        if (e == jt && !t.length && !aO.test(n)) return $c(n.length);
        if (t.length) for (; n.length > B.length; ) B[B.length] = 256;
        let i = [],
          r = e == jt ? 0 : 1;
        return Js(n, r, r, t, 0, n.length, i), i;
      }
      function $c(n) {
        return [new $t(0, n, 0)];
      }
      let Pc = "";
      function dO(n, e, t, i, r) {
        var s;
        let o = i.head - n.from,
          l = $t.find(
            e,
            o,
            (s = i.bidiLevel) !== null && s !== void 0 ? s : -1,
            i.assoc
          ),
          a = e[l],
          h = a.side(r, t);
        if (o == h) {
          let u = (l += r ? 1 : -1);
          if (u < 0 || u >= e.length) return null;
          (a = e[(l = u)]), (o = a.side(!r, t)), (h = a.side(r, t));
        }
        let c = fe(n.text, o, a.forward(r, t));
        (c < a.from || c > a.to) && (c = h),
          (Pc = n.text.slice(Math.min(o, c), Math.max(o, c)));
        let f = l == (r ? e.length - 1 : 0) ? null : e[l + (r ? 1 : -1)];
        return f && c == h && f.level + (r ? 0 : 1) < a.level
          ? S.cursor(f.side(!r, t) + n.from, f.forward(r, t) ? 1 : -1, f.level)
          : S.cursor(c + n.from, a.forward(r, t) ? -1 : 1, a.level);
      }
      function OO(n, e, t) {
        for (let i = e; i < t; i++) {
          let r = wc(n.charCodeAt(i));
          if (r == 1) return jt;
          if (r == 2 || r == 4) return Mo;
        }
        return jt;
      }
      const vc = C.define(),
        Tc = C.define(),
        Cc = C.define(),
        Zc = C.define(),
        eo = C.define(),
        Ac = C.define(),
        Xc = C.define(),
        Yo = C.define(),
        zo = C.define(),
        Rc = C.define({ combine: (n) => n.some((e) => e) }),
        Mc = C.define({ combine: (n) => n.some((e) => e) }),
        Yc = C.define();
      class ii {
        constructor(e, t = "nearest", i = "nearest", r = 5, s = 5, o = !1) {
          (this.range = e),
            (this.y = t),
            (this.x = i),
            (this.yMargin = r),
            (this.xMargin = s),
            (this.isSnapshot = o);
        }
        map(e) {
          return e.empty
            ? this
            : new ii(
                this.range.map(e),
                this.y,
                this.x,
                this.yMargin,
                this.xMargin,
                this.isSnapshot
              );
        }
        clip(e) {
          return this.range.to <= e.doc.length
            ? this
            : new ii(
                S.cursor(e.doc.length),
                this.y,
                this.x,
                this.yMargin,
                this.xMargin,
                this.isSnapshot
              );
        }
      }
      const Sn = R.define({ map: (n, e) => n.map(e) }),
        zc = R.define();
      function ke(n, e, t) {
        let i = n.facet(Zc);
        i.length
          ? i[0](e)
          : (window.onerror &&
              window.onerror(String(e), t, void 0, void 0, e)) ||
            (t ? console.error(t + ":", e) : console.error(e));
      }
      const ut = C.define({ combine: (n) => (n.length ? n[0] : !0) });
      let pO = 0;
      const Ft = C.define({
        combine(n) {
          return n.filter((e, t) => {
            for (let i = 0; i < t; i++) if (n[i].plugin == e.plugin) return !1;
            return !0;
          });
        },
      });
      class ne {
        constructor(e, t, i, r, s) {
          (this.id = e),
            (this.create = t),
            (this.domEventHandlers = i),
            (this.domEventObservers = r),
            (this.baseExtensions = s(this)),
            (this.extension = this.baseExtensions.concat(
              Ft.of({ plugin: this, arg: void 0 })
            ));
        }
        of(e) {
          return this.baseExtensions.concat(Ft.of({ plugin: this, arg: e }));
        }
        static define(e, t) {
          const {
            eventHandlers: i,
            eventObservers: r,
            provide: s,
            decorations: o,
          } = t || {};
          return new ne(pO++, e, i, r, (l) => {
            let a = [];
            return (
              o &&
                a.push(
                  Bi.of((h) => {
                    let c = h.plugin(l);
                    return c ? o(c) : A.none;
                  })
                ),
              s && a.push(s(l)),
              a
            );
          });
        }
        static fromClass(e, t) {
          return ne.define((i, r) => new e(i, r), t);
        }
      }
      class Hr {
        constructor(e) {
          (this.spec = e), (this.mustUpdate = null), (this.value = null);
        }
        get plugin() {
          return this.spec && this.spec.plugin;
        }
        update(e) {
          if (this.value) {
            if (this.mustUpdate) {
              let t = this.mustUpdate;
              if (((this.mustUpdate = null), this.value.update))
                try {
                  this.value.update(t);
                } catch (i) {
                  if (
                    (ke(t.state, i, "CodeMirror plugin crashed"),
                    this.value.destroy)
                  )
                    try {
                      this.value.destroy();
                    } catch {}
                  this.deactivate();
                }
            }
          } else if (this.spec)
            try {
              this.value = this.spec.plugin.create(e, this.spec.arg);
            } catch (t) {
              ke(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
            }
          return this;
        }
        destroy(e) {
          var t;
          if (!((t = this.value) === null || t === void 0) && t.destroy)
            try {
              this.value.destroy();
            } catch (i) {
              ke(e.state, i, "CodeMirror plugin crashed");
            }
        }
        deactivate() {
          this.spec = this.value = null;
        }
      }
      const Dc = C.define(),
        Do = C.define(),
        Bi = C.define(),
        Ec = C.define(),
        Xr = C.define(),
        _c = C.define();
      function Yl(n, e) {
        let t = n.state.facet(_c);
        if (!t.length) return t;
        let i = t.map((s) => (s instanceof Function ? s(n) : s)),
          r = [];
        return (
          V.spans(i, e.from, e.to, {
            point() {},
            span(s, o, l, a) {
              let h = s - e.from,
                c = o - e.from,
                f = r;
              for (let u = l.length - 1; u >= 0; u--, a--) {
                let d = l[u].spec.bidiIsolate,
                  O;
                if (
                  (d == null && (d = OO(e.text, h, c)),
                  a > 0 &&
                    f.length &&
                    (O = f[f.length - 1]).to == h &&
                    O.direction == d)
                )
                  (O.to = c), (f = O.inner);
                else {
                  let m = { from: h, to: c, direction: d, inner: [] };
                  f.push(m), (f = m.inner);
                }
              }
            },
          }),
          r
        );
      }
      const Vc = C.define();
      function Eo(n) {
        let e = 0,
          t = 0,
          i = 0,
          r = 0;
        for (let s of n.state.facet(Vc)) {
          let o = s(n);
          o &&
            (o.left != null && (e = Math.max(e, o.left)),
            o.right != null && (t = Math.max(t, o.right)),
            o.top != null && (i = Math.max(i, o.top)),
            o.bottom != null && (r = Math.max(r, o.bottom)));
        }
        return { left: e, right: t, top: i, bottom: r };
      }
      const Ci = C.define();
      class _e {
        constructor(e, t, i, r) {
          (this.fromA = e), (this.toA = t), (this.fromB = i), (this.toB = r);
        }
        join(e) {
          return new _e(
            Math.min(this.fromA, e.fromA),
            Math.max(this.toA, e.toA),
            Math.min(this.fromB, e.fromB),
            Math.max(this.toB, e.toB)
          );
        }
        addToSet(e) {
          let t = e.length,
            i = this;
          for (; t > 0; t--) {
            let r = e[t - 1];
            if (!(r.fromA > i.toA)) {
              if (r.toA < i.fromA) break;
              (i = i.join(r)), e.splice(t - 1, 1);
            }
          }
          return e.splice(t, 0, i), e;
        }
        static extendWithRanges(e, t) {
          if (t.length == 0) return e;
          let i = [];
          for (let r = 0, s = 0, o = 0, l = 0; ; r++) {
            let a = r == e.length ? null : e[r],
              h = o - l,
              c = a ? a.fromB : 1e9;
            for (; s < t.length && t[s] < c; ) {
              let f = t[s],
                u = t[s + 1],
                d = Math.max(l, f),
                O = Math.min(c, u);
              if ((d <= O && new _e(d + h, O + h, d, O).addToSet(i), u > c))
                break;
              s += 2;
            }
            if (!a) return i;
            new _e(a.fromA, a.toA, a.fromB, a.toB).addToSet(i),
              (o = a.toA),
              (l = a.toB);
          }
        }
      }
      class nr {
        constructor(e, t, i) {
          (this.view = e),
            (this.state = t),
            (this.transactions = i),
            (this.flags = 0),
            (this.startState = e.state),
            (this.changes = re.empty(this.startState.doc.length));
          for (let s of i) this.changes = this.changes.compose(s.changes);
          let r = [];
          this.changes.iterChangedRanges((s, o, l, a) =>
            r.push(new _e(s, o, l, a))
          ),
            (this.changedRanges = r);
        }
        static create(e, t, i) {
          return new nr(e, t, i);
        }
        get viewportChanged() {
          return (this.flags & 4) > 0;
        }
        get viewportMoved() {
          return (this.flags & 8) > 0;
        }
        get heightChanged() {
          return (this.flags & 2) > 0;
        }
        get geometryChanged() {
          return this.docChanged || (this.flags & 18) > 0;
        }
        get focusChanged() {
          return (this.flags & 1) > 0;
        }
        get docChanged() {
          return !this.changes.empty;
        }
        get selectionSet() {
          return this.transactions.some((e) => e.selection);
        }
        get empty() {
          return this.flags == 0 && this.transactions.length == 0;
        }
      }
      class zl extends I {
        get length() {
          return this.view.state.doc.length;
        }
        constructor(e) {
          super(),
            (this.view = e),
            (this.decorations = []),
            (this.dynamicDecorationMap = [!1]),
            (this.domChanged = null),
            (this.hasComposition = null),
            (this.markedForComposition = new Set()),
            (this.editContextFormatting = A.none),
            (this.lastCompositionAfterCursor = !1),
            (this.minWidth = 0),
            (this.minWidthFrom = 0),
            (this.minWidthTo = 0),
            (this.impreciseAnchor = null),
            (this.impreciseHead = null),
            (this.forceSelection = !1),
            (this.lastUpdate = Date.now()),
            this.setDOM(e.contentDOM),
            (this.children = [new te()]),
            this.children[0].setParent(this),
            this.updateDeco(),
            this.updateInner([new _e(0, 0, 0, e.state.doc.length)], 0, null);
        }
        update(e) {
          var t;
          let i = e.changedRanges;
          this.minWidth > 0 &&
            i.length &&
            (i.every(
              ({ fromA: h, toA: c }) =>
                c < this.minWidthFrom || h > this.minWidthTo
            )
              ? ((this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1)),
                (this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)))
              : (this.minWidth = this.minWidthFrom = this.minWidthTo = 0)),
            this.updateEditContextFormatting(e);
          let r = -1;
          this.view.inputState.composing >= 0 &&
            !this.view.observer.editContext &&
            (!((t = this.domChanged) === null || t === void 0) && t.newSel
              ? (r = this.domChanged.newSel.head)
              : !xO(e.changes, this.hasComposition) &&
                !e.selectionSet &&
                (r = e.state.selection.main.head));
          let s = r > -1 ? gO(this.view, e.changes, r) : null;
          if (((this.domChanged = null), this.hasComposition)) {
            this.markedForComposition.clear();
            let { from: h, to: c } = this.hasComposition;
            i = new _e(
              h,
              c,
              e.changes.mapPos(h, -1),
              e.changes.mapPos(c, 1)
            ).addToSet(i.slice());
          }
          (this.hasComposition = s
            ? { from: s.range.fromB, to: s.range.toB }
            : null),
            (T.ie || T.chrome) &&
              !s &&
              e &&
              e.state.doc.lines != e.startState.doc.lines &&
              (this.forceSelection = !0);
          let o = this.decorations,
            l = this.updateDeco(),
            a = yO(o, l, e.changes);
          return (
            (i = _e.extendWithRanges(i, a)),
            !(this.flags & 7) && i.length == 0
              ? !1
              : (this.updateInner(i, e.startState.doc.length, s),
                e.transactions.length && (this.lastUpdate = Date.now()),
                !0)
          );
        }
        updateInner(e, t, i) {
          (this.view.viewState.mustMeasureContent = !0),
            this.updateChildren(e, t, i);
          let { observer: r } = this.view;
          r.ignore(() => {
            (this.dom.style.height =
              this.view.viewState.contentHeight / this.view.scaleY + "px"),
              (this.dom.style.flexBasis = this.minWidth
                ? this.minWidth + "px"
                : "");
            let o =
              T.chrome || T.ios
                ? { node: r.selectionRange.focusNode, written: !1 }
                : void 0;
            this.sync(this.view, o),
              (this.flags &= -8),
              o &&
                (o.written || r.selectionRange.focusNode != o.node) &&
                (this.forceSelection = !0),
              (this.dom.style.height = "");
          }),
            this.markedForComposition.forEach((o) => (o.flags &= -9));
          let s = [];
          if (
            this.view.viewport.from ||
            this.view.viewport.to < this.view.state.doc.length
          )
            for (let o of this.children)
              o instanceof dt && o.widget instanceof Fs && s.push(o.dom);
          r.updateGaps(s);
        }
        updateChildren(e, t, i) {
          let r = i ? i.range.addToSet(e.slice()) : e,
            s = this.childCursor(t);
          for (let o = r.length - 1; ; o--) {
            let l = o >= 0 ? r[o] : null;
            if (!l) break;
            let { fromA: a, toA: h, fromB: c, toB: f } = l,
              u,
              d,
              O,
              m;
            if (i && i.range.fromB < f && i.range.toB > c) {
              let k = Di.build(
                  this.view.state.doc,
                  c,
                  i.range.fromB,
                  this.decorations,
                  this.dynamicDecorationMap
                ),
                b = Di.build(
                  this.view.state.doc,
                  i.range.toB,
                  f,
                  this.decorations,
                  this.dynamicDecorationMap
                );
              (d = k.breakAtStart), (O = k.openStart), (m = b.openEnd);
              let w = this.compositionView(i);
              b.breakAtStart
                ? (w.breakAfter = 1)
                : b.content.length &&
                  w.merge(
                    w.length,
                    w.length,
                    b.content[0],
                    !1,
                    b.openStart,
                    0
                  ) &&
                  ((w.breakAfter = b.content[0].breakAfter), b.content.shift()),
                k.content.length &&
                  w.merge(
                    0,
                    0,
                    k.content[k.content.length - 1],
                    !0,
                    0,
                    k.openEnd
                  ) &&
                  k.content.pop(),
                (u = k.content.concat(w).concat(b.content));
            } else
              ({
                content: u,
                breakAtStart: d,
                openStart: O,
                openEnd: m,
              } = Di.build(
                this.view.state.doc,
                c,
                f,
                this.decorations,
                this.dynamicDecorationMap
              ));
            let { i: g, off: Q } = s.findPos(h, 1),
              { i: y, off: x } = s.findPos(a, -1);
            Oc(this, y, x, g, Q, u, d, O, m);
          }
          i && this.fixCompositionDOM(i);
        }
        updateEditContextFormatting(e) {
          this.editContextFormatting = this.editContextFormatting.map(
            e.changes
          );
          for (let t of e.transactions)
            for (let i of t.effects)
              i.is(zc) && (this.editContextFormatting = i.value);
        }
        compositionView(e) {
          let t = new Le(e.text.nodeValue);
          t.flags |= 8;
          for (let { deco: r } of e.marks) t = new mt(r, [t], t.length);
          let i = new te();
          return i.append(t, 0), i;
        }
        fixCompositionDOM(e) {
          let t = (s, o) => {
              (o.flags |= 8 | (o.children.some((a) => a.flags & 7) ? 1 : 0)),
                this.markedForComposition.add(o);
              let l = I.get(s);
              l && l != o && (l.dom = null), o.setDOM(s);
            },
            i = this.childPos(e.range.fromB, 1),
            r = this.children[i.i];
          t(e.line, r);
          for (let s = e.marks.length - 1; s >= -1; s--)
            (i = r.childPos(i.off, 1)),
              (r = r.children[i.i]),
              t(s >= 0 ? e.marks[s].node : e.text, r);
        }
        updateSelection(e = !1, t = !1) {
          (e || !this.view.observer.selectionRange.focusNode) &&
            this.view.observer.readSelectionRange();
          let i = this.view.root.activeElement,
            r = i == this.dom,
            s =
              !r &&
              !(this.view.state.facet(ut) || this.dom.tabIndex > -1) &&
              Vn(this.dom, this.view.observer.selectionRange) &&
              !(i && this.dom.contains(i));
          if (!(r || t || s)) return;
          let o = this.forceSelection;
          this.forceSelection = !1;
          let l = this.view.state.selection.main,
            a = this.moveToLine(this.domAtPos(l.anchor)),
            h = l.empty ? a : this.moveToLine(this.domAtPos(l.head));
          if (T.gecko && l.empty && !this.hasComposition && mO(a)) {
            let f = document.createTextNode("");
            this.view.observer.ignore(() =>
              a.node.insertBefore(f, a.node.childNodes[a.offset] || null)
            ),
              (a = h = new de(f, 0)),
              (o = !0);
          }
          let c = this.view.observer.selectionRange;
          (o ||
            !c.focusNode ||
            ((!zi(a.node, a.offset, c.anchorNode, c.anchorOffset) ||
              !zi(h.node, h.offset, c.focusNode, c.focusOffset)) &&
              !this.suppressWidgetCursorChange(c, l))) &&
            (this.view.observer.ignore(() => {
              T.android &&
                T.chrome &&
                this.dom.contains(c.focusNode) &&
                bO(c.focusNode, this.dom) &&
                (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
              let f = Li(this.view.root);
              if (f)
                if (l.empty) {
                  if (T.gecko) {
                    let u = QO(a.node, a.offset);
                    if (u && u != 3) {
                      let d = (u == 1 ? fc : uc)(a.node, a.offset);
                      d && (a = new de(d.node, d.offset));
                    }
                  }
                  f.collapse(a.node, a.offset),
                    l.bidiLevel != null &&
                      f.caretBidiLevel !== void 0 &&
                      (f.caretBidiLevel = l.bidiLevel);
                } else if (f.extend) {
                  f.collapse(a.node, a.offset);
                  try {
                    f.extend(h.node, h.offset);
                  } catch {}
                } else {
                  let u = document.createRange();
                  l.anchor > l.head && ([a, h] = [h, a]),
                    u.setEnd(h.node, h.offset),
                    u.setStart(a.node, a.offset),
                    f.removeAllRanges(),
                    f.addRange(u);
                }
              s &&
                this.view.root.activeElement == this.dom &&
                (this.dom.blur(), i && i.focus());
            }),
            this.view.observer.setSelectionRange(a, h)),
            (this.impreciseAnchor = a.precise
              ? null
              : new de(c.anchorNode, c.anchorOffset)),
            (this.impreciseHead = h.precise
              ? null
              : new de(c.focusNode, c.focusOffset));
        }
        suppressWidgetCursorChange(e, t) {
          return (
            this.hasComposition &&
            t.empty &&
            zi(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) &&
            this.posFromDOM(e.focusNode, e.focusOffset) == t.head
          );
        }
        enforceCursorAssoc() {
          if (this.hasComposition) return;
          let { view: e } = this,
            t = e.state.selection.main,
            i = Li(e.root),
            { anchorNode: r, anchorOffset: s } = e.observer.selectionRange;
          if (!i || !t.empty || !t.assoc || !i.modify) return;
          let o = te.find(this, t.head);
          if (!o) return;
          let l = o.posAtStart;
          if (t.head == l || t.head == l + o.length) return;
          let a = this.coordsAt(t.head, -1),
            h = this.coordsAt(t.head, 1);
          if (!a || !h || a.bottom > h.top) return;
          let c = this.domAtPos(t.head + t.assoc);
          i.collapse(c.node, c.offset),
            i.modify(
              "move",
              t.assoc < 0 ? "forward" : "backward",
              "lineboundary"
            ),
            e.observer.readSelectionRange();
          let f = e.observer.selectionRange;
          e.docView.posFromDOM(f.anchorNode, f.anchorOffset) != t.from &&
            i.collapse(r, s);
        }
        moveToLine(e) {
          let t = this.dom,
            i;
          if (e.node != t) return e;
          for (let r = e.offset; !i && r < t.childNodes.length; r++) {
            let s = I.get(t.childNodes[r]);
            s instanceof te && (i = s.domAtPos(0));
          }
          for (let r = e.offset - 1; !i && r >= 0; r--) {
            let s = I.get(t.childNodes[r]);
            s instanceof te && (i = s.domAtPos(s.length));
          }
          return i ? new de(i.node, i.offset, !0) : e;
        }
        nearest(e) {
          for (let t = e; t; ) {
            let i = I.get(t);
            if (i && i.rootView == this) return i;
            t = t.parentNode;
          }
          return null;
        }
        posFromDOM(e, t) {
          let i = this.nearest(e);
          if (!i)
            throw new RangeError(
              "Trying to find position for a DOM position outside of the document"
            );
          return i.localPosFromDOM(e, t) + i.posAtStart;
        }
        domAtPos(e) {
          let { i: t, off: i } = this.childCursor().findPos(e, -1);
          for (; t < this.children.length - 1; ) {
            let r = this.children[t];
            if (i < r.length || r instanceof te) break;
            t++, (i = 0);
          }
          return this.children[t].domAtPos(i);
        }
        coordsAt(e, t) {
          let i = null,
            r = 0;
          for (let s = this.length, o = this.children.length - 1; o >= 0; o--) {
            let l = this.children[o],
              a = s - l.breakAfter,
              h = a - l.length;
            if (a < e) break;
            if (
              h <= e &&
              (h < e || l.covers(-1)) &&
              (a > e || l.covers(1)) &&
              (!i || (l instanceof te && !(i instanceof te && t >= 0)))
            )
              (i = l), (r = h);
            else if (
              i &&
              h == e &&
              a == e &&
              l instanceof dt &&
              Math.abs(t) < 2
            ) {
              if (l.deco.startSide < 0) break;
              o && (i = null);
            }
            s = h;
          }
          return i ? i.coordsAt(e - r, t) : null;
        }
        coordsForChar(e) {
          let { i: t, off: i } = this.childPos(e, 1),
            r = this.children[t];
          if (!(r instanceof te)) return null;
          for (; r.children.length; ) {
            let { i: l, off: a } = r.childPos(i, 1);
            for (; ; l++) {
              if (l == r.children.length) return null;
              if ((r = r.children[l]).length) break;
            }
            i = a;
          }
          if (!(r instanceof Le)) return null;
          let s = fe(r.text, i);
          if (s == i) return null;
          let o = Lt(r.dom, i, s).getClientRects();
          for (let l = 0; l < o.length; l++) {
            let a = o[l];
            if (l == o.length - 1 || (a.top < a.bottom && a.left < a.right))
              return a;
          }
          return null;
        }
        measureVisibleLineHeights(e) {
          let t = [],
            { from: i, to: r } = e,
            s = this.view.contentDOM.clientWidth,
            o =
              s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1,
            l = -1,
            a = this.view.textDirection == F.LTR;
          for (let h = 0, c = 0; c < this.children.length; c++) {
            let f = this.children[c],
              u = h + f.length;
            if (u > r) break;
            if (h >= i) {
              let d = f.dom.getBoundingClientRect();
              if ((t.push(d.height), o)) {
                let O = f.dom.lastChild,
                  m = O ? ji(O) : [];
                if (m.length) {
                  let g = m[m.length - 1],
                    Q = a ? g.right - d.left : d.right - g.left;
                  Q > l &&
                    ((l = Q),
                    (this.minWidth = s),
                    (this.minWidthFrom = h),
                    (this.minWidthTo = u));
                }
              }
            }
            h = u + f.breakAfter;
          }
          return t;
        }
        textDirectionAt(e) {
          let { i: t } = this.childPos(e, 1);
          return getComputedStyle(this.children[t].dom).direction == "rtl"
            ? F.RTL
            : F.LTR;
        }
        measureTextSize() {
          for (let s of this.children)
            if (s instanceof te) {
              let o = s.measureTextSize();
              if (o) return o;
            }
          let e = document.createElement("div"),
            t,
            i,
            r;
          return (
            (e.className = "cm-line"),
            (e.style.width = "99999px"),
            (e.style.position = "absolute"),
            (e.textContent = "abc def ghi jkl mno pqr stu"),
            this.view.observer.ignore(() => {
              this.dom.appendChild(e);
              let s = ji(e.firstChild)[0];
              (t = e.getBoundingClientRect().height),
                (i = s ? s.width / 27 : 7),
                (r = s ? s.height : t),
                e.remove();
            }),
            { lineHeight: t, charWidth: i, textHeight: r }
          );
        }
        childCursor(e = this.length) {
          let t = this.children.length;
          return (
            t && (e -= this.children[--t].length), new dc(this.children, e, t)
          );
        }
        computeBlockGapDeco() {
          let e = [],
            t = this.view.viewState;
          for (let i = 0, r = 0; ; r++) {
            let s = r == t.viewports.length ? null : t.viewports[r],
              o = s ? s.from - 1 : this.length;
            if (o > i) {
              let l =
                (t.lineBlockAt(o).bottom - t.lineBlockAt(i).top) /
                this.view.scaleY;
              e.push(
                A.replace({
                  widget: new Fs(l),
                  block: !0,
                  inclusive: !0,
                  isBlockGap: !0,
                }).range(i, o)
              );
            }
            if (!s) break;
            i = s.to + 1;
          }
          return A.set(e);
        }
        updateDeco() {
          let e = 1,
            t = this.view.state
              .facet(Bi)
              .map((s) =>
                (this.dynamicDecorationMap[e++] = typeof s == "function")
                  ? s(this.view)
                  : s
              ),
            i = !1,
            r = this.view.state.facet(Ec).map((s, o) => {
              let l = typeof s == "function";
              return l && (i = !0), l ? s(this.view) : s;
            });
          for (
            r.length &&
              ((this.dynamicDecorationMap[e++] = i), t.push(V.join(r))),
              this.decorations = [
                this.editContextFormatting,
                ...t,
                this.computeBlockGapDeco(),
                this.view.viewState.lineGapDeco,
              ];
            e < this.decorations.length;

          )
            this.dynamicDecorationMap[e++] = !1;
          return this.decorations;
        }
        scrollIntoView(e) {
          if (e.isSnapshot) {
            let h = this.view.viewState.lineBlockAt(e.range.head);
            (this.view.scrollDOM.scrollTop = h.top - e.yMargin),
              (this.view.scrollDOM.scrollLeft = e.xMargin);
            return;
          }
          for (let h of this.view.state.facet(Yc))
            try {
              if (h(this.view, e.range, e)) return !0;
            } catch (c) {
              ke(this.view.state, c, "scroll handler");
            }
          let { range: t } = e,
            i = this.coordsAt(
              t.head,
              t.empty ? t.assoc : t.head > t.anchor ? -1 : 1
            ),
            r;
          if (!i) return;
          !t.empty &&
            (r = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) &&
            (i = {
              left: Math.min(i.left, r.left),
              top: Math.min(i.top, r.top),
              right: Math.max(i.right, r.right),
              bottom: Math.max(i.bottom, r.bottom),
            });
          let s = Eo(this.view),
            o = {
              left: i.left - s.left,
              top: i.top - s.top,
              right: i.right + s.right,
              bottom: i.bottom + s.bottom,
            },
            { offsetWidth: l, offsetHeight: a } = this.view.scrollDOM;
          Nd(
            this.view.scrollDOM,
            o,
            t.head < t.anchor ? -1 : 1,
            e.x,
            e.y,
            Math.max(Math.min(e.xMargin, l), -l),
            Math.max(Math.min(e.yMargin, a), -a),
            this.view.textDirection == F.LTR
          );
        }
      }
      function mO(n) {
        return (
          n.node.nodeType == 1 &&
          n.node.firstChild &&
          (n.offset == 0 ||
            n.node.childNodes[n.offset - 1].contentEditable == "false") &&
          (n.offset == n.node.childNodes.length ||
            n.node.childNodes[n.offset].contentEditable == "false")
        );
      }
      function qc(n, e) {
        let t = n.observer.selectionRange;
        if (!t.focusNode) return null;
        let i = fc(t.focusNode, t.focusOffset),
          r = uc(t.focusNode, t.focusOffset),
          s = i || r;
        if (r && i && r.node != i.node) {
          let l = I.get(r.node);
          if (!l || (l instanceof Le && l.text != r.node.nodeValue)) s = r;
          else if (n.docView.lastCompositionAfterCursor) {
            let a = I.get(i.node);
            !a || (a instanceof Le && a.text != i.node.nodeValue) || (s = r);
          }
        }
        if (((n.docView.lastCompositionAfterCursor = s != i), !s)) return null;
        let o = e - s.offset;
        return { from: o, to: o + s.node.nodeValue.length, node: s.node };
      }
      function gO(n, e, t) {
        let i = qc(n, t);
        if (!i) return null;
        let { node: r, from: s, to: o } = i,
          l = r.nodeValue;
        if (/[\n\r]/.test(l) || n.state.doc.sliceString(i.from, i.to) != l)
          return null;
        let a = e.invertedDesc,
          h = new _e(a.mapPos(s), a.mapPos(o), s, o),
          c = [];
        for (let f = r.parentNode; ; f = f.parentNode) {
          let u = I.get(f);
          if (u instanceof mt) c.push({ node: f, deco: u.mark });
          else {
            if (
              u instanceof te ||
              (f.nodeName == "DIV" && f.parentNode == n.contentDOM)
            )
              return { range: h, text: r, marks: c, line: f };
            if (f != n.contentDOM)
              c.push({
                node: f,
                deco: new on({
                  inclusive: !0,
                  attributes: rO(f),
                  tagName: f.tagName.toLowerCase(),
                }),
              });
            else return null;
          }
        }
      }
      function QO(n, e) {
        return n.nodeType != 1
          ? 0
          : (e && n.childNodes[e - 1].contentEditable == "false" ? 1 : 0) |
              (e < n.childNodes.length &&
              n.childNodes[e].contentEditable == "false"
                ? 2
                : 0);
      }
      let SO = class {
        constructor() {
          this.changes = [];
        }
        compareRange(e, t) {
          qn(e, t, this.changes);
        }
        comparePoint(e, t) {
          qn(e, t, this.changes);
        }
        boundChange(e) {
          qn(e, e, this.changes);
        }
      };
      function yO(n, e, t) {
        let i = new SO();
        return V.compare(n, e, t, i), i.changes;
      }
      function bO(n, e) {
        for (let t = n; t && t != e; t = t.assignedSlot || t.parentNode)
          if (t.nodeType == 1 && t.contentEditable == "false") return !0;
        return !1;
      }
      function xO(n, e) {
        let t = !1;
        return (
          e &&
            n.iterChangedRanges((i, r) => {
              i < e.to && r > e.from && (t = !0);
            }),
          t
        );
      }
      function wO(n, e, t = 1) {
        let i = n.charCategorizer(e),
          r = n.doc.lineAt(e),
          s = e - r.from;
        if (r.length == 0) return S.cursor(e);
        s == 0 ? (t = 1) : s == r.length && (t = -1);
        let o = s,
          l = s;
        t < 0 ? (o = fe(r.text, s, !1)) : (l = fe(r.text, s));
        let a = i(r.text.slice(o, l));
        for (; o > 0; ) {
          let h = fe(r.text, o, !1);
          if (i(r.text.slice(h, o)) != a) break;
          o = h;
        }
        for (; l < r.length; ) {
          let h = fe(r.text, l);
          if (i(r.text.slice(l, h)) != a) break;
          l = h;
        }
        return S.range(o + r.from, l + r.from);
      }
      function kO(n, e) {
        return e.left > n ? e.left - n : Math.max(0, n - e.right);
      }
      function $O(n, e) {
        return e.top > n ? e.top - n : Math.max(0, n - e.bottom);
      }
      function Kr(n, e) {
        return n.top < e.bottom - 1 && n.bottom > e.top + 1;
      }
      function Dl(n, e) {
        return e < n.top
          ? { top: e, left: n.left, right: n.right, bottom: n.bottom }
          : n;
      }
      function El(n, e) {
        return e > n.bottom
          ? { top: n.top, left: n.left, right: n.right, bottom: e }
          : n;
      }
      function to(n, e, t) {
        let i,
          r,
          s,
          o,
          l = !1,
          a,
          h,
          c,
          f;
        for (let O = n.firstChild; O; O = O.nextSibling) {
          let m = ji(O);
          for (let g = 0; g < m.length; g++) {
            let Q = m[g];
            r && Kr(r, Q) && (Q = Dl(El(Q, r.bottom), r.top));
            let y = kO(e, Q),
              x = $O(t, Q);
            if (y == 0 && x == 0)
              return O.nodeType == 3 ? _l(O, e, t) : to(O, e, t);
            (!i || o > x || (o == x && s > y)) &&
              ((i = O),
              (r = Q),
              (s = y),
              (o = x),
              (l = y ? (e < Q.left ? g > 0 : g < m.length - 1) : !0)),
              y == 0
                ? t > Q.bottom && (!c || c.bottom < Q.bottom)
                  ? ((a = O), (c = Q))
                  : t < Q.top && (!f || f.top > Q.top) && ((h = O), (f = Q))
                : c && Kr(c, Q)
                ? (c = El(c, Q.bottom))
                : f && Kr(f, Q) && (f = Dl(f, Q.top));
          }
        }
        if (
          (c && c.bottom >= t
            ? ((i = a), (r = c))
            : f && f.top <= t && ((i = h), (r = f)),
          !i)
        )
          return { node: n, offset: 0 };
        let u = Math.max(r.left, Math.min(r.right, e));
        if (i.nodeType == 3) return _l(i, u, t);
        if (l && i.contentEditable != "false") return to(i, u, t);
        let d =
          Array.prototype.indexOf.call(n.childNodes, i) +
          (e >= (r.left + r.right) / 2 ? 1 : 0);
        return { node: n, offset: d };
      }
      function _l(n, e, t) {
        let i = n.nodeValue.length,
          r = -1,
          s = 1e9,
          o = 0;
        for (let l = 0; l < i; l++) {
          let a = Lt(n, l, l + 1).getClientRects();
          for (let h = 0; h < a.length; h++) {
            let c = a[h];
            if (c.top == c.bottom) continue;
            o || (o = e - c.left);
            let f = (c.top > t ? c.top - t : t - c.bottom) - 1;
            if (c.left - 1 <= e && c.right + 1 >= e && f < s) {
              let u = e >= (c.left + c.right) / 2,
                d = u;
              if (
                ((T.chrome || T.gecko) &&
                  Lt(n, l).getBoundingClientRect().left == c.right &&
                  (d = !u),
                f <= 0)
              )
                return { node: n, offset: l + (d ? 1 : 0) };
              (r = l + (d ? 1 : 0)), (s = f);
            }
          }
        }
        return { node: n, offset: r > -1 ? r : o > 0 ? n.nodeValue.length : 0 };
      }
      function Wc(n, e, t, i = -1) {
        var r, s;
        let o = n.contentDOM.getBoundingClientRect(),
          l = o.top + n.viewState.paddingTop,
          a,
          { docHeight: h } = n.viewState,
          { x: c, y: f } = e,
          u = f - l;
        if (u < 0) return 0;
        if (u > h) return n.state.doc.length;
        for (
          let k = n.viewState.heightOracle.textHeight / 2, b = !1;
          (a = n.elementAtHeight(u)), a.type != ge.Text;

        )
          for (
            ;
            (u = i > 0 ? a.bottom + k : a.top - k), !(u >= 0 && u <= h);

          ) {
            if (b) return t ? null : 0;
            (b = !0), (i = -i);
          }
        f = l + u;
        let d = a.from;
        if (d < n.viewport.from)
          return n.viewport.from == 0 ? 0 : t ? null : Vl(n, o, a, c, f);
        if (d > n.viewport.to)
          return n.viewport.to == n.state.doc.length
            ? n.state.doc.length
            : t
            ? null
            : Vl(n, o, a, c, f);
        let O = n.dom.ownerDocument,
          m = n.root.elementFromPoint ? n.root : O,
          g = m.elementFromPoint(c, f);
        g && !n.contentDOM.contains(g) && (g = null),
          g ||
            ((c = Math.max(o.left + 1, Math.min(o.right - 1, c))),
            (g = m.elementFromPoint(c, f)),
            g && !n.contentDOM.contains(g) && (g = null));
        let Q,
          y = -1;
        if (
          g &&
          ((r = n.docView.nearest(g)) === null || r === void 0
            ? void 0
            : r.isEditable) != !1
        ) {
          if (O.caretPositionFromPoint) {
            let k = O.caretPositionFromPoint(c, f);
            k && ({ offsetNode: Q, offset: y } = k);
          } else if (O.caretRangeFromPoint) {
            let k = O.caretRangeFromPoint(c, f);
            k &&
              (({ startContainer: Q, startOffset: y } = k),
              (!n.contentDOM.contains(Q) ||
                (T.safari && PO(Q, y, c)) ||
                (T.chrome && vO(Q, y, c))) &&
                (Q = void 0));
          }
          Q && (y = Math.min(ot(Q), y));
        }
        if (!Q || !n.docView.dom.contains(Q)) {
          let k = te.find(n.docView, d);
          if (!k) return u > a.top + a.height / 2 ? a.to : a.from;
          ({ node: Q, offset: y } = to(k.dom, c, f));
        }
        let x = n.docView.nearest(Q);
        if (!x) return null;
        if (
          x.isWidget &&
          ((s = x.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1
        ) {
          let k = x.dom.getBoundingClientRect();
          return e.y < k.top ||
            (e.y <= k.bottom && e.x <= (k.left + k.right) / 2)
            ? x.posAtStart
            : x.posAtEnd;
        } else return x.localPosFromDOM(Q, y) + x.posAtStart;
      }
      function Vl(n, e, t, i, r) {
        let s = Math.round((i - e.left) * n.defaultCharacterWidth);
        if (n.lineWrapping && t.height > n.defaultLineHeight * 1.5) {
          let l = n.viewState.heightOracle.textHeight,
            a = Math.floor((r - t.top - (n.defaultLineHeight - l) * 0.5) / l);
          s += a * n.viewState.heightOracle.lineLength;
        }
        let o = n.state.sliceDoc(t.from, t.to);
        return t.from + qs(o, s, n.state.tabSize);
      }
      function PO(n, e, t) {
        let i,
          r = n;
        if (n.nodeType != 3 || e != (i = n.nodeValue.length)) return !1;
        for (;;) {
          let s = r.nextSibling;
          if (s) {
            if (s.nodeName == "BR") break;
            return !1;
          } else {
            let o = r.parentNode;
            if (!o || o.nodeName == "DIV") break;
            r = o;
          }
        }
        return Lt(n, i - 1, i).getBoundingClientRect().right > t;
      }
      function vO(n, e, t) {
        if (e != 0) return !1;
        for (let r = n; ; ) {
          let s = r.parentNode;
          if (!s || s.nodeType != 1 || s.firstChild != r) return !1;
          if (s.classList.contains("cm-line")) break;
          r = s;
        }
        let i =
          n.nodeType == 1
            ? n.getBoundingClientRect()
            : Lt(n, 0, Math.max(n.nodeValue.length, 1)).getBoundingClientRect();
        return t - i.left > 5;
      }
      function io(n, e, t) {
        let i = n.lineBlockAt(e);
        if (Array.isArray(i.type)) {
          let r;
          for (let s of i.type) {
            if (s.from > e) break;
            if (!(s.to < e)) {
              if (s.from < e && s.to > e) return s;
              (!r ||
                (s.type == ge.Text &&
                  (r.type != s.type || (t < 0 ? s.from < e : s.to > e)))) &&
                (r = s);
            }
          }
          return r || i;
        }
        return i;
      }
      function TO(n, e, t, i) {
        let r = io(n, e.head, e.assoc || -1),
          s =
            !i || r.type != ge.Text || !(n.lineWrapping || r.widgetLineBreaks)
              ? null
              : n.coordsAtPos(
                  e.assoc < 0 && e.head > r.from ? e.head - 1 : e.head
                );
        if (s) {
          let o = n.dom.getBoundingClientRect(),
            l = n.textDirectionAt(r.from),
            a = n.posAtCoords({
              x: t == (l == F.LTR) ? o.right - 1 : o.left + 1,
              y: (s.top + s.bottom) / 2,
            });
          if (a != null) return S.cursor(a, t ? -1 : 1);
        }
        return S.cursor(t ? r.to : r.from, t ? -1 : 1);
      }
      function ql(n, e, t, i) {
        let r = n.state.doc.lineAt(e.head),
          s = n.bidiSpans(r),
          o = n.textDirectionAt(r.from);
        for (let l = e, a = null; ; ) {
          let h = dO(r, s, o, l, t),
            c = Pc;
          if (!h) {
            if (r.number == (t ? n.state.doc.lines : 1)) return l;
            (c = `
`),
              (r = n.state.doc.line(r.number + (t ? 1 : -1))),
              (s = n.bidiSpans(r)),
              (h = n.visualLineSide(r, !t));
          }
          if (a) {
            if (!a(c)) return l;
          } else {
            if (!i) return h;
            a = i(c);
          }
          l = h;
        }
      }
      function CO(n, e, t) {
        let i = n.state.charCategorizer(e),
          r = i(t);
        return (s) => {
          let o = i(s);
          return r == H.Space && (r = o), r == o;
        };
      }
      function ZO(n, e, t, i) {
        let r = e.head,
          s = t ? 1 : -1;
        if (r == (t ? n.state.doc.length : 0)) return S.cursor(r, e.assoc);
        let o = e.goalColumn,
          l,
          a = n.contentDOM.getBoundingClientRect(),
          h = n.coordsAtPos(r, e.assoc || -1),
          c = n.documentTop;
        if (h)
          o == null && (o = h.left - a.left), (l = s < 0 ? h.top : h.bottom);
        else {
          let d = n.viewState.lineBlockAt(r);
          o == null &&
            (o = Math.min(
              a.right - a.left,
              n.defaultCharacterWidth * (r - d.from)
            )),
            (l = (s < 0 ? d.top : d.bottom) + c);
        }
        let f = a.left + o,
          u = i ?? n.viewState.heightOracle.textHeight >> 1;
        for (let d = 0; ; d += 10) {
          let O = l + (u + d) * s,
            m = Wc(n, { x: f, y: O }, !1, s);
          if (O < a.top || O > a.bottom || (s < 0 ? m < r : m > r)) {
            let g = n.docView.coordsForChar(m),
              Q = !g || O < g.top ? -1 : 1;
            return S.cursor(m, Q, void 0, o);
          }
        }
      }
      function Wn(n, e, t) {
        for (;;) {
          let i = 0;
          for (let r of n)
            r.between(e - 1, e + 1, (s, o, l) => {
              if (e > s && e < o) {
                let a = i || t || (e - s < o - e ? -1 : 1);
                (e = a < 0 ? s : o), (i = a);
              }
            });
          if (!i) return e;
        }
      }
      function Lc(n, e) {
        let t = null;
        for (let i = 0; i < e.ranges.length; i++) {
          let r = e.ranges[i],
            s = null;
          if (r.empty) {
            let o = Wn(n, r.from, 0);
            o != r.from && (s = S.cursor(o, -1));
          } else {
            let o = Wn(n, r.from, -1),
              l = Wn(n, r.to, 1);
            (o != r.from || l != r.to) &&
              (s = S.range(
                r.from == r.anchor ? o : l,
                r.from == r.head ? o : l
              ));
          }
          s && (t || (t = e.ranges.slice()), (t[i] = s));
        }
        return t ? S.create(t, e.mainIndex) : e;
      }
      function Jr(n, e, t) {
        let i = Wn(
          n.state.facet(Xr).map((r) => r(n)),
          t.from,
          e.head > t.from ? -1 : 1
        );
        return i == t.from ? t : S.cursor(i, i < t.from ? 1 : -1);
      }
      const Zi = "";
      class AO {
        constructor(e, t) {
          (this.points = e),
            (this.text = ""),
            (this.lineSeparator = t.facet(_.lineSeparator));
        }
        append(e) {
          this.text += e;
        }
        lineBreak() {
          this.text += Zi;
        }
        readRange(e, t) {
          if (!e) return this;
          let i = e.parentNode;
          for (let r = e; ; ) {
            this.findPointBefore(i, r);
            let s = this.text.length;
            this.readNode(r);
            let o = r.nextSibling;
            if (o == t) break;
            let l = I.get(r),
              a = I.get(o);
            (l && a
              ? l.breakAfter
              : (l ? l.breakAfter : tr(r)) ||
                (tr(o) &&
                  (r.nodeName != "BR" || r.cmIgnore) &&
                  this.text.length > s)) && this.lineBreak(),
              (r = o);
          }
          return this.findPointBefore(i, t), this;
        }
        readTextNode(e) {
          let t = e.nodeValue;
          for (let i of this.points)
            i.node == e &&
              (i.pos = this.text.length + Math.min(i.offset, t.length));
          for (let i = 0, r = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
            let s = -1,
              o = 1,
              l;
            if (
              (this.lineSeparator
                ? ((s = t.indexOf(this.lineSeparator, i)),
                  (o = this.lineSeparator.length))
                : (l = r.exec(t)) && ((s = l.index), (o = l[0].length)),
              this.append(t.slice(i, s < 0 ? t.length : s)),
              s < 0)
            )
              break;
            if ((this.lineBreak(), o > 1))
              for (let a of this.points)
                a.node == e && a.pos > this.text.length && (a.pos -= o - 1);
            i = s + o;
          }
        }
        readNode(e) {
          if (e.cmIgnore) return;
          let t = I.get(e),
            i = t && t.overrideDOMText;
          if (i != null) {
            this.findPointInside(e, i.length);
            for (let r = i.iter(); !r.next().done; )
              r.lineBreak ? this.lineBreak() : this.append(r.value);
          } else
            e.nodeType == 3
              ? this.readTextNode(e)
              : e.nodeName == "BR"
              ? e.nextSibling && this.lineBreak()
              : e.nodeType == 1 && this.readRange(e.firstChild, null);
        }
        findPointBefore(e, t) {
          for (let i of this.points)
            i.node == e &&
              e.childNodes[i.offset] == t &&
              (i.pos = this.text.length);
        }
        findPointInside(e, t) {
          for (let i of this.points)
            (e.nodeType == 3 ? i.node == e : e.contains(i.node)) &&
              (i.pos = this.text.length + (XO(e, i.node, i.offset) ? t : 0));
        }
      }
      function XO(n, e, t) {
        for (;;) {
          if (!e || t < ot(e)) return !1;
          if (e == n) return !0;
          (t = Wt(e) + 1), (e = e.parentNode);
        }
      }
      class Wl {
        constructor(e, t) {
          (this.node = e), (this.offset = t), (this.pos = -1);
        }
      }
      class RO {
        constructor(e, t, i, r) {
          (this.typeOver = r),
            (this.bounds = null),
            (this.text = ""),
            (this.domChanged = t > -1);
          let { impreciseHead: s, impreciseAnchor: o } = e.docView;
          if (e.state.readOnly && t > -1) this.newSel = null;
          else if (
            t > -1 &&
            (this.bounds = e.docView.domBoundsAround(t, i, 0))
          ) {
            let l = s || o ? [] : zO(e),
              a = new AO(l, e.state);
            a.readRange(this.bounds.startDOM, this.bounds.endDOM),
              (this.text = a.text),
              (this.newSel = DO(l, this.bounds.from));
          } else {
            let l = e.observer.selectionRange,
              a =
                (s && s.node == l.focusNode && s.offset == l.focusOffset) ||
                !js(e.contentDOM, l.focusNode)
                  ? e.state.selection.main.head
                  : e.docView.posFromDOM(l.focusNode, l.focusOffset),
              h =
                (o && o.node == l.anchorNode && o.offset == l.anchorOffset) ||
                !js(e.contentDOM, l.anchorNode)
                  ? e.state.selection.main.anchor
                  : e.docView.posFromDOM(l.anchorNode, l.anchorOffset),
              c = e.viewport;
            if (
              (T.ios || T.chrome) &&
              e.state.selection.main.empty &&
              a != h &&
              (c.from > 0 || c.to < e.state.doc.length)
            ) {
              let f = Math.min(a, h),
                u = Math.max(a, h),
                d = c.from - f,
                O = c.to - u;
              (d == 0 || d == 1 || f == 0) &&
                (O == 0 || O == -1 || u == e.state.doc.length) &&
                ((a = 0), (h = e.state.doc.length));
            }
            this.newSel = S.single(h, a);
          }
        }
      }
      function jc(n, e) {
        let t,
          { newSel: i } = e,
          r = n.state.selection.main,
          s =
            n.inputState.lastKeyTime > Date.now() - 100
              ? n.inputState.lastKeyCode
              : -1;
        if (e.bounds) {
          let { from: o, to: l } = e.bounds,
            a = r.from,
            h = null;
          (s === 8 || (T.android && e.text.length < l - o)) &&
            ((a = r.to), (h = "end"));
          let c = YO(n.state.doc.sliceString(o, l, Zi), e.text, a - o, h);
          c &&
            (T.chrome &&
              s == 13 &&
              c.toB == c.from + 2 &&
              e.text.slice(c.from, c.toB) == Zi + Zi &&
              c.toB--,
            (t = {
              from: o + c.from,
              to: o + c.toA,
              insert: E.of(e.text.slice(c.from, c.toB).split(Zi)),
            }));
        } else
          i &&
            ((!n.hasFocus && n.state.facet(ut)) || i.main.eq(r)) &&
            (i = null);
        if (!t && !i) return !1;
        if (
          (!t && e.typeOver && !r.empty && i && i.main.empty
            ? (t = {
                from: r.from,
                to: r.to,
                insert: n.state.doc.slice(r.from, r.to),
              })
            : (T.mac || T.android) &&
              t &&
              t.from == t.to &&
              t.from == r.head - 1 &&
              /^\. ?$/.test(t.insert.toString()) &&
              n.contentDOM.getAttribute("autocorrect") == "off"
            ? (i &&
                t.insert.length == 2 &&
                (i = S.single(i.main.anchor - 1, i.main.head - 1)),
              (t = {
                from: t.from,
                to: t.to,
                insert: E.of([t.insert.toString().replace(".", " ")]),
              }))
            : t &&
              t.from >= r.from &&
              t.to <= r.to &&
              (t.from != r.from || t.to != r.to) &&
              r.to - r.from - (t.to - t.from) <= 4
            ? (t = {
                from: r.from,
                to: r.to,
                insert: n.state.doc
                  .slice(r.from, t.from)
                  .append(t.insert)
                  .append(n.state.doc.slice(t.to, r.to)),
              })
            : T.chrome &&
              t &&
              t.from == t.to &&
              t.from == r.head &&
              t.insert.toString() ==
                `
 ` &&
              n.lineWrapping &&
              (i && (i = S.single(i.main.anchor - 1, i.main.head - 1)),
              (t = { from: r.from, to: r.to, insert: E.of([" "]) })),
          t)
        )
          return _o(n, t, i, s);
        if (i && !i.main.eq(r)) {
          let o = !1,
            l = "select";
          return (
            n.inputState.lastSelectionTime > Date.now() - 50 &&
              (n.inputState.lastSelectionOrigin == "select" && (o = !0),
              (l = n.inputState.lastSelectionOrigin),
              l == "select.pointer" &&
                (i = Lc(
                  n.state.facet(Xr).map((a) => a(n)),
                  i
                ))),
            n.dispatch({ selection: i, scrollIntoView: o, userEvent: l }),
            !0
          );
        } else return !1;
      }
      function _o(n, e, t, i = -1) {
        if (T.ios && n.inputState.flushIOSKey(e)) return !0;
        let r = n.state.selection.main;
        if (
          T.android &&
          ((e.to == r.to &&
            (e.from == r.from ||
              (e.from == r.from - 1 &&
                n.state.sliceDoc(e.from, r.from) == " ")) &&
            e.insert.length == 1 &&
            e.insert.lines == 2 &&
            ti(n.contentDOM, "Enter", 13)) ||
            (((e.from == r.from - 1 && e.to == r.to && e.insert.length == 0) ||
              (i == 8 && e.insert.length < e.to - e.from && e.to > r.head)) &&
              ti(n.contentDOM, "Backspace", 8)) ||
            (e.from == r.from &&
              e.to == r.to + 1 &&
              e.insert.length == 0 &&
              ti(n.contentDOM, "Delete", 46)))
        )
          return !0;
        let s = e.insert.toString();
        n.inputState.composing >= 0 && n.inputState.composing++;
        let o,
          l = () => o || (o = MO(n, e, t));
        return (
          n.state.facet(Ac).some((a) => a(n, e.from, e.to, s, l)) ||
            n.dispatch(l()),
          !0
        );
      }
      function MO(n, e, t) {
        let i,
          r = n.state,
          s = r.selection.main;
        if (
          e.from >= s.from &&
          e.to <= s.to &&
          e.to - e.from >= (s.to - s.from) / 3 &&
          (!t || (t.main.empty && t.main.from == e.from + e.insert.length)) &&
          n.inputState.composing < 0
        ) {
          let l = s.from < e.from ? r.sliceDoc(s.from, e.from) : "",
            a = s.to > e.to ? r.sliceDoc(e.to, s.to) : "";
          i = r.replaceSelection(
            n.state.toText(
              l + e.insert.sliceString(0, void 0, n.state.lineBreak) + a
            )
          );
        } else {
          let l = r.changes(e),
            a = t && t.main.to <= l.newLength ? t.main : void 0;
          if (
            r.selection.ranges.length > 1 &&
            n.inputState.composing >= 0 &&
            e.to <= s.to &&
            e.to >= s.to - 10
          ) {
            let h = n.state.sliceDoc(e.from, e.to),
              c,
              f = t && qc(n, t.main.head);
            if (f) {
              let O = e.insert.length - (e.to - e.from);
              c = { from: f.from, to: f.to - O };
            } else c = n.state.doc.lineAt(s.head);
            let u = s.to - e.to,
              d = s.to - s.from;
            i = r.changeByRange((O) => {
              if (O.from == s.from && O.to == s.to)
                return { changes: l, range: a || O.map(l) };
              let m = O.to - u,
                g = m - h.length;
              if (
                O.to - O.from != d ||
                n.state.sliceDoc(g, m) != h ||
                (O.to >= c.from && O.from <= c.to)
              )
                return { range: O };
              let Q = r.changes({ from: g, to: m, insert: e.insert }),
                y = O.to - s.to;
              return {
                changes: Q,
                range: a
                  ? S.range(Math.max(0, a.anchor + y), Math.max(0, a.head + y))
                  : O.map(Q),
              };
            });
          } else
            i = { changes: l, selection: a && r.selection.replaceRange(a) };
        }
        let o = "input.type";
        return (
          (n.composing ||
            (n.inputState.compositionPendingChange &&
              n.inputState.compositionEndedAt > Date.now() - 50)) &&
            ((n.inputState.compositionPendingChange = !1),
            (o += ".compose"),
            n.inputState.compositionFirstChange &&
              ((o += ".start"), (n.inputState.compositionFirstChange = !1))),
          r.update(i, { userEvent: o, scrollIntoView: !0 })
        );
      }
      function YO(n, e, t, i) {
        let r = Math.min(n.length, e.length),
          s = 0;
        for (; s < r && n.charCodeAt(s) == e.charCodeAt(s); ) s++;
        if (s == r && n.length == e.length) return null;
        let o = n.length,
          l = e.length;
        for (; o > 0 && l > 0 && n.charCodeAt(o - 1) == e.charCodeAt(l - 1); )
          o--, l--;
        if (i == "end") {
          let a = Math.max(0, s - Math.min(o, l));
          t -= o + a - s;
        }
        if (o < s && n.length < e.length) {
          let a = t <= s && t >= o ? s - t : 0;
          (s -= a), (l = s + (l - o)), (o = s);
        } else if (l < s) {
          let a = t <= s && t >= l ? s - t : 0;
          (s -= a), (o = s + (o - l)), (l = s);
        }
        return { from: s, toA: o, toB: l };
      }
      function zO(n) {
        let e = [];
        if (n.root.activeElement != n.contentDOM) return e;
        let {
          anchorNode: t,
          anchorOffset: i,
          focusNode: r,
          focusOffset: s,
        } = n.observer.selectionRange;
        return (
          t &&
            (e.push(new Wl(t, i)), (r != t || s != i) && e.push(new Wl(r, s))),
          e
        );
      }
      function DO(n, e) {
        if (n.length == 0) return null;
        let t = n[0].pos,
          i = n.length == 2 ? n[1].pos : t;
        return t > -1 && i > -1 ? S.single(t + e, i + e) : null;
      }
      class EO {
        setSelectionOrigin(e) {
          (this.lastSelectionOrigin = e), (this.lastSelectionTime = Date.now());
        }
        constructor(e) {
          (this.view = e),
            (this.lastKeyCode = 0),
            (this.lastKeyTime = 0),
            (this.lastTouchTime = 0),
            (this.lastFocusTime = 0),
            (this.lastScrollTop = 0),
            (this.lastScrollLeft = 0),
            (this.pendingIOSKey = void 0),
            (this.tabFocusMode = -1),
            (this.lastSelectionOrigin = null),
            (this.lastSelectionTime = 0),
            (this.lastContextMenu = 0),
            (this.scrollHandlers = []),
            (this.handlers = Object.create(null)),
            (this.composing = -1),
            (this.compositionFirstChange = null),
            (this.compositionEndedAt = 0),
            (this.compositionPendingKey = !1),
            (this.compositionPendingChange = !1),
            (this.mouseSelection = null),
            (this.draggedContent = null),
            (this.handleEvent = this.handleEvent.bind(this)),
            (this.notifiedFocused = e.hasFocus),
            T.safari && e.contentDOM.addEventListener("input", () => null),
            T.gecko && ep(e.contentDOM.ownerDocument);
        }
        handleEvent(e) {
          !IO(this.view, e) ||
            this.ignoreDuringComposition(e) ||
            (e.type == "keydown" && this.keydown(e)) ||
            (this.view.updateState != 0
              ? Promise.resolve().then(() => this.runHandlers(e.type, e))
              : this.runHandlers(e.type, e));
        }
        runHandlers(e, t) {
          let i = this.handlers[e];
          if (i) {
            for (let r of i.observers) r(this.view, t);
            for (let r of i.handlers) {
              if (t.defaultPrevented) break;
              if (r(this.view, t)) {
                t.preventDefault();
                break;
              }
            }
          }
        }
        ensureHandlers(e) {
          let t = _O(e),
            i = this.handlers,
            r = this.view.contentDOM;
          for (let s in t)
            if (s != "scroll") {
              let o = !t[s].handlers.length,
                l = i[s];
              l &&
                o != !l.handlers.length &&
                (r.removeEventListener(s, this.handleEvent), (l = null)),
                l || r.addEventListener(s, this.handleEvent, { passive: o });
            }
          for (let s in i)
            s != "scroll" &&
              !t[s] &&
              r.removeEventListener(s, this.handleEvent);
          this.handlers = t;
        }
        keydown(e) {
          if (
            ((this.lastKeyCode = e.keyCode),
            (this.lastKeyTime = Date.now()),
            e.keyCode == 9 &&
              this.tabFocusMode > -1 &&
              (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
          )
            return !0;
          if (
            (this.tabFocusMode > 0 &&
              e.keyCode != 27 &&
              Ic.indexOf(e.keyCode) < 0 &&
              (this.tabFocusMode = -1),
            T.android &&
              T.chrome &&
              !e.synthetic &&
              (e.keyCode == 13 || e.keyCode == 8))
          )
            return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
          let t;
          return T.ios &&
            !e.synthetic &&
            !e.altKey &&
            !e.metaKey &&
            (((t = Bc.find((i) => i.keyCode == e.keyCode)) && !e.ctrlKey) ||
              (VO.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey))
            ? ((this.pendingIOSKey = t || e),
              setTimeout(() => this.flushIOSKey(), 250),
              !0)
            : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
        }
        flushIOSKey(e) {
          let t = this.pendingIOSKey;
          return !t ||
            (t.key == "Enter" &&
              e &&
              e.from < e.to &&
              /^\S+$/.test(e.insert.toString()))
            ? !1
            : ((this.pendingIOSKey = void 0),
              ti(
                this.view.contentDOM,
                t.key,
                t.keyCode,
                t instanceof KeyboardEvent ? t : void 0
              ));
        }
        ignoreDuringComposition(e) {
          return /^key/.test(e.type)
            ? this.composing > 0
              ? !0
              : T.safari &&
                !T.ios &&
                this.compositionPendingKey &&
                Date.now() - this.compositionEndedAt < 100
              ? ((this.compositionPendingKey = !1), !0)
              : !1
            : !1;
        }
        startMouseSelection(e) {
          this.mouseSelection && this.mouseSelection.destroy(),
            (this.mouseSelection = e);
        }
        update(e) {
          this.view.observer.update(e),
            this.mouseSelection && this.mouseSelection.update(e),
            this.draggedContent &&
              e.docChanged &&
              (this.draggedContent = this.draggedContent.map(e.changes)),
            e.transactions.length &&
              (this.lastKeyCode = this.lastSelectionTime = 0);
        }
        destroy() {
          this.mouseSelection && this.mouseSelection.destroy();
        }
      }
      function Ll(n, e) {
        return (t, i) => {
          try {
            return e.call(n, i, t);
          } catch (r) {
            ke(t.state, r);
          }
        };
      }
      function _O(n) {
        let e = Object.create(null);
        function t(i) {
          return e[i] || (e[i] = { observers: [], handlers: [] });
        }
        for (let i of n) {
          let r = i.spec,
            s = r && r.plugin.domEventHandlers,
            o = r && r.plugin.domEventObservers;
          if (s)
            for (let l in s) {
              let a = s[l];
              a && t(l).handlers.push(Ll(i.value, a));
            }
          if (o)
            for (let l in o) {
              let a = o[l];
              a && t(l).observers.push(Ll(i.value, a));
            }
        }
        for (let i in je) t(i).handlers.push(je[i]);
        for (let i in Ve) t(i).observers.push(Ve[i]);
        return e;
      }
      const Bc = [
          { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
          { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
          { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
          { key: "Delete", keyCode: 46, inputType: "deleteContentForward" },
        ],
        VO = "dthko",
        Ic = [16, 17, 18, 20, 91, 92, 224, 225],
        yn = 6;
      function bn(n) {
        return Math.max(0, n) * 0.7 + 8;
      }
      function qO(n, e) {
        return Math.max(
          Math.abs(n.clientX - e.clientX),
          Math.abs(n.clientY - e.clientY)
        );
      }
      class WO {
        constructor(e, t, i, r) {
          (this.view = e),
            (this.startEvent = t),
            (this.style = i),
            (this.mustSelect = r),
            (this.scrollSpeed = { x: 0, y: 0 }),
            (this.scrolling = -1),
            (this.lastEvent = t),
            (this.scrollParents = Ud(e.contentDOM)),
            (this.atoms = e.state.facet(Xr).map((o) => o(e)));
          let s = e.contentDOM.ownerDocument;
          s.addEventListener("mousemove", (this.move = this.move.bind(this))),
            s.addEventListener("mouseup", (this.up = this.up.bind(this))),
            (this.extend = t.shiftKey),
            (this.multiple =
              e.state.facet(_.allowMultipleSelections) && LO(e, t)),
            (this.dragging = BO(e, t) && Uc(t) == 1 ? null : !1);
        }
        start(e) {
          this.dragging === !1 && this.select(e);
        }
        move(e) {
          if (e.buttons == 0) return this.destroy();
          if (
            this.dragging ||
            (this.dragging == null && qO(this.startEvent, e) < 10)
          )
            return;
          this.select((this.lastEvent = e));
          let t = 0,
            i = 0,
            r = 0,
            s = 0,
            o = this.view.win.innerWidth,
            l = this.view.win.innerHeight;
          this.scrollParents.x &&
            ({ left: r, right: o } =
              this.scrollParents.x.getBoundingClientRect()),
            this.scrollParents.y &&
              ({ top: s, bottom: l } =
                this.scrollParents.y.getBoundingClientRect());
          let a = Eo(this.view);
          e.clientX - a.left <= r + yn
            ? (t = -bn(r - e.clientX))
            : e.clientX + a.right >= o - yn && (t = bn(e.clientX - o)),
            e.clientY - a.top <= s + yn
              ? (i = -bn(s - e.clientY))
              : e.clientY + a.bottom >= l - yn && (i = bn(e.clientY - l)),
            this.setScrollSpeed(t, i);
        }
        up(e) {
          this.dragging == null && this.select(this.lastEvent),
            this.dragging || e.preventDefault(),
            this.destroy();
        }
        destroy() {
          this.setScrollSpeed(0, 0);
          let e = this.view.contentDOM.ownerDocument;
          e.removeEventListener("mousemove", this.move),
            e.removeEventListener("mouseup", this.up),
            (this.view.inputState.mouseSelection =
              this.view.inputState.draggedContent =
                null);
        }
        setScrollSpeed(e, t) {
          (this.scrollSpeed = { x: e, y: t }),
            e || t
              ? this.scrolling < 0 &&
                (this.scrolling = setInterval(() => this.scroll(), 50))
              : this.scrolling > -1 &&
                (clearInterval(this.scrolling), (this.scrolling = -1));
        }
        scroll() {
          let { x: e, y: t } = this.scrollSpeed;
          e &&
            this.scrollParents.x &&
            ((this.scrollParents.x.scrollLeft += e), (e = 0)),
            t &&
              this.scrollParents.y &&
              ((this.scrollParents.y.scrollTop += t), (t = 0)),
            (e || t) && this.view.win.scrollBy(e, t),
            this.dragging === !1 && this.select(this.lastEvent);
        }
        select(e) {
          let { view: t } = this,
            i = Lc(this.atoms, this.style.get(e, this.extend, this.multiple));
          (this.mustSelect || !i.eq(t.state.selection, this.dragging === !1)) &&
            this.view.dispatch({ selection: i, userEvent: "select.pointer" }),
            (this.mustSelect = !1);
        }
        update(e) {
          e.transactions.some((t) => t.isUserEvent("input.type"))
            ? this.destroy()
            : this.style.update(e) &&
              setTimeout(() => this.select(this.lastEvent), 20);
        }
      }
      function LO(n, e) {
        let t = n.state.facet(vc);
        return t.length ? t[0](e) : T.mac ? e.metaKey : e.ctrlKey;
      }
      function jO(n, e) {
        let t = n.state.facet(Tc);
        return t.length ? t[0](e) : T.mac ? !e.altKey : !e.ctrlKey;
      }
      function BO(n, e) {
        let { main: t } = n.state.selection;
        if (t.empty) return !1;
        let i = Li(n.root);
        if (!i || i.rangeCount == 0) return !0;
        let r = i.getRangeAt(0).getClientRects();
        for (let s = 0; s < r.length; s++) {
          let o = r[s];
          if (
            o.left <= e.clientX &&
            o.right >= e.clientX &&
            o.top <= e.clientY &&
            o.bottom >= e.clientY
          )
            return !0;
        }
        return !1;
      }
      function IO(n, e) {
        if (!e.bubbles) return !0;
        if (e.defaultPrevented) return !1;
        for (let t = e.target, i; t != n.contentDOM; t = t.parentNode)
          if (!t || t.nodeType == 11 || ((i = I.get(t)) && i.ignoreEvent(e)))
            return !1;
        return !0;
      }
      const je = Object.create(null),
        Ve = Object.create(null),
        Gc = (T.ie && T.ie_version < 15) || (T.ios && T.webkit_version < 604);
      function GO(n) {
        let e = n.dom.parentNode;
        if (!e) return;
        let t = e.appendChild(document.createElement("textarea"));
        (t.style.cssText = "position: fixed; left: -10000px; top: 10px"),
          t.focus(),
          setTimeout(() => {
            n.focus(), t.remove(), Nc(n, t.value);
          }, 50);
      }
      function Rr(n, e, t) {
        for (let i of n.facet(e)) t = i(t, n);
        return t;
      }
      function Nc(n, e) {
        e = Rr(n.state, Yo, e);
        let { state: t } = n,
          i,
          r = 1,
          s = t.toText(e),
          o = s.lines == t.selection.ranges.length;
        if (
          no != null &&
          t.selection.ranges.every((a) => a.empty) &&
          no == s.toString()
        ) {
          let a = -1;
          i = t.changeByRange((h) => {
            let c = t.doc.lineAt(h.from);
            if (c.from == a) return { range: h };
            a = c.from;
            let f = t.toText((o ? s.line(r++).text : e) + t.lineBreak);
            return {
              changes: { from: c.from, insert: f },
              range: S.cursor(h.from + f.length),
            };
          });
        } else
          o
            ? (i = t.changeByRange((a) => {
                let h = s.line(r++);
                return {
                  changes: { from: a.from, to: a.to, insert: h.text },
                  range: S.cursor(a.from + h.length),
                };
              }))
            : (i = t.replaceSelection(s));
        n.dispatch(i, { userEvent: "input.paste", scrollIntoView: !0 });
      }
      Ve.scroll = (n) => {
        (n.inputState.lastScrollTop = n.scrollDOM.scrollTop),
          (n.inputState.lastScrollLeft = n.scrollDOM.scrollLeft);
      };
      je.keydown = (n, e) => (
        n.inputState.setSelectionOrigin("select"),
        e.keyCode == 27 &&
          n.inputState.tabFocusMode != 0 &&
          (n.inputState.tabFocusMode = Date.now() + 2e3),
        !1
      );
      Ve.touchstart = (n, e) => {
        (n.inputState.lastTouchTime = Date.now()),
          n.inputState.setSelectionOrigin("select.pointer");
      };
      Ve.touchmove = (n) => {
        n.inputState.setSelectionOrigin("select.pointer");
      };
      je.mousedown = (n, e) => {
        if ((n.observer.flush(), n.inputState.lastTouchTime > Date.now() - 2e3))
          return !1;
        let t = null;
        for (let i of n.state.facet(Cc)) if (((t = i(n, e)), t)) break;
        if ((!t && e.button == 0 && (t = FO(n, e)), t)) {
          let i = !n.hasFocus;
          n.inputState.startMouseSelection(new WO(n, e, t, i)),
            i &&
              n.observer.ignore(() => {
                ac(n.contentDOM);
                let s = n.root.activeElement;
                s && !s.contains(n.contentDOM) && s.blur();
              });
          let r = n.inputState.mouseSelection;
          if (r) return r.start(e), r.dragging === !1;
        } else n.inputState.setSelectionOrigin("select.pointer");
        return !1;
      };
      function jl(n, e, t, i) {
        if (i == 1) return S.cursor(e, t);
        if (i == 2) return wO(n.state, e, t);
        {
          let r = te.find(n.docView, e),
            s = n.state.doc.lineAt(r ? r.posAtEnd : e),
            o = r ? r.posAtStart : s.from,
            l = r ? r.posAtEnd : s.to;
          return l < n.state.doc.length && l == s.to && l++, S.range(o, l);
        }
      }
      let Bl = (n, e, t) =>
        e >= t.top && e <= t.bottom && n >= t.left && n <= t.right;
      function NO(n, e, t, i) {
        let r = te.find(n.docView, e);
        if (!r) return 1;
        let s = e - r.posAtStart;
        if (s == 0) return 1;
        if (s == r.length) return -1;
        let o = r.coordsAt(s, -1);
        if (o && Bl(t, i, o)) return -1;
        let l = r.coordsAt(s, 1);
        return l && Bl(t, i, l) ? 1 : o && o.bottom >= i ? -1 : 1;
      }
      function Il(n, e) {
        let t = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
        return { pos: t, bias: NO(n, t, e.clientX, e.clientY) };
      }
      const UO = T.ie && T.ie_version <= 11;
      let Gl = null,
        Nl = 0,
        Ul = 0;
      function Uc(n) {
        if (!UO) return n.detail;
        let e = Gl,
          t = Ul;
        return (
          (Gl = n),
          (Ul = Date.now()),
          (Nl =
            !e ||
            (t > Date.now() - 400 &&
              Math.abs(e.clientX - n.clientX) < 2 &&
              Math.abs(e.clientY - n.clientY) < 2)
              ? (Nl + 1) % 3
              : 1)
        );
      }
      function FO(n, e) {
        let t = Il(n, e),
          i = Uc(e),
          r = n.state.selection;
        return {
          update(s) {
            s.docChanged &&
              ((t.pos = s.changes.mapPos(t.pos)), (r = r.map(s.changes)));
          },
          get(s, o, l) {
            let a = Il(n, s),
              h,
              c = jl(n, a.pos, a.bias, i);
            if (t.pos != a.pos && !o) {
              let f = jl(n, t.pos, t.bias, i),
                u = Math.min(f.from, c.from),
                d = Math.max(f.to, c.to);
              c = u < c.from ? S.range(u, d) : S.range(d, u);
            }
            return o
              ? r.replaceRange(r.main.extend(c.from, c.to))
              : l && i == 1 && r.ranges.length > 1 && (h = HO(r, a.pos))
              ? h
              : l
              ? r.addRange(c)
              : S.create([c]);
          },
        };
      }
      function HO(n, e) {
        for (let t = 0; t < n.ranges.length; t++) {
          let { from: i, to: r } = n.ranges[t];
          if (i <= e && r >= e)
            return S.create(
              n.ranges.slice(0, t).concat(n.ranges.slice(t + 1)),
              n.mainIndex == t ? 0 : n.mainIndex - (n.mainIndex > t ? 1 : 0)
            );
        }
        return null;
      }
      je.dragstart = (n, e) => {
        let {
          selection: { main: t },
        } = n.state;
        if (e.target.draggable) {
          let r = n.docView.nearest(e.target);
          if (r && r.isWidget) {
            let s = r.posAtStart,
              o = s + r.length;
            (s >= t.to || o <= t.from) && (t = S.range(s, o));
          }
        }
        let { inputState: i } = n;
        return (
          i.mouseSelection && (i.mouseSelection.dragging = !0),
          (i.draggedContent = t),
          e.dataTransfer &&
            (e.dataTransfer.setData(
              "Text",
              Rr(n.state, zo, n.state.sliceDoc(t.from, t.to))
            ),
            (e.dataTransfer.effectAllowed = "copyMove")),
          !1
        );
      };
      je.dragend = (n) => ((n.inputState.draggedContent = null), !1);
      function Fl(n, e, t, i) {
        if (((t = Rr(n.state, Yo, t)), !t)) return;
        let r = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1),
          { draggedContent: s } = n.inputState,
          o = i && s && jO(n, e) ? { from: s.from, to: s.to } : null,
          l = { from: r, insert: t },
          a = n.state.changes(o ? [o, l] : l);
        n.focus(),
          n.dispatch({
            changes: a,
            selection: { anchor: a.mapPos(r, -1), head: a.mapPos(r, 1) },
            userEvent: o ? "move.drop" : "input.drop",
          }),
          (n.inputState.draggedContent = null);
      }
      je.drop = (n, e) => {
        if (!e.dataTransfer) return !1;
        if (n.state.readOnly) return !0;
        let t = e.dataTransfer.files;
        if (t && t.length) {
          let i = Array(t.length),
            r = 0,
            s = () => {
              ++r == t.length &&
                Fl(
                  n,
                  e,
                  i.filter((o) => o != null).join(n.state.lineBreak),
                  !1
                );
            };
          for (let o = 0; o < t.length; o++) {
            let l = new FileReader();
            (l.onerror = s),
              (l.onload = () => {
                /[\x00-\x08\x0e-\x1f]{2}/.test(l.result) || (i[o] = l.result),
                  s();
              }),
              l.readAsText(t[o]);
          }
          return !0;
        } else {
          let i = e.dataTransfer.getData("Text");
          if (i) return Fl(n, e, i, !0), !0;
        }
        return !1;
      };
      je.paste = (n, e) => {
        if (n.state.readOnly) return !0;
        n.observer.flush();
        let t = Gc ? null : e.clipboardData;
        return t
          ? (Nc(n, t.getData("text/plain") || t.getData("text/uri-list")), !0)
          : (GO(n), !1);
      };
      function KO(n, e) {
        let t = n.dom.parentNode;
        if (!t) return;
        let i = t.appendChild(document.createElement("textarea"));
        (i.style.cssText = "position: fixed; left: -10000px; top: 10px"),
          (i.value = e),
          i.focus(),
          (i.selectionEnd = e.length),
          (i.selectionStart = 0),
          setTimeout(() => {
            i.remove(), n.focus();
          }, 50);
      }
      function JO(n) {
        let e = [],
          t = [],
          i = !1;
        for (let r of n.selection.ranges)
          r.empty || (e.push(n.sliceDoc(r.from, r.to)), t.push(r));
        if (!e.length) {
          let r = -1;
          for (let { from: s } of n.selection.ranges) {
            let o = n.doc.lineAt(s);
            o.number > r &&
              (e.push(o.text),
              t.push({ from: o.from, to: Math.min(n.doc.length, o.to + 1) })),
              (r = o.number);
          }
          i = !0;
        }
        return { text: Rr(n, zo, e.join(n.lineBreak)), ranges: t, linewise: i };
      }
      let no = null;
      je.copy = je.cut = (n, e) => {
        let { text: t, ranges: i, linewise: r } = JO(n.state);
        if (!t && !r) return !1;
        (no = r ? t : null),
          e.type == "cut" &&
            !n.state.readOnly &&
            n.dispatch({
              changes: i,
              scrollIntoView: !0,
              userEvent: "delete.cut",
            });
        let s = Gc ? null : e.clipboardData;
        return s
          ? (s.clearData(), s.setData("text/plain", t), !0)
          : (KO(n, t), !1);
      };
      const Fc = Qt.define();
      function Hc(n, e) {
        let t = [];
        for (let i of n.facet(Xc)) {
          let r = i(n, e);
          r && t.push(r);
        }
        return t.length
          ? n.update({ effects: t, annotations: Fc.of(!0) })
          : null;
      }
      function Kc(n) {
        setTimeout(() => {
          let e = n.hasFocus;
          if (e != n.inputState.notifiedFocused) {
            let t = Hc(n.state, e);
            t ? n.dispatch(t) : n.update([]);
          }
        }, 10);
      }
      Ve.focus = (n) => {
        (n.inputState.lastFocusTime = Date.now()),
          !n.scrollDOM.scrollTop &&
            (n.inputState.lastScrollTop || n.inputState.lastScrollLeft) &&
            ((n.scrollDOM.scrollTop = n.inputState.lastScrollTop),
            (n.scrollDOM.scrollLeft = n.inputState.lastScrollLeft)),
          Kc(n);
      };
      Ve.blur = (n) => {
        n.observer.clearSelectionRange(), Kc(n);
      };
      Ve.compositionstart = Ve.compositionupdate = (n) => {
        n.observer.editContext ||
          (n.inputState.compositionFirstChange == null &&
            (n.inputState.compositionFirstChange = !0),
          n.inputState.composing < 0 && (n.inputState.composing = 0));
      };
      Ve.compositionend = (n) => {
        n.observer.editContext ||
          ((n.inputState.composing = -1),
          (n.inputState.compositionEndedAt = Date.now()),
          (n.inputState.compositionPendingKey = !0),
          (n.inputState.compositionPendingChange =
            n.observer.pendingRecords().length > 0),
          (n.inputState.compositionFirstChange = null),
          T.chrome && T.android
            ? n.observer.flushSoon()
            : n.inputState.compositionPendingChange
            ? Promise.resolve().then(() => n.observer.flush())
            : setTimeout(() => {
                n.inputState.composing < 0 &&
                  n.docView.hasComposition &&
                  n.update([]);
              }, 50));
      };
      Ve.contextmenu = (n) => {
        n.inputState.lastContextMenu = Date.now();
      };
      je.beforeinput = (n, e) => {
        var t, i;
        if (e.inputType == "insertReplacementText" && n.observer.editContext) {
          let s =
              (t = e.dataTransfer) === null || t === void 0
                ? void 0
                : t.getData("text/plain"),
            o = e.getTargetRanges();
          if (s && o.length) {
            let l = o[0],
              a = n.posAtDOM(l.startContainer, l.startOffset),
              h = n.posAtDOM(l.endContainer, l.endOffset);
            return (
              _o(n, { from: a, to: h, insert: n.state.toText(s) }, null), !0
            );
          }
        }
        let r;
        if (
          T.chrome &&
          T.android &&
          (r = Bc.find((s) => s.inputType == e.inputType)) &&
          (n.observer.delayAndroidKey(r.key, r.keyCode),
          r.key == "Backspace" || r.key == "Delete")
        ) {
          let s =
            ((i = window.visualViewport) === null || i === void 0
              ? void 0
              : i.height) || 0;
          setTimeout(() => {
            var o;
            (((o = window.visualViewport) === null || o === void 0
              ? void 0
              : o.height) || 0) >
              s + 10 &&
              n.hasFocus &&
              (n.contentDOM.blur(), n.focus());
          }, 100);
        }
        return (
          T.ios &&
            e.inputType == "deleteContentForward" &&
            n.observer.flushSoon(),
          T.safari &&
            e.inputType == "insertText" &&
            n.inputState.composing >= 0 &&
            setTimeout(() => Ve.compositionend(n, e), 20),
          !1
        );
      };
      const Hl = new Set();
      function ep(n) {
        Hl.has(n) ||
          (Hl.add(n),
          n.addEventListener("copy", () => {}),
          n.addEventListener("cut", () => {}));
      }
      const Kl = ["pre-wrap", "normal", "pre-line", "break-spaces"];
      let hi = !1;
      function Jl() {
        hi = !1;
      }
      class tp {
        constructor(e) {
          (this.lineWrapping = e),
            (this.doc = E.empty),
            (this.heightSamples = {}),
            (this.lineHeight = 14),
            (this.charWidth = 7),
            (this.textHeight = 14),
            (this.lineLength = 30);
        }
        heightForGap(e, t) {
          let i = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
          return (
            this.lineWrapping &&
              (i += Math.max(
                0,
                Math.ceil((t - e - i * this.lineLength * 0.5) / this.lineLength)
              )),
            this.lineHeight * i
          );
        }
        heightForLine(e) {
          return this.lineWrapping
            ? (1 +
                Math.max(
                  0,
                  Math.ceil(
                    (e - this.lineLength) / Math.max(1, this.lineLength - 5)
                  )
                )) *
                this.lineHeight
            : this.lineHeight;
        }
        setDoc(e) {
          return (this.doc = e), this;
        }
        mustRefreshForWrapping(e) {
          return Kl.indexOf(e) > -1 != this.lineWrapping;
        }
        mustRefreshForHeights(e) {
          let t = !1;
          for (let i = 0; i < e.length; i++) {
            let r = e[i];
            r < 0
              ? i++
              : this.heightSamples[Math.floor(r * 10)] ||
                ((t = !0), (this.heightSamples[Math.floor(r * 10)] = !0));
          }
          return t;
        }
        refresh(e, t, i, r, s, o) {
          let l = Kl.indexOf(e) > -1,
            a =
              Math.round(t) != Math.round(this.lineHeight) ||
              this.lineWrapping != l;
          if (
            ((this.lineWrapping = l),
            (this.lineHeight = t),
            (this.charWidth = i),
            (this.textHeight = r),
            (this.lineLength = s),
            a)
          ) {
            this.heightSamples = {};
            for (let h = 0; h < o.length; h++) {
              let c = o[h];
              c < 0 ? h++ : (this.heightSamples[Math.floor(c * 10)] = !0);
            }
          }
          return a;
        }
      }
      class ip {
        constructor(e, t) {
          (this.from = e), (this.heights = t), (this.index = 0);
        }
        get more() {
          return this.index < this.heights.length;
        }
      }
      class et {
        constructor(e, t, i, r, s) {
          (this.from = e),
            (this.length = t),
            (this.top = i),
            (this.height = r),
            (this._content = s);
        }
        get type() {
          return typeof this._content == "number"
            ? ge.Text
            : Array.isArray(this._content)
            ? this._content
            : this._content.type;
        }
        get to() {
          return this.from + this.length;
        }
        get bottom() {
          return this.top + this.height;
        }
        get widget() {
          return this._content instanceof Ct ? this._content.widget : null;
        }
        get widgetLineBreaks() {
          return typeof this._content == "number" ? this._content : 0;
        }
        join(e) {
          let t = (
            Array.isArray(this._content) ? this._content : [this]
          ).concat(Array.isArray(e._content) ? e._content : [e]);
          return new et(
            this.from,
            this.length + e.length,
            this.top,
            this.height + e.height,
            t
          );
        }
      }
      var U = (function (n) {
        return (
          (n[(n.ByPos = 0)] = "ByPos"),
          (n[(n.ByHeight = 1)] = "ByHeight"),
          (n[(n.ByPosNoHeight = 2)] = "ByPosNoHeight"),
          n
        );
      })(U || (U = {}));
      const Ln = 0.001;
      class Qe {
        constructor(e, t, i = 2) {
          (this.length = e), (this.height = t), (this.flags = i);
        }
        get outdated() {
          return (this.flags & 2) > 0;
        }
        set outdated(e) {
          this.flags = (e ? 2 : 0) | (this.flags & -3);
        }
        setHeight(e) {
          this.height != e &&
            (Math.abs(this.height - e) > Ln && (hi = !0), (this.height = e));
        }
        replace(e, t, i) {
          return Qe.of(i);
        }
        decomposeLeft(e, t) {
          t.push(this);
        }
        decomposeRight(e, t) {
          t.push(this);
        }
        applyChanges(e, t, i, r) {
          let s = this,
            o = i.doc;
          for (let l = r.length - 1; l >= 0; l--) {
            let { fromA: a, toA: h, fromB: c, toB: f } = r[l],
              u = s.lineAt(a, U.ByPosNoHeight, i.setDoc(t), 0, 0),
              d = u.to >= h ? u : s.lineAt(h, U.ByPosNoHeight, i, 0, 0);
            for (f += d.to - h, h = d.to; l > 0 && u.from <= r[l - 1].toA; )
              (a = r[l - 1].fromA),
                (c = r[l - 1].fromB),
                l--,
                a < u.from && (u = s.lineAt(a, U.ByPosNoHeight, i, 0, 0));
            (c += u.from - a), (a = u.from);
            let O = Vo.build(i.setDoc(o), e, c, f);
            s = rr(s, s.replace(a, h, O));
          }
          return s.updateHeight(i, 0);
        }
        static empty() {
          return new Ze(0, 0);
        }
        static of(e) {
          if (e.length == 1) return e[0];
          let t = 0,
            i = e.length,
            r = 0,
            s = 0;
          for (;;)
            if (t == i)
              if (r > s * 2) {
                let l = e[t - 1];
                l.break
                  ? e.splice(--t, 1, l.left, null, l.right)
                  : e.splice(--t, 1, l.left, l.right),
                  (i += 1 + l.break),
                  (r -= l.size);
              } else if (s > r * 2) {
                let l = e[i];
                l.break
                  ? e.splice(i, 1, l.left, null, l.right)
                  : e.splice(i, 1, l.left, l.right),
                  (i += 2 + l.break),
                  (s -= l.size);
              } else break;
            else if (r < s) {
              let l = e[t++];
              l && (r += l.size);
            } else {
              let l = e[--i];
              l && (s += l.size);
            }
          let o = 0;
          return (
            e[t - 1] == null ? ((o = 1), t--) : e[t] == null && ((o = 1), i++),
            new np(Qe.of(e.slice(0, t)), o, Qe.of(e.slice(i)))
          );
        }
      }
      function rr(n, e) {
        return n == e ? n : (n.constructor != e.constructor && (hi = !0), e);
      }
      Qe.prototype.size = 1;
      class Jc extends Qe {
        constructor(e, t, i) {
          super(e, t), (this.deco = i);
        }
        blockAt(e, t, i, r) {
          return new et(r, this.length, i, this.height, this.deco || 0);
        }
        lineAt(e, t, i, r, s) {
          return this.blockAt(0, i, r, s);
        }
        forEachLine(e, t, i, r, s, o) {
          e <= s + this.length && t >= s && o(this.blockAt(0, i, r, s));
        }
        updateHeight(e, t = 0, i = !1, r) {
          return (
            r && r.from <= t && r.more && this.setHeight(r.heights[r.index++]),
            (this.outdated = !1),
            this
          );
        }
        toString() {
          return `block(${this.length})`;
        }
      }
      class Ze extends Jc {
        constructor(e, t) {
          super(e, t, null),
            (this.collapsed = 0),
            (this.widgetHeight = 0),
            (this.breaks = 0);
        }
        blockAt(e, t, i, r) {
          return new et(r, this.length, i, this.height, this.breaks);
        }
        replace(e, t, i) {
          let r = i[0];
          return i.length == 1 &&
            (r instanceof Ze || (r instanceof ae && r.flags & 4)) &&
            Math.abs(this.length - r.length) < 10
            ? (r instanceof ae
                ? (r = new Ze(r.length, this.height))
                : (r.height = this.height),
              this.outdated || (r.outdated = !1),
              r)
            : Qe.of(i);
        }
        updateHeight(e, t = 0, i = !1, r) {
          return (
            r && r.from <= t && r.more
              ? this.setHeight(r.heights[r.index++])
              : (i || this.outdated) &&
                this.setHeight(
                  Math.max(
                    this.widgetHeight,
                    e.heightForLine(this.length - this.collapsed)
                  ) +
                    this.breaks * e.lineHeight
                ),
            (this.outdated = !1),
            this
          );
        }
        toString() {
          return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${
            this.widgetHeight ? ":" + this.widgetHeight : ""
          })`;
        }
      }
      class ae extends Qe {
        constructor(e) {
          super(e, 0);
        }
        heightMetrics(e, t) {
          let i = e.doc.lineAt(t).number,
            r = e.doc.lineAt(t + this.length).number,
            s = r - i + 1,
            o,
            l = 0;
          if (e.lineWrapping) {
            let a = Math.min(this.height, e.lineHeight * s);
            (o = a / s),
              this.length > s + 1 &&
                (l = (this.height - a) / (this.length - s - 1));
          } else o = this.height / s;
          return { firstLine: i, lastLine: r, perLine: o, perChar: l };
        }
        blockAt(e, t, i, r) {
          let {
            firstLine: s,
            lastLine: o,
            perLine: l,
            perChar: a,
          } = this.heightMetrics(t, r);
          if (t.lineWrapping) {
            let h =
                r +
                (e < t.lineHeight
                  ? 0
                  : Math.round(
                      Math.max(0, Math.min(1, (e - i) / this.height)) *
                        this.length
                    )),
              c = t.doc.lineAt(h),
              f = l + c.length * a,
              u = Math.max(i, e - f / 2);
            return new et(c.from, c.length, u, f, 0);
          } else {
            let h = Math.max(0, Math.min(o - s, Math.floor((e - i) / l))),
              { from: c, length: f } = t.doc.line(s + h);
            return new et(c, f, i + l * h, l, 0);
          }
        }
        lineAt(e, t, i, r, s) {
          if (t == U.ByHeight) return this.blockAt(e, i, r, s);
          if (t == U.ByPosNoHeight) {
            let { from: d, to: O } = i.doc.lineAt(e);
            return new et(d, O - d, 0, 0, 0);
          }
          let {
              firstLine: o,
              perLine: l,
              perChar: a,
            } = this.heightMetrics(i, s),
            h = i.doc.lineAt(e),
            c = l + h.length * a,
            f = h.number - o,
            u = r + l * f + a * (h.from - s - f);
          return new et(
            h.from,
            h.length,
            Math.max(r, Math.min(u, r + this.height - c)),
            c,
            0
          );
        }
        forEachLine(e, t, i, r, s, o) {
          (e = Math.max(e, s)), (t = Math.min(t, s + this.length));
          let {
            firstLine: l,
            perLine: a,
            perChar: h,
          } = this.heightMetrics(i, s);
          for (let c = e, f = r; c <= t; ) {
            let u = i.doc.lineAt(c);
            if (c == e) {
              let O = u.number - l;
              f += a * O + h * (e - s - O);
            }
            let d = a + h * u.length;
            o(new et(u.from, u.length, f, d, 0)), (f += d), (c = u.to + 1);
          }
        }
        replace(e, t, i) {
          let r = this.length - t;
          if (r > 0) {
            let s = i[i.length - 1];
            s instanceof ae
              ? (i[i.length - 1] = new ae(s.length + r))
              : i.push(null, new ae(r - 1));
          }
          if (e > 0) {
            let s = i[0];
            s instanceof ae
              ? (i[0] = new ae(e + s.length))
              : i.unshift(new ae(e - 1), null);
          }
          return Qe.of(i);
        }
        decomposeLeft(e, t) {
          t.push(new ae(e - 1), null);
        }
        decomposeRight(e, t) {
          t.push(null, new ae(this.length - e - 1));
        }
        updateHeight(e, t = 0, i = !1, r) {
          let s = t + this.length;
          if (r && r.from <= t + this.length && r.more) {
            let o = [],
              l = Math.max(t, r.from),
              a = -1;
            for (
              r.from > t && o.push(new ae(r.from - t - 1).updateHeight(e, t));
              l <= s && r.more;

            ) {
              let c = e.doc.lineAt(l).length;
              o.length && o.push(null);
              let f = r.heights[r.index++];
              a == -1 ? (a = f) : Math.abs(f - a) >= Ln && (a = -2);
              let u = new Ze(c, f);
              (u.outdated = !1), o.push(u), (l += c + 1);
            }
            l <= s && o.push(null, new ae(s - l).updateHeight(e, l));
            let h = Qe.of(o);
            return (
              (a < 0 ||
                Math.abs(h.height - this.height) >= Ln ||
                Math.abs(a - this.heightMetrics(e, t).perLine) >= Ln) &&
                (hi = !0),
              rr(this, h)
            );
          } else
            (i || this.outdated) &&
              (this.setHeight(e.heightForGap(t, t + this.length)),
              (this.outdated = !1));
          return this;
        }
        toString() {
          return `gap(${this.length})`;
        }
      }
      class np extends Qe {
        constructor(e, t, i) {
          super(
            e.length + t + i.length,
            e.height + i.height,
            t | (e.outdated || i.outdated ? 2 : 0)
          ),
            (this.left = e),
            (this.right = i),
            (this.size = e.size + i.size);
        }
        get break() {
          return this.flags & 1;
        }
        blockAt(e, t, i, r) {
          let s = i + this.left.height;
          return e < s
            ? this.left.blockAt(e, t, i, r)
            : this.right.blockAt(e, t, s, r + this.left.length + this.break);
        }
        lineAt(e, t, i, r, s) {
          let o = r + this.left.height,
            l = s + this.left.length + this.break,
            a = t == U.ByHeight ? e < o : e < l,
            h = a
              ? this.left.lineAt(e, t, i, r, s)
              : this.right.lineAt(e, t, i, o, l);
          if (this.break || (a ? h.to < l : h.from > l)) return h;
          let c = t == U.ByPosNoHeight ? U.ByPosNoHeight : U.ByPos;
          return a
            ? h.join(this.right.lineAt(l, c, i, o, l))
            : this.left.lineAt(l, c, i, r, s).join(h);
        }
        forEachLine(e, t, i, r, s, o) {
          let l = r + this.left.height,
            a = s + this.left.length + this.break;
          if (this.break)
            e < a && this.left.forEachLine(e, t, i, r, s, o),
              t >= a && this.right.forEachLine(e, t, i, l, a, o);
          else {
            let h = this.lineAt(a, U.ByPos, i, r, s);
            e < h.from && this.left.forEachLine(e, h.from - 1, i, r, s, o),
              h.to >= e && h.from <= t && o(h),
              t > h.to && this.right.forEachLine(h.to + 1, t, i, l, a, o);
          }
        }
        replace(e, t, i) {
          let r = this.left.length + this.break;
          if (t < r)
            return this.balanced(this.left.replace(e, t, i), this.right);
          if (e > this.left.length)
            return this.balanced(
              this.left,
              this.right.replace(e - r, t - r, i)
            );
          let s = [];
          e > 0 && this.decomposeLeft(e, s);
          let o = s.length;
          for (let l of i) s.push(l);
          if ((e > 0 && ea(s, o - 1), t < this.length)) {
            let l = s.length;
            this.decomposeRight(t, s), ea(s, l);
          }
          return Qe.of(s);
        }
        decomposeLeft(e, t) {
          let i = this.left.length;
          if (e <= i) return this.left.decomposeLeft(e, t);
          t.push(this.left),
            this.break && (i++, e >= i && t.push(null)),
            e > i && this.right.decomposeLeft(e - i, t);
        }
        decomposeRight(e, t) {
          let i = this.left.length,
            r = i + this.break;
          if (e >= r) return this.right.decomposeRight(e - r, t);
          e < i && this.left.decomposeRight(e, t),
            this.break && e < r && t.push(null),
            t.push(this.right);
        }
        balanced(e, t) {
          return e.size > 2 * t.size || t.size > 2 * e.size
            ? Qe.of(this.break ? [e, null, t] : [e, t])
            : ((this.left = rr(this.left, e)),
              (this.right = rr(this.right, t)),
              this.setHeight(e.height + t.height),
              (this.outdated = e.outdated || t.outdated),
              (this.size = e.size + t.size),
              (this.length = e.length + this.break + t.length),
              this);
        }
        updateHeight(e, t = 0, i = !1, r) {
          let { left: s, right: o } = this,
            l = t + s.length + this.break,
            a = null;
          return (
            r && r.from <= t + s.length && r.more
              ? (a = s = s.updateHeight(e, t, i, r))
              : s.updateHeight(e, t, i),
            r && r.from <= l + o.length && r.more
              ? (a = o = o.updateHeight(e, l, i, r))
              : o.updateHeight(e, l, i),
            a
              ? this.balanced(s, o)
              : ((this.height = this.left.height + this.right.height),
                (this.outdated = !1),
                this)
          );
        }
        toString() {
          return this.left + (this.break ? " " : "-") + this.right;
        }
      }
      function ea(n, e) {
        let t, i;
        n[e] == null &&
          (t = n[e - 1]) instanceof ae &&
          (i = n[e + 1]) instanceof ae &&
          n.splice(e - 1, 3, new ae(t.length + 1 + i.length));
      }
      const rp = 5;
      class Vo {
        constructor(e, t) {
          (this.pos = e),
            (this.oracle = t),
            (this.nodes = []),
            (this.lineStart = -1),
            (this.lineEnd = -1),
            (this.covering = null),
            (this.writtenTo = e);
        }
        get isCovered() {
          return (
            this.covering && this.nodes[this.nodes.length - 1] == this.covering
          );
        }
        span(e, t) {
          if (this.lineStart > -1) {
            let i = Math.min(t, this.lineEnd),
              r = this.nodes[this.nodes.length - 1];
            r instanceof Ze
              ? (r.length += i - this.pos)
              : (i > this.pos || !this.isCovered) &&
                this.nodes.push(new Ze(i - this.pos, -1)),
              (this.writtenTo = i),
              t > i &&
                (this.nodes.push(null),
                this.writtenTo++,
                (this.lineStart = -1));
          }
          this.pos = t;
        }
        point(e, t, i) {
          if (e < t || i.heightRelevant) {
            let r = i.widget ? i.widget.estimatedHeight : 0,
              s = i.widget ? i.widget.lineBreaks : 0;
            r < 0 && (r = this.oracle.lineHeight);
            let o = t - e;
            i.block
              ? this.addBlock(new Jc(o, r, i))
              : (o || s || r >= rp) && this.addLineDeco(r, s, o);
          } else t > e && this.span(e, t);
          this.lineEnd > -1 &&
            this.lineEnd < this.pos &&
            (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
        }
        enterLine() {
          if (this.lineStart > -1) return;
          let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
          (this.lineStart = e),
            (this.lineEnd = t),
            this.writtenTo < e &&
              ((this.writtenTo < e - 1 ||
                this.nodes[this.nodes.length - 1] == null) &&
                this.nodes.push(this.blankContent(this.writtenTo, e - 1)),
              this.nodes.push(null)),
            this.pos > e && this.nodes.push(new Ze(this.pos - e, -1)),
            (this.writtenTo = this.pos);
        }
        blankContent(e, t) {
          let i = new ae(t - e);
          return this.oracle.doc.lineAt(e).to == t && (i.flags |= 4), i;
        }
        ensureLine() {
          this.enterLine();
          let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
          if (e instanceof Ze) return e;
          let t = new Ze(0, -1);
          return this.nodes.push(t), t;
        }
        addBlock(e) {
          this.enterLine();
          let t = e.deco;
          t && t.startSide > 0 && !this.isCovered && this.ensureLine(),
            this.nodes.push(e),
            (this.writtenTo = this.pos = this.pos + e.length),
            t && t.endSide > 0 && (this.covering = e);
        }
        addLineDeco(e, t, i) {
          let r = this.ensureLine();
          (r.length += i),
            (r.collapsed += i),
            (r.widgetHeight = Math.max(r.widgetHeight, e)),
            (r.breaks += t),
            (this.writtenTo = this.pos = this.pos + i);
        }
        finish(e) {
          let t =
            this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
          this.lineStart > -1 && !(t instanceof Ze) && !this.isCovered
            ? this.nodes.push(new Ze(0, -1))
            : (this.writtenTo < this.pos || t == null) &&
              this.nodes.push(this.blankContent(this.writtenTo, this.pos));
          let i = e;
          for (let r of this.nodes)
            r instanceof Ze && r.updateHeight(this.oracle, i),
              (i += r ? r.length : 1);
          return this.nodes;
        }
        static build(e, t, i, r) {
          let s = new Vo(i, e);
          return V.spans(t, i, r, s, 0), s.finish(i);
        }
      }
      function sp(n, e, t) {
        let i = new op();
        return V.compare(n, e, t, i, 0), i.changes;
      }
      class op {
        constructor() {
          this.changes = [];
        }
        compareRange() {}
        comparePoint(e, t, i, r) {
          (e < t || (i && i.heightRelevant) || (r && r.heightRelevant)) &&
            qn(e, t, this.changes, 5);
        }
      }
      function lp(n, e) {
        let t = n.getBoundingClientRect(),
          i = n.ownerDocument,
          r = i.defaultView || window,
          s = Math.max(0, t.left),
          o = Math.min(r.innerWidth, t.right),
          l = Math.max(0, t.top),
          a = Math.min(r.innerHeight, t.bottom);
        for (let h = n.parentNode; h && h != i.body; )
          if (h.nodeType == 1) {
            let c = h,
              f = window.getComputedStyle(c);
            if (
              (c.scrollHeight > c.clientHeight ||
                c.scrollWidth > c.clientWidth) &&
              f.overflow != "visible"
            ) {
              let u = c.getBoundingClientRect();
              (s = Math.max(s, u.left)),
                (o = Math.min(o, u.right)),
                (l = Math.max(l, u.top)),
                (a = Math.min(h == n.parentNode ? r.innerHeight : a, u.bottom));
            }
            h =
              f.position == "absolute" || f.position == "fixed"
                ? c.offsetParent
                : c.parentNode;
          } else if (h.nodeType == 11) h = h.host;
          else break;
        return {
          left: s - t.left,
          right: Math.max(s, o) - t.left,
          top: l - (t.top + e),
          bottom: Math.max(l, a) - (t.top + e),
        };
      }
      function ap(n) {
        let e = n.getBoundingClientRect(),
          t = n.ownerDocument.defaultView || window;
        return (
          e.left < t.innerWidth &&
          e.right > 0 &&
          e.top < t.innerHeight &&
          e.bottom > 0
        );
      }
      function hp(n, e) {
        let t = n.getBoundingClientRect();
        return {
          left: 0,
          right: t.right - t.left,
          top: e,
          bottom: t.bottom - (t.top + e),
        };
      }
      class es {
        constructor(e, t, i, r) {
          (this.from = e),
            (this.to = t),
            (this.size = i),
            (this.displaySize = r);
        }
        static same(e, t) {
          if (e.length != t.length) return !1;
          for (let i = 0; i < e.length; i++) {
            let r = e[i],
              s = t[i];
            if (r.from != s.from || r.to != s.to || r.size != s.size) return !1;
          }
          return !0;
        }
        draw(e, t) {
          return A.replace({
            widget: new cp(this.displaySize * (t ? e.scaleY : e.scaleX), t),
          }).range(this.from, this.to);
        }
      }
      class cp extends St {
        constructor(e, t) {
          super(), (this.size = e), (this.vertical = t);
        }
        eq(e) {
          return e.size == this.size && e.vertical == this.vertical;
        }
        toDOM() {
          let e = document.createElement("div");
          return (
            this.vertical
              ? (e.style.height = this.size + "px")
              : ((e.style.width = this.size + "px"),
                (e.style.height = "2px"),
                (e.style.display = "inline-block")),
            e
          );
        }
        get estimatedHeight() {
          return this.vertical ? this.size : -1;
        }
      }
      class ta {
        constructor(e) {
          (this.state = e),
            (this.pixelViewport = {
              left: 0,
              right: window.innerWidth,
              top: 0,
              bottom: 0,
            }),
            (this.inView = !0),
            (this.paddingTop = 0),
            (this.paddingBottom = 0),
            (this.contentDOMWidth = 0),
            (this.contentDOMHeight = 0),
            (this.editorHeight = 0),
            (this.editorWidth = 0),
            (this.scrollTop = 0),
            (this.scrolledToBottom = !1),
            (this.scaleX = 1),
            (this.scaleY = 1),
            (this.scrollAnchorPos = 0),
            (this.scrollAnchorHeight = -1),
            (this.scaler = ia),
            (this.scrollTarget = null),
            (this.printing = !1),
            (this.mustMeasureContent = !0),
            (this.defaultTextDirection = F.LTR),
            (this.visibleRanges = []),
            (this.mustEnforceCursorAssoc = !1);
          let t = e
            .facet(Do)
            .some(
              (i) => typeof i != "function" && i.class == "cm-lineWrapping"
            );
          (this.heightOracle = new tp(t)),
            (this.stateDeco = e
              .facet(Bi)
              .filter((i) => typeof i != "function")),
            (this.heightMap = Qe.empty().applyChanges(
              this.stateDeco,
              E.empty,
              this.heightOracle.setDoc(e.doc),
              [new _e(0, 0, 0, e.doc.length)]
            ));
          for (
            let i = 0;
            i < 2 &&
            ((this.viewport = this.getViewport(0, null)),
            !!this.updateForViewport());
            i++
          );
          this.updateViewportLines(),
            (this.lineGaps = this.ensureLineGaps([])),
            (this.lineGapDeco = A.set(
              this.lineGaps.map((i) => i.draw(this, !1))
            )),
            this.computeVisibleRanges();
        }
        updateForViewport() {
          let e = [this.viewport],
            { main: t } = this.state.selection;
          for (let i = 0; i <= 1; i++) {
            let r = i ? t.head : t.anchor;
            if (!e.some(({ from: s, to: o }) => r >= s && r <= o)) {
              let { from: s, to: o } = this.lineBlockAt(r);
              e.push(new xn(s, o));
            }
          }
          return (
            (this.viewports = e.sort((i, r) => i.from - r.from)),
            this.updateScaler()
          );
        }
        updateScaler() {
          let e = this.scaler;
          return (
            (this.scaler =
              this.heightMap.height <= 7e6
                ? ia
                : new qo(this.heightOracle, this.heightMap, this.viewports)),
            e.eq(this.scaler) ? 0 : 2
          );
        }
        updateViewportLines() {
          (this.viewportLines = []),
            this.heightMap.forEachLine(
              this.viewport.from,
              this.viewport.to,
              this.heightOracle.setDoc(this.state.doc),
              0,
              0,
              (e) => {
                this.viewportLines.push(Ai(e, this.scaler));
              }
            );
        }
        update(e, t = null) {
          this.state = e.state;
          let i = this.stateDeco;
          this.stateDeco = this.state
            .facet(Bi)
            .filter((c) => typeof c != "function");
          let r = e.changedRanges,
            s = _e.extendWithRanges(
              r,
              sp(
                i,
                this.stateDeco,
                e ? e.changes : re.empty(this.state.doc.length)
              )
            ),
            o = this.heightMap.height,
            l = this.scrolledToBottom
              ? null
              : this.scrollAnchorAt(this.scrollTop);
          Jl(),
            (this.heightMap = this.heightMap.applyChanges(
              this.stateDeco,
              e.startState.doc,
              this.heightOracle.setDoc(this.state.doc),
              s
            )),
            (this.heightMap.height != o || hi) && (e.flags |= 2),
            l
              ? ((this.scrollAnchorPos = e.changes.mapPos(l.from, -1)),
                (this.scrollAnchorHeight = l.top))
              : ((this.scrollAnchorPos = -1), (this.scrollAnchorHeight = o));
          let a = s.length
            ? this.mapViewport(this.viewport, e.changes)
            : this.viewport;
          ((t && (t.range.head < a.from || t.range.head > a.to)) ||
            !this.viewportIsAppropriate(a)) &&
            (a = this.getViewport(0, t));
          let h = a.from != this.viewport.from || a.to != this.viewport.to;
          (this.viewport = a),
            (e.flags |= this.updateForViewport()),
            (h || !e.changes.empty || e.flags & 2) &&
              this.updateViewportLines(),
            (this.lineGaps.length ||
              this.viewport.to - this.viewport.from > 4e3) &&
              this.updateLineGaps(
                this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))
              ),
            (e.flags |= this.computeVisibleRanges(e.changes)),
            t && (this.scrollTarget = t),
            !this.mustEnforceCursorAssoc &&
              e.selectionSet &&
              e.view.lineWrapping &&
              e.state.selection.main.empty &&
              e.state.selection.main.assoc &&
              !e.state.facet(Mc) &&
              (this.mustEnforceCursorAssoc = !0);
        }
        measure(e) {
          let t = e.contentDOM,
            i = window.getComputedStyle(t),
            r = this.heightOracle,
            s = i.whiteSpace;
          this.defaultTextDirection = i.direction == "rtl" ? F.RTL : F.LTR;
          let o = this.heightOracle.mustRefreshForWrapping(s),
            l = t.getBoundingClientRect(),
            a =
              o || this.mustMeasureContent || this.contentDOMHeight != l.height;
          (this.contentDOMHeight = l.height), (this.mustMeasureContent = !1);
          let h = 0,
            c = 0;
          if (l.width && l.height) {
            let { scaleX: k, scaleY: b } = lc(t, l);
            ((k > 0.005 && Math.abs(this.scaleX - k) > 0.005) ||
              (b > 0.005 && Math.abs(this.scaleY - b) > 0.005)) &&
              ((this.scaleX = k), (this.scaleY = b), (h |= 16), (o = a = !0));
          }
          let f = (parseInt(i.paddingTop) || 0) * this.scaleY,
            u = (parseInt(i.paddingBottom) || 0) * this.scaleY;
          (this.paddingTop != f || this.paddingBottom != u) &&
            ((this.paddingTop = f), (this.paddingBottom = u), (h |= 18)),
            this.editorWidth != e.scrollDOM.clientWidth &&
              (r.lineWrapping && (a = !0),
              (this.editorWidth = e.scrollDOM.clientWidth),
              (h |= 16));
          let d = e.scrollDOM.scrollTop * this.scaleY;
          this.scrollTop != d &&
            ((this.scrollAnchorHeight = -1), (this.scrollTop = d)),
            (this.scrolledToBottom = cc(e.scrollDOM));
          let O = (this.printing ? hp : lp)(t, this.paddingTop),
            m = O.top - this.pixelViewport.top,
            g = O.bottom - this.pixelViewport.bottom;
          this.pixelViewport = O;
          let Q =
            this.pixelViewport.bottom > this.pixelViewport.top &&
            this.pixelViewport.right > this.pixelViewport.left;
          if (
            (Q != this.inView && ((this.inView = Q), Q && (a = !0)),
            !this.inView && !this.scrollTarget && !ap(e.dom))
          )
            return 0;
          let y = l.width;
          if (
            ((this.contentDOMWidth != y ||
              this.editorHeight != e.scrollDOM.clientHeight) &&
              ((this.contentDOMWidth = l.width),
              (this.editorHeight = e.scrollDOM.clientHeight),
              (h |= 16)),
            a)
          ) {
            let k = e.docView.measureVisibleLineHeights(this.viewport);
            if (
              (r.mustRefreshForHeights(k) && (o = !0),
              o ||
                (r.lineWrapping &&
                  Math.abs(y - this.contentDOMWidth) > r.charWidth))
            ) {
              let {
                lineHeight: b,
                charWidth: w,
                textHeight: P,
              } = e.docView.measureTextSize();
              (o = b > 0 && r.refresh(s, b, w, P, Math.max(5, y / w), k)),
                o && ((e.docView.minWidth = 0), (h |= 16));
            }
            m > 0 && g > 0
              ? (c = Math.max(m, g))
              : m < 0 && g < 0 && (c = Math.min(m, g)),
              Jl();
            for (let b of this.viewports) {
              let w =
                b.from == this.viewport.from
                  ? k
                  : e.docView.measureVisibleLineHeights(b);
              this.heightMap = (
                o
                  ? Qe.empty().applyChanges(
                      this.stateDeco,
                      E.empty,
                      this.heightOracle,
                      [new _e(0, 0, 0, e.state.doc.length)]
                    )
                  : this.heightMap
              ).updateHeight(r, 0, o, new ip(b.from, w));
            }
            hi && (h |= 2);
          }
          let x =
            !this.viewportIsAppropriate(this.viewport, c) ||
            (this.scrollTarget &&
              (this.scrollTarget.range.head < this.viewport.from ||
                this.scrollTarget.range.head > this.viewport.to));
          return (
            x &&
              (h & 2 && (h |= this.updateScaler()),
              (this.viewport = this.getViewport(c, this.scrollTarget)),
              (h |= this.updateForViewport())),
            (h & 2 || x) && this.updateViewportLines(),
            (this.lineGaps.length ||
              this.viewport.to - this.viewport.from > 4e3) &&
              this.updateLineGaps(
                this.ensureLineGaps(o ? [] : this.lineGaps, e)
              ),
            (h |= this.computeVisibleRanges()),
            this.mustEnforceCursorAssoc &&
              ((this.mustEnforceCursorAssoc = !1),
              e.docView.enforceCursorAssoc()),
            h
          );
        }
        get visibleTop() {
          return this.scaler.fromDOM(this.pixelViewport.top);
        }
        get visibleBottom() {
          return this.scaler.fromDOM(this.pixelViewport.bottom);
        }
        getViewport(e, t) {
          let i = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)),
            r = this.heightMap,
            s = this.heightOracle,
            { visibleTop: o, visibleBottom: l } = this,
            a = new xn(
              r.lineAt(o - i * 1e3, U.ByHeight, s, 0, 0).from,
              r.lineAt(l + (1 - i) * 1e3, U.ByHeight, s, 0, 0).to
            );
          if (t) {
            let { head: h } = t.range;
            if (h < a.from || h > a.to) {
              let c = Math.min(
                  this.editorHeight,
                  this.pixelViewport.bottom - this.pixelViewport.top
                ),
                f = r.lineAt(h, U.ByPos, s, 0, 0),
                u;
              t.y == "center"
                ? (u = (f.top + f.bottom) / 2 - c / 2)
                : t.y == "start" || (t.y == "nearest" && h < a.from)
                ? (u = f.top)
                : (u = f.bottom - c),
                (a = new xn(
                  r.lineAt(u - 1e3 / 2, U.ByHeight, s, 0, 0).from,
                  r.lineAt(u + c + 1e3 / 2, U.ByHeight, s, 0, 0).to
                ));
            }
          }
          return a;
        }
        mapViewport(e, t) {
          let i = t.mapPos(e.from, -1),
            r = t.mapPos(e.to, 1);
          return new xn(
            this.heightMap.lineAt(i, U.ByPos, this.heightOracle, 0, 0).from,
            this.heightMap.lineAt(r, U.ByPos, this.heightOracle, 0, 0).to
          );
        }
        viewportIsAppropriate({ from: e, to: t }, i = 0) {
          if (!this.inView) return !0;
          let { top: r } = this.heightMap.lineAt(
              e,
              U.ByPos,
              this.heightOracle,
              0,
              0
            ),
            { bottom: s } = this.heightMap.lineAt(
              t,
              U.ByPos,
              this.heightOracle,
              0,
              0
            ),
            { visibleTop: o, visibleBottom: l } = this;
          return (
            (e == 0 || r <= o - Math.max(10, Math.min(-i, 250))) &&
            (t == this.state.doc.length ||
              s >= l + Math.max(10, Math.min(i, 250))) &&
            r > o - 2 * 1e3 &&
            s < l + 2 * 1e3
          );
        }
        mapLineGaps(e, t) {
          if (!e.length || t.empty) return e;
          let i = [];
          for (let r of e)
            t.touchesRange(r.from, r.to) ||
              i.push(
                new es(t.mapPos(r.from), t.mapPos(r.to), r.size, r.displaySize)
              );
          return i;
        }
        ensureLineGaps(e, t) {
          let i = this.heightOracle.lineWrapping,
            r = i ? 1e4 : 2e3,
            s = r >> 1,
            o = r << 1;
          if (this.defaultTextDirection != F.LTR && !i) return [];
          let l = [],
            a = (c, f, u, d) => {
              if (f - c < s) return;
              let O = this.state.selection.main,
                m = [O.from];
              O.empty || m.push(O.to);
              for (let Q of m)
                if (Q > c && Q < f) {
                  a(c, Q - 10, u, d), a(Q + 10, f, u, d);
                  return;
                }
              let g = up(
                e,
                (Q) =>
                  Q.from >= u.from &&
                  Q.to <= u.to &&
                  Math.abs(Q.from - c) < s &&
                  Math.abs(Q.to - f) < s &&
                  !m.some((y) => Q.from < y && Q.to > y)
              );
              if (!g) {
                if (
                  f < u.to &&
                  t &&
                  i &&
                  t.visibleRanges.some((x) => x.from <= f && x.to >= f)
                ) {
                  let x = t.moveToLineBoundary(S.cursor(f), !1, !0).head;
                  x > c && (f = x);
                }
                let Q = this.gapSize(u, c, f, d),
                  y = i || Q < 2e6 ? Q : 2e6;
                g = new es(c, f, Q, y);
              }
              l.push(g);
            },
            h = (c) => {
              if (c.length < o || c.type != ge.Text) return;
              let f = fp(c.from, c.to, this.stateDeco);
              if (f.total < o) return;
              let u = this.scrollTarget ? this.scrollTarget.range.head : null,
                d,
                O;
              if (i) {
                let m =
                    (r / this.heightOracle.lineLength) *
                    this.heightOracle.lineHeight,
                  g,
                  Q;
                if (u != null) {
                  let y = kn(f, u),
                    x =
                      ((this.visibleBottom - this.visibleTop) / 2 + m) /
                      c.height;
                  (g = y - x), (Q = y + x);
                } else
                  (g = (this.visibleTop - c.top - m) / c.height),
                    (Q = (this.visibleBottom - c.top + m) / c.height);
                (d = wn(f, g)), (O = wn(f, Q));
              } else {
                let m = f.total * this.heightOracle.charWidth,
                  g = r * this.heightOracle.charWidth,
                  Q = 0;
                if (m > 2e6)
                  for (let w of e)
                    w.from >= c.from &&
                      w.from < c.to &&
                      w.size != w.displaySize &&
                      w.from * this.heightOracle.charWidth + Q <
                        this.pixelViewport.left &&
                      (Q = w.size - w.displaySize);
                let y = this.pixelViewport.left + Q,
                  x = this.pixelViewport.right + Q,
                  k,
                  b;
                if (u != null) {
                  let w = kn(f, u),
                    P = ((x - y) / 2 + g) / m;
                  (k = w - P), (b = w + P);
                } else (k = (y - g) / m), (b = (x + g) / m);
                (d = wn(f, k)), (O = wn(f, b));
              }
              d > c.from && a(c.from, d, c, f), O < c.to && a(O, c.to, c, f);
            };
          for (let c of this.viewportLines)
            Array.isArray(c.type) ? c.type.forEach(h) : h(c);
          return l;
        }
        gapSize(e, t, i, r) {
          let s = kn(r, i) - kn(r, t);
          return this.heightOracle.lineWrapping
            ? e.height * s
            : r.total * this.heightOracle.charWidth * s;
        }
        updateLineGaps(e) {
          es.same(e, this.lineGaps) ||
            ((this.lineGaps = e),
            (this.lineGapDeco = A.set(
              e.map((t) => t.draw(this, this.heightOracle.lineWrapping))
            )));
        }
        computeVisibleRanges(e) {
          let t = this.stateDeco;
          this.lineGaps.length && (t = t.concat(this.lineGapDeco));
          let i = [];
          V.spans(
            t,
            this.viewport.from,
            this.viewport.to,
            {
              span(s, o) {
                i.push({ from: s, to: o });
              },
              point() {},
            },
            20
          );
          let r = 0;
          if (i.length != this.visibleRanges.length) r = 12;
          else
            for (let s = 0; s < i.length && !(r & 8); s++) {
              let o = this.visibleRanges[s],
                l = i[s];
              (o.from != l.from || o.to != l.to) &&
                ((r |= 4),
                (e &&
                  e.mapPos(o.from, -1) == l.from &&
                  e.mapPos(o.to, 1) == l.to) ||
                  (r |= 8));
            }
          return (this.visibleRanges = i), r;
        }
        lineBlockAt(e) {
          return (
            (e >= this.viewport.from &&
              e <= this.viewport.to &&
              this.viewportLines.find((t) => t.from <= e && t.to >= e)) ||
            Ai(
              this.heightMap.lineAt(e, U.ByPos, this.heightOracle, 0, 0),
              this.scaler
            )
          );
        }
        lineBlockAtHeight(e) {
          return (
            (e >= this.viewportLines[0].top &&
              e <= this.viewportLines[this.viewportLines.length - 1].bottom &&
              this.viewportLines.find((t) => t.top <= e && t.bottom >= e)) ||
            Ai(
              this.heightMap.lineAt(
                this.scaler.fromDOM(e),
                U.ByHeight,
                this.heightOracle,
                0,
                0
              ),
              this.scaler
            )
          );
        }
        scrollAnchorAt(e) {
          let t = this.lineBlockAtHeight(e + 8);
          return t.from >= this.viewport.from ||
            this.viewportLines[0].top - e > 200
            ? t
            : this.viewportLines[0];
        }
        elementAtHeight(e) {
          return Ai(
            this.heightMap.blockAt(
              this.scaler.fromDOM(e),
              this.heightOracle,
              0,
              0
            ),
            this.scaler
          );
        }
        get docHeight() {
          return this.scaler.toDOM(this.heightMap.height);
        }
        get contentHeight() {
          return this.docHeight + this.paddingTop + this.paddingBottom;
        }
      }
      class xn {
        constructor(e, t) {
          (this.from = e), (this.to = t);
        }
      }
      function fp(n, e, t) {
        let i = [],
          r = n,
          s = 0;
        return (
          V.spans(
            t,
            n,
            e,
            {
              span() {},
              point(o, l) {
                o > r && (i.push({ from: r, to: o }), (s += o - r)), (r = l);
              },
            },
            20
          ),
          r < e && (i.push({ from: r, to: e }), (s += e - r)),
          { total: s, ranges: i }
        );
      }
      function wn({ total: n, ranges: e }, t) {
        if (t <= 0) return e[0].from;
        if (t >= 1) return e[e.length - 1].to;
        let i = Math.floor(n * t);
        for (let r = 0; ; r++) {
          let { from: s, to: o } = e[r],
            l = o - s;
          if (i <= l) return s + i;
          i -= l;
        }
      }
      function kn(n, e) {
        let t = 0;
        for (let { from: i, to: r } of n.ranges) {
          if (e <= r) {
            t += e - i;
            break;
          }
          t += r - i;
        }
        return t / n.total;
      }
      function up(n, e) {
        for (let t of n) if (e(t)) return t;
      }
      const ia = {
        toDOM(n) {
          return n;
        },
        fromDOM(n) {
          return n;
        },
        scale: 1,
        eq(n) {
          return n == this;
        },
      };
      class qo {
        constructor(e, t, i) {
          let r = 0,
            s = 0,
            o = 0;
          (this.viewports = i.map(({ from: l, to: a }) => {
            let h = t.lineAt(l, U.ByPos, e, 0, 0).top,
              c = t.lineAt(a, U.ByPos, e, 0, 0).bottom;
            return (
              (r += c - h),
              { from: l, to: a, top: h, bottom: c, domTop: 0, domBottom: 0 }
            );
          })),
            (this.scale = (7e6 - r) / (t.height - r));
          for (let l of this.viewports)
            (l.domTop = o + (l.top - s) * this.scale),
              (o = l.domBottom = l.domTop + (l.bottom - l.top)),
              (s = l.bottom);
        }
        toDOM(e) {
          for (let t = 0, i = 0, r = 0; ; t++) {
            let s = t < this.viewports.length ? this.viewports[t] : null;
            if (!s || e < s.top) return r + (e - i) * this.scale;
            if (e <= s.bottom) return s.domTop + (e - s.top);
            (i = s.bottom), (r = s.domBottom);
          }
        }
        fromDOM(e) {
          for (let t = 0, i = 0, r = 0; ; t++) {
            let s = t < this.viewports.length ? this.viewports[t] : null;
            if (!s || e < s.domTop) return i + (e - r) / this.scale;
            if (e <= s.domBottom) return s.top + (e - s.domTop);
            (i = s.bottom), (r = s.domBottom);
          }
        }
        eq(e) {
          return e instanceof qo
            ? this.scale == e.scale &&
                this.viewports.length == e.viewports.length &&
                this.viewports.every(
                  (t, i) =>
                    t.from == e.viewports[i].from && t.to == e.viewports[i].to
                )
            : !1;
        }
      }
      function Ai(n, e) {
        if (e.scale == 1) return n;
        let t = e.toDOM(n.top),
          i = e.toDOM(n.bottom);
        return new et(
          n.from,
          n.length,
          t,
          i - t,
          Array.isArray(n._content)
            ? n._content.map((r) => Ai(r, e))
            : n._content
        );
      }
      const $n = C.define({ combine: (n) => n.join(" ") }),
        ro = C.define({ combine: (n) => n.indexOf(!0) > -1 }),
        so = vt.newName(),
        ef = vt.newName(),
        tf = vt.newName(),
        nf = { "&light": "." + ef, "&dark": "." + tf };
      function oo(n, e, t) {
        return new vt(e, {
          finish(i) {
            return /&/.test(i)
              ? i.replace(/&\w*/, (r) => {
                  if (r == "&") return n;
                  if (!t || !t[r])
                    throw new RangeError(`Unsupported selector: ${r}`);
                  return t[r];
                })
              : n + " " + i;
          },
        });
      }
      const dp = oo(
          "." + so,
          {
            "&": {
              position: "relative !important",
              boxSizing: "border-box",
              "&.cm-focused": { outline: "1px dotted #212121" },
              display: "flex !important",
              flexDirection: "column",
            },
            ".cm-scroller": {
              display: "flex !important",
              alignItems: "flex-start !important",
              fontFamily: "monospace",
              lineHeight: 1.4,
              height: "100%",
              overflowX: "auto",
              position: "relative",
              zIndex: 0,
              overflowAnchor: "none",
            },
            ".cm-content": {
              margin: 0,
              flexGrow: 2,
              flexShrink: 0,
              display: "block",
              whiteSpace: "pre",
              wordWrap: "normal",
              boxSizing: "border-box",
              minHeight: "100%",
              padding: "4px 0",
              outline: "none",
              "&[contenteditable=true]": {
                WebkitUserModify: "read-write-plaintext-only",
              },
            },
            ".cm-lineWrapping": {
              whiteSpace_fallback: "pre-wrap",
              whiteSpace: "break-spaces",
              wordBreak: "break-word",
              overflowWrap: "anywhere",
              flexShrink: 1,
            },
            "&light .cm-content": { caretColor: "black" },
            "&dark .cm-content": { caretColor: "white" },
            ".cm-line": { display: "block", padding: "0 2px 0 6px" },
            ".cm-layer": {
              position: "absolute",
              left: 0,
              top: 0,
              contain: "size style",
              "& > *": { position: "absolute" },
            },
            "&light .cm-selectionBackground": { background: "#d9d9d9" },
            "&dark .cm-selectionBackground": { background: "#222" },
            "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground":
              { background: "#d7d4f0" },
            "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground":
              { background: "#233" },
            ".cm-cursorLayer": { pointerEvents: "none" },
            "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
              animation: "steps(1) cm-blink 1.2s infinite",
            },
            "@keyframes cm-blink": {
              "0%": {},
              "50%": { opacity: 0 },
              "100%": {},
            },
            "@keyframes cm-blink2": {
              "0%": {},
              "50%": { opacity: 0 },
              "100%": {},
            },
            ".cm-cursor, .cm-dropCursor": {
              borderLeft: "1.2px solid black",
              marginLeft: "-0.6px",
              pointerEvents: "none",
            },
            ".cm-cursor": { display: "none" },
            "&dark .cm-cursor": { borderLeftColor: "#ddd" },
            ".cm-dropCursor": { position: "absolute" },
            "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
              display: "block",
            },
            ".cm-iso": { unicodeBidi: "isolate" },
            ".cm-announced": { position: "fixed", top: "-10000px" },
            "@media print": { ".cm-announced": { display: "none" } },
            "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
            "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
            "&light .cm-specialChar": { color: "red" },
            "&dark .cm-specialChar": { color: "#f78" },
            ".cm-gutters": {
              flexShrink: 0,
              display: "flex",
              height: "100%",
              boxSizing: "border-box",
              zIndex: 200,
            },
            ".cm-gutters-before": { insetInlineStart: 0 },
            ".cm-gutters-after": { insetInlineEnd: 0 },
            "&light .cm-gutters": {
              backgroundColor: "#f5f5f5",
              color: "#6c6c6c",
              border: "0px solid #ddd",
              "&.cm-gutters-before": { borderRightWidth: "1px" },
              "&.cm-gutters-after": { borderLeftWidth: "1px" },
            },
            "&dark .cm-gutters": { backgroundColor: "#333338", color: "#ccc" },
            ".cm-gutter": {
              display: "flex !important",
              flexDirection: "column",
              flexShrink: 0,
              boxSizing: "border-box",
              minHeight: "100%",
              overflow: "hidden",
            },
            ".cm-gutterElement": { boxSizing: "border-box" },
            ".cm-lineNumbers .cm-gutterElement": {
              padding: "0 3px 0 5px",
              minWidth: "20px",
              textAlign: "right",
              whiteSpace: "nowrap",
            },
            "&light .cm-activeLineGutter": { backgroundColor: "#e2f2ff" },
            "&dark .cm-activeLineGutter": { backgroundColor: "#222227" },
            ".cm-panels": {
              boxSizing: "border-box",
              position: "sticky",
              left: 0,
              right: 0,
              zIndex: 300,
            },
            "&light .cm-panels": { backgroundColor: "#f5f5f5", color: "black" },
            "&light .cm-panels-top": { borderBottom: "1px solid #ddd" },
            "&light .cm-panels-bottom": { borderTop: "1px solid #ddd" },
            "&dark .cm-panels": { backgroundColor: "#333338", color: "white" },
            ".cm-dialog": {
              padding: "2px 19px 4px 6px",
              position: "relative",
              "& label": { fontSize: "80%" },
            },
            ".cm-dialog-close": {
              position: "absolute",
              top: "3px",
              right: "4px",
              backgroundColor: "inherit",
              border: "none",
              font: "inherit",
              fontSize: "14px",
              padding: "0",
            },
            ".cm-tab": {
              display: "inline-block",
              overflow: "hidden",
              verticalAlign: "bottom",
            },
            ".cm-widgetBuffer": {
              verticalAlign: "text-top",
              height: "1em",
              width: 0,
              display: "inline",
            },
            ".cm-placeholder": {
              color: "#888",
              display: "inline-block",
              verticalAlign: "top",
              userSelect: "none",
            },
            ".cm-highlightSpace": {
              backgroundImage:
                "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
              backgroundPosition: "center",
            },
            ".cm-highlightTab": {
              backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
              backgroundSize: "auto 100%",
              backgroundPosition: "right 90%",
              backgroundRepeat: "no-repeat",
            },
            ".cm-trailingSpace": { backgroundColor: "#ff332255" },
            ".cm-button": {
              verticalAlign: "middle",
              color: "inherit",
              fontSize: "70%",
              padding: ".2em 1em",
              borderRadius: "1px",
            },
            "&light .cm-button": {
              backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
              border: "1px solid #888",
              "&:active": {
                backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)",
              },
            },
            "&dark .cm-button": {
              backgroundImage: "linear-gradient(#393939, #111)",
              border: "1px solid #888",
              "&:active": { backgroundImage: "linear-gradient(#111, #333)" },
            },
            ".cm-textfield": {
              verticalAlign: "middle",
              color: "inherit",
              fontSize: "70%",
              border: "1px solid silver",
              padding: ".2em .5em",
            },
            "&light .cm-textfield": { backgroundColor: "white" },
            "&dark .cm-textfield": {
              border: "1px solid #555",
              backgroundColor: "inherit",
            },
          },
          nf
        ),
        Op = {
          childList: !0,
          characterData: !0,
          subtree: !0,
          attributes: !0,
          characterDataOldValue: !0,
        },
        ts = T.ie && T.ie_version <= 11;
      class pp {
        constructor(e) {
          (this.view = e),
            (this.active = !1),
            (this.editContext = null),
            (this.selectionRange = new Fd()),
            (this.selectionChanged = !1),
            (this.delayedFlush = -1),
            (this.resizeTimeout = -1),
            (this.queue = []),
            (this.delayedAndroidKey = null),
            (this.flushingAndroidKey = -1),
            (this.lastChange = 0),
            (this.scrollTargets = []),
            (this.intersection = null),
            (this.resizeScroll = null),
            (this.intersecting = !1),
            (this.gapIntersection = null),
            (this.gaps = []),
            (this.printQuery = null),
            (this.parentCheck = -1),
            (this.dom = e.contentDOM),
            (this.observer = new MutationObserver((t) => {
              for (let i of t) this.queue.push(i);
              ((T.ie && T.ie_version <= 11) || (T.ios && e.composing)) &&
              t.some(
                (i) =>
                  (i.type == "childList" && i.removedNodes.length) ||
                  (i.type == "characterData" &&
                    i.oldValue.length > i.target.nodeValue.length)
              )
                ? this.flushSoon()
                : this.flush();
            })),
            window.EditContext &&
              T.android &&
              e.constructor.EDIT_CONTEXT !== !1 &&
              !(T.chrome && T.chrome_version < 126) &&
              ((this.editContext = new gp(e)),
              e.state.facet(ut) &&
                (e.contentDOM.editContext = this.editContext.editContext)),
            ts &&
              (this.onCharData = (t) => {
                this.queue.push({
                  target: t.target,
                  type: "characterData",
                  oldValue: t.prevValue,
                }),
                  this.flushSoon();
              }),
            (this.onSelectionChange = this.onSelectionChange.bind(this)),
            (this.onResize = this.onResize.bind(this)),
            (this.onPrint = this.onPrint.bind(this)),
            (this.onScroll = this.onScroll.bind(this)),
            window.matchMedia && (this.printQuery = window.matchMedia("print")),
            typeof ResizeObserver == "function" &&
              ((this.resizeScroll = new ResizeObserver(() => {
                var t;
                ((t = this.view.docView) === null || t === void 0
                  ? void 0
                  : t.lastUpdate) <
                  Date.now() - 75 && this.onResize();
              })),
              this.resizeScroll.observe(e.scrollDOM)),
            this.addWindowListeners((this.win = e.win)),
            this.start(),
            typeof IntersectionObserver == "function" &&
              ((this.intersection = new IntersectionObserver(
                (t) => {
                  this.parentCheck < 0 &&
                    (this.parentCheck = setTimeout(
                      this.listenForScroll.bind(this),
                      1e3
                    )),
                    t.length > 0 &&
                      t[t.length - 1].intersectionRatio > 0 !=
                        this.intersecting &&
                      ((this.intersecting = !this.intersecting),
                      this.intersecting != this.view.inView &&
                        this.onScrollChanged(document.createEvent("Event")));
                },
                { threshold: [0, 0.001] }
              )),
              this.intersection.observe(this.dom),
              (this.gapIntersection = new IntersectionObserver((t) => {
                t.length > 0 &&
                  t[t.length - 1].intersectionRatio > 0 &&
                  this.onScrollChanged(document.createEvent("Event"));
              }, {}))),
            this.listenForScroll(),
            this.readSelectionRange();
        }
        onScrollChanged(e) {
          this.view.inputState.runHandlers("scroll", e),
            this.intersecting && this.view.measure();
        }
        onScroll(e) {
          this.intersecting && this.flush(!1),
            this.editContext &&
              this.view.requestMeasure(this.editContext.measureReq),
            this.onScrollChanged(e);
        }
        onResize() {
          this.resizeTimeout < 0 &&
            (this.resizeTimeout = setTimeout(() => {
              (this.resizeTimeout = -1), this.view.requestMeasure();
            }, 50));
        }
        onPrint(e) {
          ((e.type == "change" || !e.type) && !e.matches) ||
            ((this.view.viewState.printing = !0),
            this.view.measure(),
            setTimeout(() => {
              (this.view.viewState.printing = !1), this.view.requestMeasure();
            }, 500));
        }
        updateGaps(e) {
          if (
            this.gapIntersection &&
            (e.length != this.gaps.length ||
              this.gaps.some((t, i) => t != e[i]))
          ) {
            this.gapIntersection.disconnect();
            for (let t of e) this.gapIntersection.observe(t);
            this.gaps = e;
          }
        }
        onSelectionChange(e) {
          let t = this.selectionChanged;
          if (!this.readSelectionRange() || this.delayedAndroidKey) return;
          let { view: i } = this,
            r = this.selectionRange;
          if (
            i.state.facet(ut)
              ? i.root.activeElement != this.dom
              : !Vn(this.dom, r)
          )
            return;
          let s = r.anchorNode && i.docView.nearest(r.anchorNode);
          if (s && s.ignoreEvent(e)) {
            t || (this.selectionChanged = !1);
            return;
          }
          ((T.ie && T.ie_version <= 11) || (T.android && T.chrome)) &&
          !i.state.selection.main.empty &&
          r.focusNode &&
          zi(r.focusNode, r.focusOffset, r.anchorNode, r.anchorOffset)
            ? this.flushSoon()
            : this.flush(!1);
        }
        readSelectionRange() {
          let { view: e } = this,
            t = Li(e.root);
          if (!t) return !1;
          let i =
            (T.safari &&
              e.root.nodeType == 11 &&
              e.root.activeElement == this.dom &&
              mp(this.view, t)) ||
            t;
          if (!i || this.selectionRange.eq(i)) return !1;
          let r = Vn(this.dom, i);
          return r &&
            !this.selectionChanged &&
            e.inputState.lastFocusTime > Date.now() - 200 &&
            e.inputState.lastTouchTime < Date.now() - 300 &&
            Kd(this.dom, i)
            ? ((this.view.inputState.lastFocusTime = 0),
              e.docView.updateSelection(),
              !1)
            : (this.selectionRange.setRange(i),
              r && (this.selectionChanged = !0),
              !0);
        }
        setSelectionRange(e, t) {
          this.selectionRange.set(e.node, e.offset, t.node, t.offset),
            (this.selectionChanged = !1);
        }
        clearSelectionRange() {
          this.selectionRange.set(null, 0, null, 0);
        }
        listenForScroll() {
          this.parentCheck = -1;
          let e = 0,
            t = null;
          for (let i = this.dom; i; )
            if (i.nodeType == 1)
              !t && e < this.scrollTargets.length && this.scrollTargets[e] == i
                ? e++
                : t || (t = this.scrollTargets.slice(0, e)),
                t && t.push(i),
                (i = i.assignedSlot || i.parentNode);
            else if (i.nodeType == 11) i = i.host;
            else break;
          if (
            (e < this.scrollTargets.length &&
              !t &&
              (t = this.scrollTargets.slice(0, e)),
            t)
          ) {
            for (let i of this.scrollTargets)
              i.removeEventListener("scroll", this.onScroll);
            for (let i of (this.scrollTargets = t))
              i.addEventListener("scroll", this.onScroll);
          }
        }
        ignore(e) {
          if (!this.active) return e();
          try {
            return this.stop(), e();
          } finally {
            this.start(), this.clear();
          }
        }
        start() {
          this.active ||
            (this.observer.observe(this.dom, Op),
            ts &&
              this.dom.addEventListener(
                "DOMCharacterDataModified",
                this.onCharData
              ),
            (this.active = !0));
        }
        stop() {
          this.active &&
            ((this.active = !1),
            this.observer.disconnect(),
            ts &&
              this.dom.removeEventListener(
                "DOMCharacterDataModified",
                this.onCharData
              ));
        }
        clear() {
          this.processRecords(),
            (this.queue.length = 0),
            (this.selectionChanged = !1);
        }
        delayAndroidKey(e, t) {
          var i;
          if (!this.delayedAndroidKey) {
            let r = () => {
              let s = this.delayedAndroidKey;
              s &&
                (this.clearDelayedAndroidKey(),
                (this.view.inputState.lastKeyCode = s.keyCode),
                (this.view.inputState.lastKeyTime = Date.now()),
                !this.flush() && s.force && ti(this.dom, s.key, s.keyCode));
            };
            this.flushingAndroidKey = this.view.win.requestAnimationFrame(r);
          }
          (!this.delayedAndroidKey || e == "Enter") &&
            (this.delayedAndroidKey = {
              key: e,
              keyCode: t,
              force:
                this.lastChange < Date.now() - 50 ||
                !!(
                  !((i = this.delayedAndroidKey) === null || i === void 0) &&
                  i.force
                ),
            });
        }
        clearDelayedAndroidKey() {
          this.win.cancelAnimationFrame(this.flushingAndroidKey),
            (this.delayedAndroidKey = null),
            (this.flushingAndroidKey = -1);
        }
        flushSoon() {
          this.delayedFlush < 0 &&
            (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
              (this.delayedFlush = -1), this.flush();
            }));
        }
        forceFlush() {
          this.delayedFlush >= 0 &&
            (this.view.win.cancelAnimationFrame(this.delayedFlush),
            (this.delayedFlush = -1)),
            this.flush();
        }
        pendingRecords() {
          for (let e of this.observer.takeRecords()) this.queue.push(e);
          return this.queue;
        }
        processRecords() {
          let e = this.pendingRecords();
          e.length && (this.queue = []);
          let t = -1,
            i = -1,
            r = !1;
          for (let s of e) {
            let o = this.readMutation(s);
            o &&
              (o.typeOver && (r = !0),
              t == -1
                ? ({ from: t, to: i } = o)
                : ((t = Math.min(o.from, t)), (i = Math.max(o.to, i))));
          }
          return { from: t, to: i, typeOver: r };
        }
        readChange() {
          let { from: e, to: t, typeOver: i } = this.processRecords(),
            r = this.selectionChanged && Vn(this.dom, this.selectionRange);
          if (e < 0 && !r) return null;
          e > -1 && (this.lastChange = Date.now()),
            (this.view.inputState.lastFocusTime = 0),
            (this.selectionChanged = !1);
          let s = new RO(this.view, e, t, i);
          return (
            (this.view.docView.domChanged = {
              newSel: s.newSel ? s.newSel.main : null,
            }),
            s
          );
        }
        flush(e = !0) {
          if (this.delayedFlush >= 0 || this.delayedAndroidKey) return !1;
          e && this.readSelectionRange();
          let t = this.readChange();
          if (!t) return this.view.requestMeasure(), !1;
          let i = this.view.state,
            r = jc(this.view, t);
          return (
            this.view.state == i &&
              (t.domChanged ||
                (t.newSel &&
                  !t.newSel.main.eq(this.view.state.selection.main))) &&
              this.view.update([]),
            r
          );
        }
        readMutation(e) {
          let t = this.view.docView.nearest(e.target);
          if (!t || t.ignoreMutation(e)) return null;
          if (
            (t.markDirty(e.type == "attributes"),
            e.type == "attributes" && (t.flags |= 4),
            e.type == "childList")
          ) {
            let i = na(t, e.previousSibling || e.target.previousSibling, -1),
              r = na(t, e.nextSibling || e.target.nextSibling, 1);
            return {
              from: i ? t.posAfter(i) : t.posAtStart,
              to: r ? t.posBefore(r) : t.posAtEnd,
              typeOver: !1,
            };
          } else
            return e.type == "characterData"
              ? {
                  from: t.posAtStart,
                  to: t.posAtEnd,
                  typeOver: e.target.nodeValue == e.oldValue,
                }
              : null;
        }
        setWindow(e) {
          e != this.win &&
            (this.removeWindowListeners(this.win),
            (this.win = e),
            this.addWindowListeners(this.win));
        }
        addWindowListeners(e) {
          e.addEventListener("resize", this.onResize),
            this.printQuery
              ? this.printQuery.addEventListener
                ? this.printQuery.addEventListener("change", this.onPrint)
                : this.printQuery.addListener(this.onPrint)
              : e.addEventListener("beforeprint", this.onPrint),
            e.addEventListener("scroll", this.onScroll),
            e.document.addEventListener(
              "selectionchange",
              this.onSelectionChange
            );
        }
        removeWindowListeners(e) {
          e.removeEventListener("scroll", this.onScroll),
            e.removeEventListener("resize", this.onResize),
            this.printQuery
              ? this.printQuery.removeEventListener
                ? this.printQuery.removeEventListener("change", this.onPrint)
                : this.printQuery.removeListener(this.onPrint)
              : e.removeEventListener("beforeprint", this.onPrint),
            e.document.removeEventListener(
              "selectionchange",
              this.onSelectionChange
            );
        }
        update(e) {
          this.editContext &&
            (this.editContext.update(e),
            e.startState.facet(ut) != e.state.facet(ut) &&
              (e.view.contentDOM.editContext = e.state.facet(ut)
                ? this.editContext.editContext
                : null));
        }
        destroy() {
          var e, t, i;
          this.stop(),
            (e = this.intersection) === null || e === void 0 || e.disconnect(),
            (t = this.gapIntersection) === null ||
              t === void 0 ||
              t.disconnect(),
            (i = this.resizeScroll) === null || i === void 0 || i.disconnect();
          for (let r of this.scrollTargets)
            r.removeEventListener("scroll", this.onScroll);
          this.removeWindowListeners(this.win),
            clearTimeout(this.parentCheck),
            clearTimeout(this.resizeTimeout),
            this.win.cancelAnimationFrame(this.delayedFlush),
            this.win.cancelAnimationFrame(this.flushingAndroidKey),
            this.editContext &&
              ((this.view.contentDOM.editContext = null),
              this.editContext.destroy());
        }
      }
      function na(n, e, t) {
        for (; e; ) {
          let i = I.get(e);
          if (i && i.parent == n) return i;
          let r = e.parentNode;
          e = r != n.dom ? r : t > 0 ? e.nextSibling : e.previousSibling;
        }
        return null;
      }
      function ra(n, e) {
        let t = e.startContainer,
          i = e.startOffset,
          r = e.endContainer,
          s = e.endOffset,
          o = n.docView.domAtPos(n.state.selection.main.anchor);
        return (
          zi(o.node, o.offset, r, s) && ([t, i, r, s] = [r, s, t, i]),
          { anchorNode: t, anchorOffset: i, focusNode: r, focusOffset: s }
        );
      }
      function mp(n, e) {
        if (e.getComposedRanges) {
          let r = e.getComposedRanges(n.root)[0];
          if (r) return ra(n, r);
        }
        let t = null;
        function i(r) {
          r.preventDefault(),
            r.stopImmediatePropagation(),
            (t = r.getTargetRanges()[0]);
        }
        return (
          n.contentDOM.addEventListener("beforeinput", i, !0),
          n.dom.ownerDocument.execCommand("indent"),
          n.contentDOM.removeEventListener("beforeinput", i, !0),
          t ? ra(n, t) : null
        );
      }
      class gp {
        constructor(e) {
          (this.from = 0),
            (this.to = 0),
            (this.pendingContextChange = null),
            (this.handlers = Object.create(null)),
            (this.composing = null),
            this.resetRange(e.state);
          let t = (this.editContext = new window.EditContext({
            text: e.state.doc.sliceString(this.from, this.to),
            selectionStart: this.toContextPos(
              Math.max(
                this.from,
                Math.min(this.to, e.state.selection.main.anchor)
              )
            ),
            selectionEnd: this.toContextPos(e.state.selection.main.head),
          }));
          (this.handlers.textupdate = (i) => {
            let r = e.state.selection.main,
              { anchor: s, head: o } = r,
              l = this.toEditorPos(i.updateRangeStart),
              a = this.toEditorPos(i.updateRangeEnd);
            e.inputState.composing >= 0 &&
              !this.composing &&
              (this.composing = {
                contextBase: i.updateRangeStart,
                editorBase: l,
                drifted: !1,
              });
            let h = {
              from: l,
              to: a,
              insert: E.of(
                i.text.split(`
`)
              ),
            };
            if (
              (h.from == this.from && s < this.from
                ? (h.from = s)
                : h.to == this.to && s > this.to && (h.to = s),
              h.from == h.to && !h.insert.length)
            ) {
              let c = S.single(
                this.toEditorPos(i.selectionStart),
                this.toEditorPos(i.selectionEnd)
              );
              c.main.eq(r) || e.dispatch({ selection: c, userEvent: "select" });
              return;
            }
            if (
              ((T.mac || T.android) &&
                h.from == o - 1 &&
                /^\. ?$/.test(i.text) &&
                e.contentDOM.getAttribute("autocorrect") == "off" &&
                (h = {
                  from: l,
                  to: a,
                  insert: E.of([i.text.replace(".", " ")]),
                }),
              (this.pendingContextChange = h),
              !e.state.readOnly)
            ) {
              let c = this.to - this.from + (h.to - h.from + h.insert.length);
              _o(
                e,
                h,
                S.single(
                  this.toEditorPos(i.selectionStart, c),
                  this.toEditorPos(i.selectionEnd, c)
                )
              );
            }
            this.pendingContextChange &&
              (this.revertPending(e.state), this.setSelection(e.state));
          }),
            (this.handlers.characterboundsupdate = (i) => {
              let r = [],
                s = null;
              for (
                let o = this.toEditorPos(i.rangeStart),
                  l = this.toEditorPos(i.rangeEnd);
                o < l;
                o++
              ) {
                let a = e.coordsForChar(o);
                (s =
                  (a &&
                    new DOMRect(
                      a.left,
                      a.top,
                      a.right - a.left,
                      a.bottom - a.top
                    )) ||
                  s ||
                  new DOMRect()),
                  r.push(s);
              }
              t.updateCharacterBounds(i.rangeStart, r);
            }),
            (this.handlers.textformatupdate = (i) => {
              let r = [];
              for (let s of i.getTextFormats()) {
                let o = s.underlineStyle,
                  l = s.underlineThickness;
                if (o != "None" && l != "None") {
                  let a = this.toEditorPos(s.rangeStart),
                    h = this.toEditorPos(s.rangeEnd);
                  if (a < h) {
                    let c = `text-decoration: underline ${
                      o == "Dashed" ? "dashed " : o == "Squiggle" ? "wavy " : ""
                    }${l == "Thin" ? 1 : 2}px`;
                    r.push(A.mark({ attributes: { style: c } }).range(a, h));
                  }
                }
              }
              e.dispatch({ effects: zc.of(A.set(r)) });
            }),
            (this.handlers.compositionstart = () => {
              e.inputState.composing < 0 &&
                ((e.inputState.composing = 0),
                (e.inputState.compositionFirstChange = !0));
            }),
            (this.handlers.compositionend = () => {
              if (
                ((e.inputState.composing = -1),
                (e.inputState.compositionFirstChange = null),
                this.composing)
              ) {
                let { drifted: i } = this.composing;
                (this.composing = null), i && this.reset(e.state);
              }
            });
          for (let i in this.handlers) t.addEventListener(i, this.handlers[i]);
          this.measureReq = {
            read: (i) => {
              this.editContext.updateControlBounds(
                i.contentDOM.getBoundingClientRect()
              );
              let r = Li(i.root);
              r &&
                r.rangeCount &&
                this.editContext.updateSelectionBounds(
                  r.getRangeAt(0).getBoundingClientRect()
                );
            },
          };
        }
        applyEdits(e) {
          let t = 0,
            i = !1,
            r = this.pendingContextChange;
          return (
            e.changes.iterChanges((s, o, l, a, h) => {
              if (i) return;
              let c = h.length - (o - s);
              if (r && o >= r.to)
                if (r.from == s && r.to == o && r.insert.eq(h)) {
                  (r = this.pendingContextChange = null),
                    (t += c),
                    (this.to += c);
                  return;
                } else (r = null), this.revertPending(e.state);
              if (((s += t), (o += t), o <= this.from))
                (this.from += c), (this.to += c);
              else if (s < this.to) {
                if (
                  s < this.from ||
                  o > this.to ||
                  this.to - this.from + h.length > 3e4
                ) {
                  i = !0;
                  return;
                }
                this.editContext.updateText(
                  this.toContextPos(s),
                  this.toContextPos(o),
                  h.toString()
                ),
                  (this.to += c);
              }
              t += c;
            }),
            r && !i && this.revertPending(e.state),
            !i
          );
        }
        update(e) {
          let t = this.pendingContextChange,
            i = e.startState.selection.main;
          this.composing &&
          (this.composing.drifted ||
            (!e.changes.touchesRange(i.from, i.to) &&
              e.transactions.some(
                (r) =>
                  !r.isUserEvent("input.type") &&
                  r.changes.touchesRange(this.from, this.to)
              )))
            ? ((this.composing.drifted = !0),
              (this.composing.editorBase = e.changes.mapPos(
                this.composing.editorBase
              )))
            : !this.applyEdits(e) || !this.rangeIsValid(e.state)
            ? ((this.pendingContextChange = null), this.reset(e.state))
            : (e.docChanged || e.selectionSet || t) &&
              this.setSelection(e.state),
            (e.geometryChanged || e.docChanged || e.selectionSet) &&
              e.view.requestMeasure(this.measureReq);
        }
        resetRange(e) {
          let { head: t } = e.selection.main;
          (this.from = Math.max(0, t - 1e4)),
            (this.to = Math.min(e.doc.length, t + 1e4));
        }
        reset(e) {
          this.resetRange(e),
            this.editContext.updateText(
              0,
              this.editContext.text.length,
              e.doc.sliceString(this.from, this.to)
            ),
            this.setSelection(e);
        }
        revertPending(e) {
          let t = this.pendingContextChange;
          (this.pendingContextChange = null),
            this.editContext.updateText(
              this.toContextPos(t.from),
              this.toContextPos(t.from + t.insert.length),
              e.doc.sliceString(t.from, t.to)
            );
        }
        setSelection(e) {
          let { main: t } = e.selection,
            i = this.toContextPos(
              Math.max(this.from, Math.min(this.to, t.anchor))
            ),
            r = this.toContextPos(t.head);
          (this.editContext.selectionStart != i ||
            this.editContext.selectionEnd != r) &&
            this.editContext.updateSelection(i, r);
        }
        rangeIsValid(e) {
          let { head: t } = e.selection.main;
          return !(
            (this.from > 0 && t - this.from < 500) ||
            (this.to < e.doc.length && this.to - t < 500) ||
            this.to - this.from > 1e4 * 3
          );
        }
        toEditorPos(e, t = this.to - this.from) {
          e = Math.min(e, t);
          let i = this.composing;
          return i && i.drifted
            ? i.editorBase + (e - i.contextBase)
            : e + this.from;
        }
        toContextPos(e) {
          let t = this.composing;
          return t && t.drifted
            ? t.contextBase + (e - t.editorBase)
            : e - this.from;
        }
        destroy() {
          for (let e in this.handlers)
            this.editContext.removeEventListener(e, this.handlers[e]);
        }
      }
      class v {
        get state() {
          return this.viewState.state;
        }
        get viewport() {
          return this.viewState.viewport;
        }
        get visibleRanges() {
          return this.viewState.visibleRanges;
        }
        get inView() {
          return this.viewState.inView;
        }
        get composing() {
          return !!this.inputState && this.inputState.composing > 0;
        }
        get compositionStarted() {
          return !!this.inputState && this.inputState.composing >= 0;
        }
        get root() {
          return this._root;
        }
        get win() {
          return this.dom.ownerDocument.defaultView || window;
        }
        constructor(e = {}) {
          var t;
          (this.plugins = []),
            (this.pluginMap = new Map()),
            (this.editorAttrs = {}),
            (this.contentAttrs = {}),
            (this.bidiCache = []),
            (this.destroyed = !1),
            (this.updateState = 2),
            (this.measureScheduled = -1),
            (this.measureRequests = []),
            (this.contentDOM = document.createElement("div")),
            (this.scrollDOM = document.createElement("div")),
            (this.scrollDOM.tabIndex = -1),
            (this.scrollDOM.className = "cm-scroller"),
            this.scrollDOM.appendChild(this.contentDOM),
            (this.announceDOM = document.createElement("div")),
            (this.announceDOM.className = "cm-announced"),
            this.announceDOM.setAttribute("aria-live", "polite"),
            (this.dom = document.createElement("div")),
            this.dom.appendChild(this.announceDOM),
            this.dom.appendChild(this.scrollDOM),
            e.parent && e.parent.appendChild(this.dom);
          let { dispatch: i } = e;
          (this.dispatchTransactions =
            e.dispatchTransactions ||
            (i && ((r) => r.forEach((s) => i(s, this)))) ||
            ((r) => this.update(r))),
            (this.dispatch = this.dispatch.bind(this)),
            (this._root = e.root || Hd(e.parent) || document),
            (this.viewState = new ta(e.state || _.create(e))),
            e.scrollTo &&
              e.scrollTo.is(Sn) &&
              (this.viewState.scrollTarget = e.scrollTo.value.clip(
                this.viewState.state
              )),
            (this.plugins = this.state.facet(Ft).map((r) => new Hr(r)));
          for (let r of this.plugins) r.update(this);
          (this.observer = new pp(this)),
            (this.inputState = new EO(this)),
            this.inputState.ensureHandlers(this.plugins),
            (this.docView = new zl(this)),
            this.mountStyles(),
            this.updateAttrs(),
            (this.updateState = 0),
            this.requestMeasure(),
            !((t = document.fonts) === null || t === void 0) &&
              t.ready &&
              document.fonts.ready.then(() => this.requestMeasure());
        }
        dispatch(...e) {
          let t =
            e.length == 1 && e[0] instanceof ie
              ? e
              : e.length == 1 && Array.isArray(e[0])
              ? e[0]
              : [this.state.update(...e)];
          this.dispatchTransactions(t, this);
        }
        update(e) {
          if (this.updateState != 0)
            throw new Error(
              "Calls to EditorView.update are not allowed while an update is in progress"
            );
          let t = !1,
            i = !1,
            r,
            s = this.state;
          for (let u of e) {
            if (u.startState != s)
              throw new RangeError(
                "Trying to update state with a transaction that doesn't start from the previous state."
              );
            s = u.state;
          }
          if (this.destroyed) {
            this.viewState.state = s;
            return;
          }
          let o = this.hasFocus,
            l = 0,
            a = null;
          e.some((u) => u.annotation(Fc))
            ? ((this.inputState.notifiedFocused = o), (l = 1))
            : o != this.inputState.notifiedFocused &&
              ((this.inputState.notifiedFocused = o),
              (a = Hc(s, o)),
              a || (l = 1));
          let h = this.observer.delayedAndroidKey,
            c = null;
          if (
            (h
              ? (this.observer.clearDelayedAndroidKey(),
                (c = this.observer.readChange()),
                ((c && !this.state.doc.eq(s.doc)) ||
                  !this.state.selection.eq(s.selection)) &&
                  (c = null))
              : this.observer.clear(),
            s.facet(_.phrases) != this.state.facet(_.phrases))
          )
            return this.setState(s);
          (r = nr.create(this, s, e)), (r.flags |= l);
          let f = this.viewState.scrollTarget;
          try {
            this.updateState = 2;
            for (let u of e) {
              if ((f && (f = f.map(u.changes)), u.scrollIntoView)) {
                let { main: d } = u.state.selection;
                f = new ii(
                  d.empty ? d : S.cursor(d.head, d.head > d.anchor ? -1 : 1)
                );
              }
              for (let d of u.effects)
                d.is(Sn) && (f = d.value.clip(this.state));
            }
            this.viewState.update(r, f),
              (this.bidiCache = sr.update(this.bidiCache, r.changes)),
              r.empty || (this.updatePlugins(r), this.inputState.update(r)),
              (t = this.docView.update(r)),
              this.state.facet(Ci) != this.styleModules && this.mountStyles(),
              (i = this.updateAttrs()),
              this.showAnnouncements(e),
              this.docView.updateSelection(
                t,
                e.some((u) => u.isUserEvent("select.pointer"))
              );
          } finally {
            this.updateState = 0;
          }
          if (
            (r.startState.facet($n) != r.state.facet($n) &&
              (this.viewState.mustMeasureContent = !0),
            (t ||
              i ||
              f ||
              this.viewState.mustEnforceCursorAssoc ||
              this.viewState.mustMeasureContent) &&
              this.requestMeasure(),
            t && this.docViewUpdate(),
            !r.empty)
          )
            for (let u of this.state.facet(eo))
              try {
                u(r);
              } catch (d) {
                ke(this.state, d, "update listener");
              }
          (a || c) &&
            Promise.resolve().then(() => {
              a && this.state == a.startState && this.dispatch(a),
                c &&
                  !jc(this, c) &&
                  h.force &&
                  ti(this.contentDOM, h.key, h.keyCode);
            });
        }
        setState(e) {
          if (this.updateState != 0)
            throw new Error(
              "Calls to EditorView.setState are not allowed while an update is in progress"
            );
          if (this.destroyed) {
            this.viewState.state = e;
            return;
          }
          this.updateState = 2;
          let t = this.hasFocus;
          try {
            for (let i of this.plugins) i.destroy(this);
            (this.viewState = new ta(e)),
              (this.plugins = e.facet(Ft).map((i) => new Hr(i))),
              this.pluginMap.clear();
            for (let i of this.plugins) i.update(this);
            this.docView.destroy(),
              (this.docView = new zl(this)),
              this.inputState.ensureHandlers(this.plugins),
              this.mountStyles(),
              this.updateAttrs(),
              (this.bidiCache = []);
          } finally {
            this.updateState = 0;
          }
          t && this.focus(), this.requestMeasure();
        }
        updatePlugins(e) {
          let t = e.startState.facet(Ft),
            i = e.state.facet(Ft);
          if (t != i) {
            let r = [];
            for (let s of i) {
              let o = t.indexOf(s);
              if (o < 0) r.push(new Hr(s));
              else {
                let l = this.plugins[o];
                (l.mustUpdate = e), r.push(l);
              }
            }
            for (let s of this.plugins) s.mustUpdate != e && s.destroy(this);
            (this.plugins = r), this.pluginMap.clear();
          } else for (let r of this.plugins) r.mustUpdate = e;
          for (let r = 0; r < this.plugins.length; r++)
            this.plugins[r].update(this);
          t != i && this.inputState.ensureHandlers(this.plugins);
        }
        docViewUpdate() {
          for (let e of this.plugins) {
            let t = e.value;
            if (t && t.docViewUpdate)
              try {
                t.docViewUpdate(this);
              } catch (i) {
                ke(this.state, i, "doc view update listener");
              }
          }
        }
        measure(e = !0) {
          if (this.destroyed) return;
          if (
            (this.measureScheduled > -1 &&
              this.win.cancelAnimationFrame(this.measureScheduled),
            this.observer.delayedAndroidKey)
          ) {
            (this.measureScheduled = -1), this.requestMeasure();
            return;
          }
          (this.measureScheduled = 0), e && this.observer.forceFlush();
          let t = null,
            i = this.scrollDOM,
            r = i.scrollTop * this.scaleY,
            { scrollAnchorPos: s, scrollAnchorHeight: o } = this.viewState;
          Math.abs(r - this.viewState.scrollTop) > 1 && (o = -1),
            (this.viewState.scrollAnchorHeight = -1);
          try {
            for (let l = 0; ; l++) {
              if (o < 0)
                if (cc(i)) (s = -1), (o = this.viewState.heightMap.height);
                else {
                  let d = this.viewState.scrollAnchorAt(r);
                  (s = d.from), (o = d.top);
                }
              this.updateState = 1;
              let a = this.viewState.measure(this);
              if (
                !a &&
                !this.measureRequests.length &&
                this.viewState.scrollTarget == null
              )
                break;
              if (l > 5) {
                console.warn(
                  this.measureRequests.length
                    ? "Measure loop restarted more than 5 times"
                    : "Viewport failed to stabilize"
                );
                break;
              }
              let h = [];
              a & 4 || ([this.measureRequests, h] = [h, this.measureRequests]);
              let c = h.map((d) => {
                  try {
                    return d.read(this);
                  } catch (O) {
                    return ke(this.state, O), sa;
                  }
                }),
                f = nr.create(this, this.state, []),
                u = !1;
              (f.flags |= a),
                t ? (t.flags |= a) : (t = f),
                (this.updateState = 2),
                f.empty ||
                  (this.updatePlugins(f),
                  this.inputState.update(f),
                  this.updateAttrs(),
                  (u = this.docView.update(f)),
                  u && this.docViewUpdate());
              for (let d = 0; d < h.length; d++)
                if (c[d] != sa)
                  try {
                    let O = h[d];
                    O.write && O.write(c[d], this);
                  } catch (O) {
                    ke(this.state, O);
                  }
              if (
                (u && this.docView.updateSelection(!0),
                !f.viewportChanged && this.measureRequests.length == 0)
              ) {
                if (this.viewState.editorHeight)
                  if (this.viewState.scrollTarget) {
                    this.docView.scrollIntoView(this.viewState.scrollTarget),
                      (this.viewState.scrollTarget = null),
                      (o = -1);
                    continue;
                  } else {
                    let O =
                      (s < 0
                        ? this.viewState.heightMap.height
                        : this.viewState.lineBlockAt(s).top) - o;
                    if (O > 1 || O < -1) {
                      (r = r + O), (i.scrollTop = r / this.scaleY), (o = -1);
                      continue;
                    }
                  }
                break;
              }
            }
          } finally {
            (this.updateState = 0), (this.measureScheduled = -1);
          }
          if (t && !t.empty) for (let l of this.state.facet(eo)) l(t);
        }
        get themeClasses() {
          return (
            so +
            " " +
            (this.state.facet(ro) ? tf : ef) +
            " " +
            this.state.facet($n)
          );
        }
        updateAttrs() {
          let e = oa(this, Dc, {
              class:
                "cm-editor" +
                (this.hasFocus ? " cm-focused " : " ") +
                this.themeClasses,
            }),
            t = {
              spellcheck: "false",
              autocorrect: "off",
              autocapitalize: "off",
              writingsuggestions: "false",
              translate: "no",
              contenteditable: this.state.facet(ut) ? "true" : "false",
              class: "cm-content",
              style: `${T.tabSize}: ${this.state.tabSize}`,
              role: "textbox",
              "aria-multiline": "true",
            };
          this.state.readOnly && (t["aria-readonly"] = "true"), oa(this, Do, t);
          let i = this.observer.ignore(() => {
            let r = Us(this.contentDOM, this.contentAttrs, t),
              s = Us(this.dom, this.editorAttrs, e);
            return r || s;
          });
          return (this.editorAttrs = e), (this.contentAttrs = t), i;
        }
        showAnnouncements(e) {
          let t = !0;
          for (let i of e)
            for (let r of i.effects)
              if (r.is(v.announce)) {
                t && (this.announceDOM.textContent = ""), (t = !1);
                let s = this.announceDOM.appendChild(
                  document.createElement("div")
                );
                s.textContent = r.value;
              }
        }
        mountStyles() {
          this.styleModules = this.state.facet(Ci);
          let e = this.state.facet(v.cspNonce);
          vt.mount(
            this.root,
            this.styleModules.concat(dp).reverse(),
            e ? { nonce: e } : void 0
          );
        }
        readMeasured() {
          if (this.updateState == 2)
            throw new Error(
              "Reading the editor layout isn't allowed during an update"
            );
          this.updateState == 0 &&
            this.measureScheduled > -1 &&
            this.measure(!1);
        }
        requestMeasure(e) {
          if (
            (this.measureScheduled < 0 &&
              (this.measureScheduled = this.win.requestAnimationFrame(() =>
                this.measure()
              )),
            e)
          ) {
            if (this.measureRequests.indexOf(e) > -1) return;
            if (e.key != null) {
              for (let t = 0; t < this.measureRequests.length; t++)
                if (this.measureRequests[t].key === e.key) {
                  this.measureRequests[t] = e;
                  return;
                }
            }
            this.measureRequests.push(e);
          }
        }
        plugin(e) {
          let t = this.pluginMap.get(e);
          return (
            (t === void 0 || (t && t.plugin != e)) &&
              this.pluginMap.set(
                e,
                (t = this.plugins.find((i) => i.plugin == e) || null)
              ),
            t && t.update(this).value
          );
        }
        get documentTop() {
          return (
            this.contentDOM.getBoundingClientRect().top +
            this.viewState.paddingTop
          );
        }
        get documentPadding() {
          return {
            top: this.viewState.paddingTop,
            bottom: this.viewState.paddingBottom,
          };
        }
        get scaleX() {
          return this.viewState.scaleX;
        }
        get scaleY() {
          return this.viewState.scaleY;
        }
        elementAtHeight(e) {
          return this.readMeasured(), this.viewState.elementAtHeight(e);
        }
        lineBlockAtHeight(e) {
          return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
        }
        get viewportLineBlocks() {
          return this.viewState.viewportLines;
        }
        lineBlockAt(e) {
          return this.viewState.lineBlockAt(e);
        }
        get contentHeight() {
          return this.viewState.contentHeight;
        }
        moveByChar(e, t, i) {
          return Jr(this, e, ql(this, e, t, i));
        }
        moveByGroup(e, t) {
          return Jr(
            this,
            e,
            ql(this, e, t, (i) => CO(this, e.head, i))
          );
        }
        visualLineSide(e, t) {
          let i = this.bidiSpans(e),
            r = this.textDirectionAt(e.from),
            s = i[t ? i.length - 1 : 0];
          return S.cursor(s.side(t, r) + e.from, s.forward(!t, r) ? 1 : -1);
        }
        moveToLineBoundary(e, t, i = !0) {
          return TO(this, e, t, i);
        }
        moveVertically(e, t, i) {
          return Jr(this, e, ZO(this, e, t, i));
        }
        domAtPos(e) {
          return this.docView.domAtPos(e);
        }
        posAtDOM(e, t = 0) {
          return this.docView.posFromDOM(e, t);
        }
        posAtCoords(e, t = !0) {
          return this.readMeasured(), Wc(this, e, t);
        }
        coordsAtPos(e, t = 1) {
          this.readMeasured();
          let i = this.docView.coordsAt(e, t);
          if (!i || i.left == i.right) return i;
          let r = this.state.doc.lineAt(e),
            s = this.bidiSpans(r),
            o = s[$t.find(s, e - r.from, -1, t)];
          return Zr(i, (o.dir == F.LTR) == t > 0);
        }
        coordsForChar(e) {
          return this.readMeasured(), this.docView.coordsForChar(e);
        }
        get defaultCharacterWidth() {
          return this.viewState.heightOracle.charWidth;
        }
        get defaultLineHeight() {
          return this.viewState.heightOracle.lineHeight;
        }
        get textDirection() {
          return this.viewState.defaultTextDirection;
        }
        textDirectionAt(e) {
          return !this.state.facet(Rc) ||
            e < this.viewport.from ||
            e > this.viewport.to
            ? this.textDirection
            : (this.readMeasured(), this.docView.textDirectionAt(e));
        }
        get lineWrapping() {
          return this.viewState.heightOracle.lineWrapping;
        }
        bidiSpans(e) {
          if (e.length > Qp) return $c(e.length);
          let t = this.textDirectionAt(e.from),
            i;
          for (let s of this.bidiCache)
            if (
              s.from == e.from &&
              s.dir == t &&
              (s.fresh || kc(s.isolates, (i = Yl(this, e))))
            )
              return s.order;
          i || (i = Yl(this, e));
          let r = uO(e.text, t, i);
          return this.bidiCache.push(new sr(e.from, e.to, t, i, !0, r)), r;
        }
        get hasFocus() {
          var e;
          return (
            (this.dom.ownerDocument.hasFocus() ||
              (T.safari &&
                ((e = this.inputState) === null || e === void 0
                  ? void 0
                  : e.lastContextMenu) >
                  Date.now() - 3e4)) &&
            this.root.activeElement == this.contentDOM
          );
        }
        focus() {
          this.observer.ignore(() => {
            ac(this.contentDOM), this.docView.updateSelection();
          });
        }
        setRoot(e) {
          this._root != e &&
            ((this._root = e),
            this.observer.setWindow(
              (e.nodeType == 9 ? e : e.ownerDocument).defaultView || window
            ),
            this.mountStyles());
        }
        destroy() {
          this.root.activeElement == this.contentDOM && this.contentDOM.blur();
          for (let e of this.plugins) e.destroy(this);
          (this.plugins = []),
            this.inputState.destroy(),
            this.docView.destroy(),
            this.dom.remove(),
            this.observer.destroy(),
            this.measureScheduled > -1 &&
              this.win.cancelAnimationFrame(this.measureScheduled),
            (this.destroyed = !0);
        }
        static scrollIntoView(e, t = {}) {
          return Sn.of(
            new ii(
              typeof e == "number" ? S.cursor(e) : e,
              t.y,
              t.x,
              t.yMargin,
              t.xMargin
            )
          );
        }
        scrollSnapshot() {
          let { scrollTop: e, scrollLeft: t } = this.scrollDOM,
            i = this.viewState.scrollAnchorAt(e);
          return Sn.of(
            new ii(S.cursor(i.from), "start", "start", i.top - e, t, !0)
          );
        }
        setTabFocusMode(e) {
          e == null
            ? (this.inputState.tabFocusMode =
                this.inputState.tabFocusMode < 0 ? 0 : -1)
            : typeof e == "boolean"
            ? (this.inputState.tabFocusMode = e ? 0 : -1)
            : this.inputState.tabFocusMode != 0 &&
              (this.inputState.tabFocusMode = Date.now() + e);
        }
        static domEventHandlers(e) {
          return ne.define(() => ({}), { eventHandlers: e });
        }
        static domEventObservers(e) {
          return ne.define(() => ({}), { eventObservers: e });
        }
        static theme(e, t) {
          let i = vt.newName(),
            r = [$n.of(i), Ci.of(oo(`.${i}`, e))];
          return t && t.dark && r.push(ro.of(!0)), r;
        }
        static baseTheme(e) {
          return Xt.lowest(Ci.of(oo("." + so, e, nf)));
        }
        static findFromDOM(e) {
          var t;
          let i = e.querySelector(".cm-content"),
            r = (i && I.get(i)) || I.get(e);
          return (
            ((t = r?.rootView) === null || t === void 0 ? void 0 : t.view) ||
            null
          );
        }
      }
      v.styleModule = Ci;
      v.inputHandler = Ac;
      v.clipboardInputFilter = Yo;
      v.clipboardOutputFilter = zo;
      v.scrollHandler = Yc;
      v.focusChangeEffect = Xc;
      v.perLineTextDirection = Rc;
      v.exceptionSink = Zc;
      v.updateListener = eo;
      v.editable = ut;
      v.mouseSelectionStyle = Cc;
      v.dragMovesSelection = Tc;
      v.clickAddsSelectionRange = vc;
      v.decorations = Bi;
      v.outerDecorations = Ec;
      v.atomicRanges = Xr;
      v.bidiIsolatedRanges = _c;
      v.scrollMargins = Vc;
      v.darkTheme = ro;
      v.cspNonce = C.define({ combine: (n) => (n.length ? n[0] : "") });
      v.contentAttributes = Do;
      v.editorAttributes = Dc;
      v.lineWrapping = v.contentAttributes.of({ class: "cm-lineWrapping" });
      v.announce = R.define();
      const Qp = 4096,
        sa = {};
      class sr {
        constructor(e, t, i, r, s, o) {
          (this.from = e),
            (this.to = t),
            (this.dir = i),
            (this.isolates = r),
            (this.fresh = s),
            (this.order = o);
        }
        static update(e, t) {
          if (t.empty && !e.some((s) => s.fresh)) return e;
          let i = [],
            r = e.length ? e[e.length - 1].dir : F.LTR;
          for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
            let o = e[s];
            o.dir == r &&
              !t.touchesRange(o.from, o.to) &&
              i.push(
                new sr(
                  t.mapPos(o.from, 1),
                  t.mapPos(o.to, -1),
                  o.dir,
                  o.isolates,
                  !1,
                  o.order
                )
              );
          }
          return i;
        }
      }
      function oa(n, e, t) {
        for (let i = n.state.facet(e), r = i.length - 1; r >= 0; r--) {
          let s = i[r],
            o = typeof s == "function" ? s(n) : s;
          o && Ns(o, t);
        }
        return t;
      }
      const Sp = T.mac ? "mac" : T.windows ? "win" : T.linux ? "linux" : "key";
      function yp(n, e) {
        const t = n.split(/-(?!$)/);
        let i = t[t.length - 1];
        i == "Space" && (i = " ");
        let r, s, o, l;
        for (let a = 0; a < t.length - 1; ++a) {
          const h = t[a];
          if (/^(cmd|meta|m)$/i.test(h)) l = !0;
          else if (/^a(lt)?$/i.test(h)) r = !0;
          else if (/^(c|ctrl|control)$/i.test(h)) s = !0;
          else if (/^s(hift)?$/i.test(h)) o = !0;
          else if (/^mod$/i.test(h)) e == "mac" ? (l = !0) : (s = !0);
          else throw new Error("Unrecognized modifier name: " + h);
        }
        return (
          r && (i = "Alt-" + i),
          s && (i = "Ctrl-" + i),
          l && (i = "Meta-" + i),
          o && (i = "Shift-" + i),
          i
        );
      }
      function Pn(n, e, t) {
        return (
          e.altKey && (n = "Alt-" + n),
          e.ctrlKey && (n = "Ctrl-" + n),
          e.metaKey && (n = "Meta-" + n),
          t !== !1 && e.shiftKey && (n = "Shift-" + n),
          n
        );
      }
      const bp = Xt.default(
          v.domEventHandlers({
            keydown(n, e) {
              return sf(rf(e.state), n, e, "editor");
            },
          })
        ),
        Mr = C.define({ enables: bp }),
        la = new WeakMap();
      function rf(n) {
        let e = n.facet(Mr),
          t = la.get(e);
        return t || la.set(e, (t = kp(e.reduce((i, r) => i.concat(r), [])))), t;
      }
      function xp(n, e, t) {
        return sf(rf(n.state), e, n, t);
      }
      let xt = null;
      const wp = 4e3;
      function kp(n, e = Sp) {
        let t = Object.create(null),
          i = Object.create(null),
          r = (o, l) => {
            let a = i[o];
            if (a == null) i[o] = l;
            else if (a != l)
              throw new Error(
                "Key binding " +
                  o +
                  " is used both as a regular binding and as a multi-stroke prefix"
              );
          },
          s = (o, l, a, h, c) => {
            var f, u;
            let d = t[o] || (t[o] = Object.create(null)),
              O = l.split(/ (?!$)/).map((Q) => yp(Q, e));
            for (let Q = 1; Q < O.length; Q++) {
              let y = O.slice(0, Q).join(" ");
              r(y, !0),
                d[y] ||
                  (d[y] = {
                    preventDefault: !0,
                    stopPropagation: !1,
                    run: [
                      (x) => {
                        let k = (xt = { view: x, prefix: y, scope: o });
                        return (
                          setTimeout(() => {
                            xt == k && (xt = null);
                          }, wp),
                          !0
                        );
                      },
                    ],
                  });
            }
            let m = O.join(" ");
            r(m, !1);
            let g =
              d[m] ||
              (d[m] = {
                preventDefault: !1,
                stopPropagation: !1,
                run:
                  ((u =
                    (f = d._any) === null || f === void 0 ? void 0 : f.run) ===
                    null || u === void 0
                    ? void 0
                    : u.slice()) || [],
              });
            a && g.run.push(a),
              h && (g.preventDefault = !0),
              c && (g.stopPropagation = !0);
          };
        for (let o of n) {
          let l = o.scope ? o.scope.split(" ") : ["editor"];
          if (o.any)
            for (let h of l) {
              let c = t[h] || (t[h] = Object.create(null));
              c._any ||
                (c._any = { preventDefault: !1, stopPropagation: !1, run: [] });
              let { any: f } = o;
              for (let u in c) c[u].run.push((d) => f(d, lo));
            }
          let a = o[e] || o.key;
          if (a)
            for (let h of l)
              s(h, a, o.run, o.preventDefault, o.stopPropagation),
                o.shift &&
                  s(
                    h,
                    "Shift-" + a,
                    o.shift,
                    o.preventDefault,
                    o.stopPropagation
                  );
        }
        return t;
      }
      let lo = null;
      function sf(n, e, t, i) {
        lo = e;
        let r = Id(e),
          s = be(r, 0),
          o = Je(s) == r.length && r != " ",
          l = "",
          a = !1,
          h = !1,
          c = !1;
        xt &&
          xt.view == t &&
          xt.scope == i &&
          ((l = xt.prefix + " "),
          Ic.indexOf(e.keyCode) < 0 && ((h = !0), (xt = null)));
        let f = new Set(),
          u = (g) => {
            if (g) {
              for (let Q of g.run)
                if (!f.has(Q) && (f.add(Q), Q(t)))
                  return g.stopPropagation && (c = !0), !0;
              g.preventDefault && (g.stopPropagation && (c = !0), (h = !0));
            }
            return !1;
          },
          d = n[i],
          O,
          m;
        return (
          d &&
            (u(d[l + Pn(r, e, !o)])
              ? (a = !0)
              : o &&
                (e.altKey || e.metaKey || e.ctrlKey) &&
                !(T.windows && e.ctrlKey && e.altKey) &&
                !(T.mac && e.altKey && !(e.ctrlKey || e.metaKey)) &&
                (O = Tt[e.keyCode]) &&
                O != r
              ? (u(d[l + Pn(O, e, !0)]) ||
                  (e.shiftKey &&
                    (m = Wi[e.keyCode]) != r &&
                    m != O &&
                    u(d[l + Pn(m, e, !1)]))) &&
                (a = !0)
              : o && e.shiftKey && u(d[l + Pn(r, e, !0)]) && (a = !0),
            !a && u(d._any) && (a = !0)),
          h && (a = !0),
          a && c && e.stopPropagation(),
          (lo = null),
          a
        );
      }
      class an {
        constructor(e, t, i, r, s) {
          (this.className = e),
            (this.left = t),
            (this.top = i),
            (this.width = r),
            (this.height = s);
        }
        draw() {
          let e = document.createElement("div");
          return (e.className = this.className), this.adjust(e), e;
        }
        update(e, t) {
          return t.className != this.className ? !1 : (this.adjust(e), !0);
        }
        adjust(e) {
          (e.style.left = this.left + "px"),
            (e.style.top = this.top + "px"),
            this.width != null && (e.style.width = this.width + "px"),
            (e.style.height = this.height + "px");
        }
        eq(e) {
          return (
            this.left == e.left &&
            this.top == e.top &&
            this.width == e.width &&
            this.height == e.height &&
            this.className == e.className
          );
        }
        static forRange(e, t, i) {
          if (i.empty) {
            let r = e.coordsAtPos(i.head, i.assoc || 1);
            if (!r) return [];
            let s = of(e);
            return [
              new an(t, r.left - s.left, r.top - s.top, null, r.bottom - r.top),
            ];
          } else return $p(e, t, i);
        }
      }
      function of(n) {
        let e = n.scrollDOM.getBoundingClientRect();
        return {
          left:
            (n.textDirection == F.LTR
              ? e.left
              : e.right - n.scrollDOM.clientWidth * n.scaleX) -
            n.scrollDOM.scrollLeft * n.scaleX,
          top: e.top - n.scrollDOM.scrollTop * n.scaleY,
        };
      }
      function aa(n, e, t, i) {
        let r = n.coordsAtPos(e, t * 2);
        if (!r) return i;
        let s = n.dom.getBoundingClientRect(),
          o = (r.top + r.bottom) / 2,
          l = n.posAtCoords({ x: s.left + 1, y: o }),
          a = n.posAtCoords({ x: s.right - 1, y: o });
        return l == null || a == null
          ? i
          : {
              from: Math.max(i.from, Math.min(l, a)),
              to: Math.min(i.to, Math.max(l, a)),
            };
      }
      function $p(n, e, t) {
        if (t.to <= n.viewport.from || t.from >= n.viewport.to) return [];
        let i = Math.max(t.from, n.viewport.from),
          r = Math.min(t.to, n.viewport.to),
          s = n.textDirection == F.LTR,
          o = n.contentDOM,
          l = o.getBoundingClientRect(),
          a = of(n),
          h = o.querySelector(".cm-line"),
          c = h && window.getComputedStyle(h),
          f =
            l.left +
            (c
              ? parseInt(c.paddingLeft) + Math.min(0, parseInt(c.textIndent))
              : 0),
          u = l.right - (c ? parseInt(c.paddingRight) : 0),
          d = io(n, i, 1),
          O = io(n, r, -1),
          m = d.type == ge.Text ? d : null,
          g = O.type == ge.Text ? O : null;
        if (
          (m && (n.lineWrapping || d.widgetLineBreaks) && (m = aa(n, i, 1, m)),
          g && (n.lineWrapping || O.widgetLineBreaks) && (g = aa(n, r, -1, g)),
          m && g && m.from == g.from && m.to == g.to)
        )
          return y(x(t.from, t.to, m));
        {
          let b = m ? x(t.from, null, m) : k(d, !1),
            w = g ? x(null, t.to, g) : k(O, !0),
            P = [];
          return (
            (m || d).to < (g || O).from - (m && g ? 1 : 0) ||
            (d.widgetLineBreaks > 1 &&
              b.bottom + n.defaultLineHeight / 2 < w.top)
              ? P.push(Q(f, b.bottom, u, w.top))
              : b.bottom < w.top &&
                n.elementAtHeight((b.bottom + w.top) / 2).type == ge.Text &&
                (b.bottom = w.top = (b.bottom + w.top) / 2),
            y(b).concat(P).concat(y(w))
          );
        }
        function Q(b, w, P, M) {
          return new an(e, b - a.left, w - a.top, P - b, M - w);
        }
        function y({ top: b, bottom: w, horizontal: P }) {
          let M = [];
          for (let D = 0; D < P.length; D += 2) M.push(Q(P[D], b, P[D + 1], w));
          return M;
        }
        function x(b, w, P) {
          let M = 1e9,
            D = -1e9,
            L = [];
          function z(q, G, me, Pe, Ie) {
            let le = n.coordsAtPos(q, q == P.to ? -2 : 2),
              Re = n.coordsAtPos(me, me == P.from ? 2 : -2);
            !le ||
              !Re ||
              ((M = Math.min(le.top, Re.top, M)),
              (D = Math.max(le.bottom, Re.bottom, D)),
              Ie == F.LTR
                ? L.push(s && G ? f : le.left, s && Pe ? u : Re.right)
                : L.push(!s && Pe ? f : Re.left, !s && G ? u : le.right));
          }
          let X = b ?? P.from,
            W = w ?? P.to;
          for (let q of n.visibleRanges)
            if (q.to > X && q.from < W)
              for (let G = Math.max(q.from, X), me = Math.min(q.to, W); ; ) {
                let Pe = n.state.doc.lineAt(G);
                for (let Ie of n.bidiSpans(Pe)) {
                  let le = Ie.from + Pe.from,
                    Re = Ie.to + Pe.from;
                  if (le >= me) break;
                  Re > G &&
                    z(
                      Math.max(le, G),
                      b == null && le <= X,
                      Math.min(Re, me),
                      w == null && Re >= W,
                      Ie.dir
                    );
                }
                if (((G = Pe.to + 1), G >= me)) break;
              }
          return (
            L.length == 0 && z(X, b == null, W, w == null, n.textDirection),
            { top: M, bottom: D, horizontal: L }
          );
        }
        function k(b, w) {
          let P = l.top + (w ? b.top : b.bottom);
          return { top: P, bottom: P, horizontal: [] };
        }
      }
      function Pp(n, e) {
        return n.constructor == e.constructor && n.eq(e);
      }
      class vp {
        constructor(e, t) {
          (this.view = e),
            (this.layer = t),
            (this.drawn = []),
            (this.scaleX = 1),
            (this.scaleY = 1),
            (this.measureReq = {
              read: this.measure.bind(this),
              write: this.draw.bind(this),
            }),
            (this.dom = e.scrollDOM.appendChild(document.createElement("div"))),
            this.dom.classList.add("cm-layer"),
            t.above && this.dom.classList.add("cm-layer-above"),
            t.class && this.dom.classList.add(t.class),
            this.scale(),
            this.dom.setAttribute("aria-hidden", "true"),
            this.setOrder(e.state),
            e.requestMeasure(this.measureReq),
            t.mount && t.mount(this.dom, e);
        }
        update(e) {
          e.startState.facet(jn) != e.state.facet(jn) && this.setOrder(e.state),
            (this.layer.update(e, this.dom) || e.geometryChanged) &&
              (this.scale(), e.view.requestMeasure(this.measureReq));
        }
        docViewUpdate(e) {
          this.layer.updateOnDocViewUpdate !== !1 &&
            e.requestMeasure(this.measureReq);
        }
        setOrder(e) {
          let t = 0,
            i = e.facet(jn);
          for (; t < i.length && i[t] != this.layer; ) t++;
          this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - t);
        }
        measure() {
          return this.layer.markers(this.view);
        }
        scale() {
          let { scaleX: e, scaleY: t } = this.view;
          (e != this.scaleX || t != this.scaleY) &&
            ((this.scaleX = e),
            (this.scaleY = t),
            (this.dom.style.transform = `scale(${1 / e}, ${1 / t})`));
        }
        draw(e) {
          if (
            e.length != this.drawn.length ||
            e.some((t, i) => !Pp(t, this.drawn[i]))
          ) {
            let t = this.dom.firstChild,
              i = 0;
            for (let r of e)
              r.update &&
              t &&
              r.constructor &&
              this.drawn[i].constructor &&
              r.update(t, this.drawn[i])
                ? ((t = t.nextSibling), i++)
                : this.dom.insertBefore(r.draw(), t);
            for (; t; ) {
              let r = t.nextSibling;
              t.remove(), (t = r);
            }
            this.drawn = e;
          }
        }
        destroy() {
          this.layer.destroy && this.layer.destroy(this.dom, this.view),
            this.dom.remove();
        }
      }
      const jn = C.define();
      function lf(n) {
        return [ne.define((e) => new vp(e, n)), jn.of(n)];
      }
      const Ii = C.define({
        combine(n) {
          return lt(
            n,
            { cursorBlinkRate: 1200, drawRangeCursor: !0 },
            {
              cursorBlinkRate: (e, t) => Math.min(e, t),
              drawRangeCursor: (e, t) => e || t,
            }
          );
        },
      });
      function Tp(n = {}) {
        return [Ii.of(n), Cp, Zp, Ap, Mc.of(!0)];
      }
      function af(n) {
        return n.startState.facet(Ii) != n.state.facet(Ii);
      }
      const Cp = lf({
        above: !0,
        markers(n) {
          let { state: e } = n,
            t = e.facet(Ii),
            i = [];
          for (let r of e.selection.ranges) {
            let s = r == e.selection.main;
            if (r.empty || t.drawRangeCursor) {
              let o = s
                  ? "cm-cursor cm-cursor-primary"
                  : "cm-cursor cm-cursor-secondary",
                l = r.empty ? r : S.cursor(r.head, r.head > r.anchor ? -1 : 1);
              for (let a of an.forRange(n, o, l)) i.push(a);
            }
          }
          return i;
        },
        update(n, e) {
          n.transactions.some((i) => i.selection) &&
            (e.style.animationName =
              e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
          let t = af(n);
          return t && ha(n.state, e), n.docChanged || n.selectionSet || t;
        },
        mount(n, e) {
          ha(e.state, n);
        },
        class: "cm-cursorLayer",
      });
      function ha(n, e) {
        e.style.animationDuration = n.facet(Ii).cursorBlinkRate + "ms";
      }
      const Zp = lf({
          above: !1,
          markers(n) {
            return n.state.selection.ranges
              .map((e) =>
                e.empty ? [] : an.forRange(n, "cm-selectionBackground", e)
              )
              .reduce((e, t) => e.concat(t));
          },
          update(n, e) {
            return n.docChanged || n.selectionSet || n.viewportChanged || af(n);
          },
          class: "cm-selectionLayer",
        }),
        Ap = Xt.highest(
          v.theme({
            ".cm-line": {
              "& ::selection, &::selection": {
                backgroundColor: "transparent !important",
              },
              caretColor: "transparent !important",
            },
            ".cm-content": {
              caretColor: "transparent !important",
              "& :focus": {
                caretColor: "initial !important",
                "&::selection, & ::selection": {
                  backgroundColor: "Highlight !important",
                },
              },
            },
          })
        ),
        hf = R.define({
          map(n, e) {
            return n == null ? null : e.mapPos(n);
          },
        }),
        Xi = oe.define({
          create() {
            return null;
          },
          update(n, e) {
            return (
              n != null && (n = e.changes.mapPos(n)),
              e.effects.reduce((t, i) => (i.is(hf) ? i.value : t), n)
            );
          },
        }),
        Xp = ne.fromClass(
          class {
            constructor(n) {
              (this.view = n),
                (this.cursor = null),
                (this.measureReq = {
                  read: this.readPos.bind(this),
                  write: this.drawCursor.bind(this),
                });
            }
            update(n) {
              var e;
              let t = n.state.field(Xi);
              t == null
                ? this.cursor != null &&
                  ((e = this.cursor) === null || e === void 0 || e.remove(),
                  (this.cursor = null))
                : (this.cursor ||
                    ((this.cursor = this.view.scrollDOM.appendChild(
                      document.createElement("div")
                    )),
                    (this.cursor.className = "cm-dropCursor")),
                  (n.startState.field(Xi) != t ||
                    n.docChanged ||
                    n.geometryChanged) &&
                    this.view.requestMeasure(this.measureReq));
            }
            readPos() {
              let { view: n } = this,
                e = n.state.field(Xi),
                t = e != null && n.coordsAtPos(e);
              if (!t) return null;
              let i = n.scrollDOM.getBoundingClientRect();
              return {
                left: t.left - i.left + n.scrollDOM.scrollLeft * n.scaleX,
                top: t.top - i.top + n.scrollDOM.scrollTop * n.scaleY,
                height: t.bottom - t.top,
              };
            }
            drawCursor(n) {
              if (this.cursor) {
                let { scaleX: e, scaleY: t } = this.view;
                n
                  ? ((this.cursor.style.left = n.left / e + "px"),
                    (this.cursor.style.top = n.top / t + "px"),
                    (this.cursor.style.height = n.height / t + "px"))
                  : (this.cursor.style.left = "-100000px");
              }
            }
            destroy() {
              this.cursor && this.cursor.remove();
            }
            setDropPos(n) {
              this.view.state.field(Xi) != n &&
                this.view.dispatch({ effects: hf.of(n) });
            }
          },
          {
            eventObservers: {
              dragover(n) {
                this.setDropPos(
                  this.view.posAtCoords({ x: n.clientX, y: n.clientY })
                );
              },
              dragleave(n) {
                (n.target == this.view.contentDOM ||
                  !this.view.contentDOM.contains(n.relatedTarget)) &&
                  this.setDropPos(null);
              },
              dragend() {
                this.setDropPos(null);
              },
              drop() {
                this.setDropPos(null);
              },
            },
          }
        );
      function Rp() {
        return [Xi, Xp];
      }
      function ca(n, e, t, i, r) {
        e.lastIndex = 0;
        for (
          let s = n.iterRange(t, i), o = t, l;
          !s.next().done;
          o += s.value.length
        )
          if (!s.lineBreak) for (; (l = e.exec(s.value)); ) r(o + l.index, l);
      }
      function Mp(n, e) {
        let t = n.visibleRanges;
        if (
          t.length == 1 &&
          t[0].from == n.viewport.from &&
          t[0].to == n.viewport.to
        )
          return t;
        let i = [];
        for (let { from: r, to: s } of t)
          (r = Math.max(n.state.doc.lineAt(r).from, r - e)),
            (s = Math.min(n.state.doc.lineAt(s).to, s + e)),
            i.length && i[i.length - 1].to >= r
              ? (i[i.length - 1].to = s)
              : i.push({ from: r, to: s });
        return i;
      }
      class Yp {
        constructor(e) {
          const {
            regexp: t,
            decoration: i,
            decorate: r,
            boundary: s,
            maxLength: o = 1e3,
          } = e;
          if (!t.global)
            throw new RangeError(
              "The regular expression given to MatchDecorator should have its 'g' flag set"
            );
          if (((this.regexp = t), r))
            this.addMatch = (l, a, h, c) => r(c, h, h + l[0].length, l, a);
          else if (typeof i == "function")
            this.addMatch = (l, a, h, c) => {
              let f = i(l, a, h);
              f && c(h, h + l[0].length, f);
            };
          else if (i) this.addMatch = (l, a, h, c) => c(h, h + l[0].length, i);
          else
            throw new RangeError(
              "Either 'decorate' or 'decoration' should be provided to MatchDecorator"
            );
          (this.boundary = s), (this.maxLength = o);
        }
        createDeco(e) {
          let t = new pt(),
            i = t.add.bind(t);
          for (let { from: r, to: s } of Mp(e, this.maxLength))
            ca(e.state.doc, this.regexp, r, s, (o, l) =>
              this.addMatch(l, e, o, i)
            );
          return t.finish();
        }
        updateDeco(e, t) {
          let i = 1e9,
            r = -1;
          return (
            e.docChanged &&
              e.changes.iterChanges((s, o, l, a) => {
                a >= e.view.viewport.from &&
                  l <= e.view.viewport.to &&
                  ((i = Math.min(l, i)), (r = Math.max(a, r)));
              }),
            e.viewportMoved || r - i > 1e3
              ? this.createDeco(e.view)
              : r > -1
              ? this.updateRange(e.view, t.map(e.changes), i, r)
              : t
          );
        }
        updateRange(e, t, i, r) {
          for (let s of e.visibleRanges) {
            let o = Math.max(s.from, i),
              l = Math.min(s.to, r);
            if (l >= o) {
              let a = e.state.doc.lineAt(o),
                h = a.to < l ? e.state.doc.lineAt(l) : a,
                c = Math.max(s.from, a.from),
                f = Math.min(s.to, h.to);
              if (this.boundary) {
                for (; o > a.from; o--)
                  if (this.boundary.test(a.text[o - 1 - a.from])) {
                    c = o;
                    break;
                  }
                for (; l < h.to; l++)
                  if (this.boundary.test(h.text[l - h.from])) {
                    f = l;
                    break;
                  }
              }
              let u = [],
                d,
                O = (m, g, Q) => u.push(Q.range(m, g));
              if (a == h)
                for (
                  this.regexp.lastIndex = c - a.from;
                  (d = this.regexp.exec(a.text)) && d.index < f - a.from;

                )
                  this.addMatch(d, e, d.index + a.from, O);
              else
                ca(e.state.doc, this.regexp, c, f, (m, g) =>
                  this.addMatch(g, e, m, O)
                );
              t = t.update({
                filterFrom: c,
                filterTo: f,
                filter: (m, g) => m < c || g > f,
                add: u,
              });
            }
          }
          return t;
        }
      }
      const ao = /x/.unicode != null ? "gu" : "g",
        zp = new RegExp(
          `[\0-\b
--\u2028\u2029\uFEFF-]`,
          ao
        ),
        Dp = {
          0: "null",
          7: "bell",
          8: "backspace",
          10: "newline",
          11: "vertical tab",
          13: "carriage return",
          27: "escape",
          8203: "zero width space",
          8204: "zero width non-joiner",
          8205: "zero width joiner",
          8206: "left-to-right mark",
          8207: "right-to-left mark",
          8232: "line separator",
          8237: "left-to-right override",
          8238: "right-to-left override",
          8294: "left-to-right isolate",
          8295: "right-to-left isolate",
          8297: "pop directional isolate",
          8233: "paragraph separator",
          65279: "zero width no-break space",
          65532: "object replacement",
        };
      let is = null;
      function Ep() {
        var n;
        if (is == null && typeof document < "u" && document.body) {
          let e = document.body.style;
          is =
            ((n = e.tabSize) !== null && n !== void 0 ? n : e.MozTabSize) !=
            null;
        }
        return is || !1;
      }
      const Bn = C.define({
        combine(n) {
          let e = lt(n, {
            render: null,
            specialChars: zp,
            addSpecialChars: null,
          });
          return (
            (e.replaceTabs = !Ep()) &&
              (e.specialChars = new RegExp("	|" + e.specialChars.source, ao)),
            e.addSpecialChars &&
              (e.specialChars = new RegExp(
                e.specialChars.source + "|" + e.addSpecialChars.source,
                ao
              )),
            e
          );
        },
      });
      function _p(n = {}) {
        return [Bn.of(n), Vp()];
      }
      let fa = null;
      function Vp() {
        return (
          fa ||
          (fa = ne.fromClass(
            class {
              constructor(n) {
                (this.view = n),
                  (this.decorations = A.none),
                  (this.decorationCache = Object.create(null)),
                  (this.decorator = this.makeDecorator(n.state.facet(Bn))),
                  (this.decorations = this.decorator.createDeco(n));
              }
              makeDecorator(n) {
                return new Yp({
                  regexp: n.specialChars,
                  decoration: (e, t, i) => {
                    let { doc: r } = t.state,
                      s = be(e[0], 0);
                    if (s == 9) {
                      let o = r.lineAt(i),
                        l = t.state.tabSize,
                        a = gi(o.text, l, i - o.from);
                      return A.replace({
                        widget: new jp(
                          ((l - (a % l)) * this.view.defaultCharacterWidth) /
                            this.view.scaleX
                        ),
                      });
                    }
                    return (
                      this.decorationCache[s] ||
                      (this.decorationCache[s] = A.replace({
                        widget: new Lp(n, s),
                      }))
                    );
                  },
                  boundary: n.replaceTabs ? void 0 : /[^]/,
                });
              }
              update(n) {
                let e = n.state.facet(Bn);
                n.startState.facet(Bn) != e
                  ? ((this.decorator = this.makeDecorator(e)),
                    (this.decorations = this.decorator.createDeco(n.view)))
                  : (this.decorations = this.decorator.updateDeco(
                      n,
                      this.decorations
                    ));
              }
            },
            { decorations: (n) => n.decorations }
          ))
        );
      }
      const qp = "";
      function Wp(n) {
        return n >= 32 ? qp : n == 10 ? "" : String.fromCharCode(9216 + n);
      }
      class Lp extends St {
        constructor(e, t) {
          super(), (this.options = e), (this.code = t);
        }
        eq(e) {
          return e.code == this.code;
        }
        toDOM(e) {
          let t = Wp(this.code),
            i =
              e.state.phrase("Control character") +
              " " +
              (Dp[this.code] || "0x" + this.code.toString(16)),
            r = this.options.render && this.options.render(this.code, i, t);
          if (r) return r;
          let s = document.createElement("span");
          return (
            (s.textContent = t),
            (s.title = i),
            s.setAttribute("aria-label", i),
            (s.className = "cm-specialChar"),
            s
          );
        }
        ignoreEvent() {
          return !1;
        }
      }
      class jp extends St {
        constructor(e) {
          super(), (this.width = e);
        }
        eq(e) {
          return e.width == this.width;
        }
        toDOM() {
          let e = document.createElement("span");
          return (
            (e.textContent = "	"),
            (e.className = "cm-tab"),
            (e.style.width = this.width + "px"),
            e
          );
        }
        ignoreEvent() {
          return !1;
        }
      }
      function Bp() {
        return Gp;
      }
      const Ip = A.line({ class: "cm-activeLine" }),
        Gp = ne.fromClass(
          class {
            constructor(n) {
              this.decorations = this.getDeco(n);
            }
            update(n) {
              (n.docChanged || n.selectionSet) &&
                (this.decorations = this.getDeco(n.view));
            }
            getDeco(n) {
              let e = -1,
                t = [];
              for (let i of n.state.selection.ranges) {
                let r = n.lineBlockAt(i.head);
                r.from > e && (t.push(Ip.range(r.from)), (e = r.from));
              }
              return A.set(t);
            }
          },
          { decorations: (n) => n.decorations }
        ),
        ho = 2e3;
      function Np(n, e, t) {
        let i = Math.min(e.line, t.line),
          r = Math.max(e.line, t.line),
          s = [];
        if (e.off > ho || t.off > ho || e.col < 0 || t.col < 0) {
          let o = Math.min(e.off, t.off),
            l = Math.max(e.off, t.off);
          for (let a = i; a <= r; a++) {
            let h = n.doc.line(a);
            h.length <= l && s.push(S.range(h.from + o, h.to + l));
          }
        } else {
          let o = Math.min(e.col, t.col),
            l = Math.max(e.col, t.col);
          for (let a = i; a <= r; a++) {
            let h = n.doc.line(a),
              c = qs(h.text, o, n.tabSize, !0);
            if (c < 0) s.push(S.cursor(h.to));
            else {
              let f = qs(h.text, l, n.tabSize);
              s.push(S.range(h.from + c, h.from + f));
            }
          }
        }
        return s;
      }
      function Up(n, e) {
        let t = n.coordsAtPos(n.viewport.from);
        return t
          ? Math.round(Math.abs((t.left - e) / n.defaultCharacterWidth))
          : -1;
      }
      function ua(n, e) {
        let t = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1),
          i = n.state.doc.lineAt(t),
          r = t - i.from,
          s =
            r > ho
              ? -1
              : r == i.length
              ? Up(n, e.clientX)
              : gi(i.text, n.state.tabSize, t - i.from);
        return { line: i.number, col: s, off: r };
      }
      function Fp(n, e) {
        let t = ua(n, e),
          i = n.state.selection;
        return t
          ? {
              update(r) {
                if (r.docChanged) {
                  let s = r.changes.mapPos(r.startState.doc.line(t.line).from),
                    o = r.state.doc.lineAt(s);
                  (t = {
                    line: o.number,
                    col: t.col,
                    off: Math.min(t.off, o.length),
                  }),
                    (i = i.map(r.changes));
                }
              },
              get(r, s, o) {
                let l = ua(n, r);
                if (!l) return i;
                let a = Np(n.state, t, l);
                return a.length
                  ? o
                    ? S.create(a.concat(i.ranges))
                    : S.create(a)
                  : i;
              },
            }
          : null;
      }
      function Hp(n) {
        let e = (t) => t.altKey && t.button == 0;
        return v.mouseSelectionStyle.of((t, i) => (e(i) ? Fp(t, i) : null));
      }
      const Kp = {
          Alt: [18, (n) => !!n.altKey],
          Control: [17, (n) => !!n.ctrlKey],
          Shift: [16, (n) => !!n.shiftKey],
          Meta: [91, (n) => !!n.metaKey],
        },
        Jp = { style: "cursor: crosshair" };
      function em(n = {}) {
        let [e, t] = Kp[n.key || "Alt"],
          i = ne.fromClass(
            class {
              constructor(r) {
                (this.view = r), (this.isDown = !1);
              }
              set(r) {
                this.isDown != r && ((this.isDown = r), this.view.update([]));
              }
            },
            {
              eventObservers: {
                keydown(r) {
                  this.set(r.keyCode == e || t(r));
                },
                keyup(r) {
                  (r.keyCode == e || !t(r)) && this.set(!1);
                },
                mousemove(r) {
                  this.set(t(r));
                },
              },
            }
          );
        return [
          i,
          v.contentAttributes.of((r) => {
            var s;
            return !((s = r.plugin(i)) === null || s === void 0) && s.isDown
              ? Jp
              : null;
          }),
        ];
      }
      const wi = "-10000px";
      class cf {
        constructor(e, t, i, r) {
          (this.facet = t),
            (this.createTooltipView = i),
            (this.removeTooltipView = r),
            (this.input = e.state.facet(t)),
            (this.tooltips = this.input.filter((o) => o));
          let s = null;
          this.tooltipViews = this.tooltips.map((o) => (s = i(o, s)));
        }
        update(e, t) {
          var i;
          let r = e.state.facet(this.facet),
            s = r.filter((a) => a);
          if (r === this.input) {
            for (let a of this.tooltipViews) a.update && a.update(e);
            return !1;
          }
          let o = [],
            l = t ? [] : null;
          for (let a = 0; a < s.length; a++) {
            let h = s[a],
              c = -1;
            if (h) {
              for (let f = 0; f < this.tooltips.length; f++) {
                let u = this.tooltips[f];
                u && u.create == h.create && (c = f);
              }
              if (c < 0)
                (o[a] = this.createTooltipView(h, a ? o[a - 1] : null)),
                  l && (l[a] = !!h.above);
              else {
                let f = (o[a] = this.tooltipViews[c]);
                l && (l[a] = t[c]), f.update && f.update(e);
              }
            }
          }
          for (let a of this.tooltipViews)
            o.indexOf(a) < 0 &&
              (this.removeTooltipView(a),
              (i = a.destroy) === null || i === void 0 || i.call(a));
          return (
            t && (l.forEach((a, h) => (t[h] = a)), (t.length = l.length)),
            (this.input = r),
            (this.tooltips = s),
            (this.tooltipViews = o),
            !0
          );
        }
      }
      function tm(n) {
        let e = n.dom.ownerDocument.documentElement;
        return {
          top: 0,
          left: 0,
          bottom: e.clientHeight,
          right: e.clientWidth,
        };
      }
      const ns = C.define({
          combine: (n) => {
            var e, t, i;
            return {
              position: T.ios
                ? "absolute"
                : ((e = n.find((r) => r.position)) === null || e === void 0
                    ? void 0
                    : e.position) || "fixed",
              parent:
                ((t = n.find((r) => r.parent)) === null || t === void 0
                  ? void 0
                  : t.parent) || null,
              tooltipSpace:
                ((i = n.find((r) => r.tooltipSpace)) === null || i === void 0
                  ? void 0
                  : i.tooltipSpace) || tm,
            };
          },
        }),
        da = new WeakMap(),
        Wo = ne.fromClass(
          class {
            constructor(n) {
              (this.view = n),
                (this.above = []),
                (this.inView = !0),
                (this.madeAbsolute = !1),
                (this.lastTransaction = 0),
                (this.measureTimeout = -1);
              let e = n.state.facet(ns);
              (this.position = e.position),
                (this.parent = e.parent),
                (this.classes = n.themeClasses),
                this.createContainer(),
                (this.measureReq = {
                  read: this.readMeasure.bind(this),
                  write: this.writeMeasure.bind(this),
                  key: this,
                }),
                (this.resizeObserver =
                  typeof ResizeObserver == "function"
                    ? new ResizeObserver(() => this.measureSoon())
                    : null),
                (this.manager = new cf(
                  n,
                  Lo,
                  (t, i) => this.createTooltip(t, i),
                  (t) => {
                    this.resizeObserver && this.resizeObserver.unobserve(t.dom),
                      t.dom.remove();
                  }
                )),
                (this.above = this.manager.tooltips.map((t) => !!t.above)),
                (this.intersectionObserver =
                  typeof IntersectionObserver == "function"
                    ? new IntersectionObserver(
                        (t) => {
                          Date.now() > this.lastTransaction - 50 &&
                            t.length > 0 &&
                            t[t.length - 1].intersectionRatio < 1 &&
                            this.measureSoon();
                        },
                        { threshold: [1] }
                      )
                    : null),
                this.observeIntersection(),
                n.win.addEventListener(
                  "resize",
                  (this.measureSoon = this.measureSoon.bind(this))
                ),
                this.maybeMeasure();
            }
            createContainer() {
              this.parent
                ? ((this.container = document.createElement("div")),
                  (this.container.style.position = "relative"),
                  (this.container.className = this.view.themeClasses),
                  this.parent.appendChild(this.container))
                : (this.container = this.view.dom);
            }
            observeIntersection() {
              if (this.intersectionObserver) {
                this.intersectionObserver.disconnect();
                for (let n of this.manager.tooltipViews)
                  this.intersectionObserver.observe(n.dom);
              }
            }
            measureSoon() {
              this.measureTimeout < 0 &&
                (this.measureTimeout = setTimeout(() => {
                  (this.measureTimeout = -1), this.maybeMeasure();
                }, 50));
            }
            update(n) {
              n.transactions.length && (this.lastTransaction = Date.now());
              let e = this.manager.update(n, this.above);
              e && this.observeIntersection();
              let t = e || n.geometryChanged,
                i = n.state.facet(ns);
              if (i.position != this.position && !this.madeAbsolute) {
                this.position = i.position;
                for (let r of this.manager.tooltipViews)
                  r.dom.style.position = this.position;
                t = !0;
              }
              if (i.parent != this.parent) {
                this.parent && this.container.remove(),
                  (this.parent = i.parent),
                  this.createContainer();
                for (let r of this.manager.tooltipViews)
                  this.container.appendChild(r.dom);
                t = !0;
              } else
                this.parent &&
                  this.view.themeClasses != this.classes &&
                  (this.classes = this.container.className =
                    this.view.themeClasses);
              t && this.maybeMeasure();
            }
            createTooltip(n, e) {
              let t = n.create(this.view),
                i = e ? e.dom : null;
              if (
                (t.dom.classList.add("cm-tooltip"),
                n.arrow &&
                  !t.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow"))
              ) {
                let r = document.createElement("div");
                (r.className = "cm-tooltip-arrow"), t.dom.appendChild(r);
              }
              return (
                (t.dom.style.position = this.position),
                (t.dom.style.top = wi),
                (t.dom.style.left = "0px"),
                this.container.insertBefore(t.dom, i),
                t.mount && t.mount(this.view),
                this.resizeObserver && this.resizeObserver.observe(t.dom),
                t
              );
            }
            destroy() {
              var n, e, t;
              this.view.win.removeEventListener("resize", this.measureSoon);
              for (let i of this.manager.tooltipViews)
                i.dom.remove(),
                  (n = i.destroy) === null || n === void 0 || n.call(i);
              this.parent && this.container.remove(),
                (e = this.resizeObserver) === null ||
                  e === void 0 ||
                  e.disconnect(),
                (t = this.intersectionObserver) === null ||
                  t === void 0 ||
                  t.disconnect(),
                clearTimeout(this.measureTimeout);
            }
            readMeasure() {
              let n = 1,
                e = 1,
                t = !1;
              if (
                this.position == "fixed" &&
                this.manager.tooltipViews.length
              ) {
                let { dom: s } = this.manager.tooltipViews[0];
                if (T.gecko)
                  t = s.offsetParent != this.container.ownerDocument.body;
                else if (s.style.top == wi && s.style.left == "0px") {
                  let o = s.getBoundingClientRect();
                  t = Math.abs(o.top + 1e4) > 1 || Math.abs(o.left) > 1;
                }
              }
              if (t || this.position == "absolute")
                if (this.parent) {
                  let s = this.parent.getBoundingClientRect();
                  s.width &&
                    s.height &&
                    ((n = s.width / this.parent.offsetWidth),
                    (e = s.height / this.parent.offsetHeight));
                } else ({ scaleX: n, scaleY: e } = this.view.viewState);
              let i = this.view.scrollDOM.getBoundingClientRect(),
                r = Eo(this.view);
              return {
                visible: {
                  left: i.left + r.left,
                  top: i.top + r.top,
                  right: i.right - r.right,
                  bottom: i.bottom - r.bottom,
                },
                parent: this.parent
                  ? this.container.getBoundingClientRect()
                  : this.view.dom.getBoundingClientRect(),
                pos: this.manager.tooltips.map((s, o) => {
                  let l = this.manager.tooltipViews[o];
                  return l.getCoords
                    ? l.getCoords(s.pos)
                    : this.view.coordsAtPos(s.pos);
                }),
                size: this.manager.tooltipViews.map(({ dom: s }) =>
                  s.getBoundingClientRect()
                ),
                space: this.view.state.facet(ns).tooltipSpace(this.view),
                scaleX: n,
                scaleY: e,
                makeAbsolute: t,
              };
            }
            writeMeasure(n) {
              var e;
              if (n.makeAbsolute) {
                (this.madeAbsolute = !0), (this.position = "absolute");
                for (let l of this.manager.tooltipViews)
                  l.dom.style.position = "absolute";
              }
              let { visible: t, space: i, scaleX: r, scaleY: s } = n,
                o = [];
              for (let l = 0; l < this.manager.tooltips.length; l++) {
                let a = this.manager.tooltips[l],
                  h = this.manager.tooltipViews[l],
                  { dom: c } = h,
                  f = n.pos[l],
                  u = n.size[l];
                if (
                  !f ||
                  (a.clip !== !1 &&
                    (f.bottom <= Math.max(t.top, i.top) ||
                      f.top >= Math.min(t.bottom, i.bottom) ||
                      f.right < Math.max(t.left, i.left) - 0.1 ||
                      f.left > Math.min(t.right, i.right) + 0.1))
                ) {
                  c.style.top = wi;
                  continue;
                }
                let d = a.arrow
                    ? h.dom.querySelector(".cm-tooltip-arrow")
                    : null,
                  O = d ? 7 : 0,
                  m = u.right - u.left,
                  g =
                    (e = da.get(h)) !== null && e !== void 0
                      ? e
                      : u.bottom - u.top,
                  Q = h.offset || nm,
                  y = this.view.textDirection == F.LTR,
                  x =
                    u.width > i.right - i.left
                      ? y
                        ? i.left
                        : i.right - u.width
                      : y
                      ? Math.max(
                          i.left,
                          Math.min(f.left - (d ? 14 : 0) + Q.x, i.right - m)
                        )
                      : Math.min(
                          Math.max(i.left, f.left - m + (d ? 14 : 0) - Q.x),
                          i.right - m
                        ),
                  k = this.above[l];
                !a.strictSide &&
                  (k
                    ? f.top - g - O - Q.y < i.top
                    : f.bottom + g + O + Q.y > i.bottom) &&
                  k == i.bottom - f.bottom > f.top - i.top &&
                  (k = this.above[l] = !k);
                let b = (k ? f.top - i.top : i.bottom - f.bottom) - O;
                if (b < g && h.resize !== !1) {
                  if (b < this.view.defaultLineHeight) {
                    c.style.top = wi;
                    continue;
                  }
                  da.set(h, g), (c.style.height = (g = b) / s + "px");
                } else c.style.height && (c.style.height = "");
                let w = k ? f.top - g - O - Q.y : f.bottom + O + Q.y,
                  P = x + m;
                if (h.overlap !== !0)
                  for (let M of o)
                    M.left < P &&
                      M.right > x &&
                      M.top < w + g &&
                      M.bottom > w &&
                      (w = k ? M.top - g - 2 - O : M.bottom + O + 2);
                if (
                  (this.position == "absolute"
                    ? ((c.style.top = (w - n.parent.top) / s + "px"),
                      Oa(c, (x - n.parent.left) / r))
                    : ((c.style.top = w / s + "px"), Oa(c, x / r)),
                  d)
                ) {
                  let M = f.left + (y ? Q.x : -Q.x) - (x + 14 - 7);
                  d.style.left = M / r + "px";
                }
                h.overlap !== !0 &&
                  o.push({ left: x, top: w, right: P, bottom: w + g }),
                  c.classList.toggle("cm-tooltip-above", k),
                  c.classList.toggle("cm-tooltip-below", !k),
                  h.positioned && h.positioned(n.space);
              }
            }
            maybeMeasure() {
              if (
                this.manager.tooltips.length &&
                (this.view.inView && this.view.requestMeasure(this.measureReq),
                this.inView != this.view.inView &&
                  ((this.inView = this.view.inView), !this.inView))
              )
                for (let n of this.manager.tooltipViews) n.dom.style.top = wi;
            }
          },
          {
            eventObservers: {
              scroll() {
                this.maybeMeasure();
              },
            },
          }
        );
      function Oa(n, e) {
        let t = parseInt(n.style.left, 10);
        (isNaN(t) || Math.abs(e - t) > 1) && (n.style.left = e + "px");
      }
      const im = v.baseTheme({
          ".cm-tooltip": { zIndex: 500, boxSizing: "border-box" },
          "&light .cm-tooltip": {
            border: "1px solid #bbb",
            backgroundColor: "#f5f5f5",
          },
          "&light .cm-tooltip-section:not(:first-child)": {
            borderTop: "1px solid #bbb",
          },
          "&dark .cm-tooltip": { backgroundColor: "#333338", color: "white" },
          ".cm-tooltip-arrow": {
            height: "7px",
            width: "14px",
            position: "absolute",
            zIndex: -1,
            overflow: "hidden",
            "&:before, &:after": {
              content: "''",
              position: "absolute",
              width: 0,
              height: 0,
              borderLeft: "7px solid transparent",
              borderRight: "7px solid transparent",
            },
            ".cm-tooltip-above &": {
              bottom: "-7px",
              "&:before": { borderTop: "7px solid #bbb" },
              "&:after": { borderTop: "7px solid #f5f5f5", bottom: "1px" },
            },
            ".cm-tooltip-below &": {
              top: "-7px",
              "&:before": { borderBottom: "7px solid #bbb" },
              "&:after": { borderBottom: "7px solid #f5f5f5", top: "1px" },
            },
          },
          "&dark .cm-tooltip .cm-tooltip-arrow": {
            "&:before": {
              borderTopColor: "#333338",
              borderBottomColor: "#333338",
            },
            "&:after": {
              borderTopColor: "transparent",
              borderBottomColor: "transparent",
            },
          },
        }),
        nm = { x: 0, y: 0 },
        Lo = C.define({ enables: [Wo, im] }),
        or = C.define({ combine: (n) => n.reduce((e, t) => e.concat(t), []) });
      class Yr {
        static create(e) {
          return new Yr(e);
        }
        constructor(e) {
          (this.view = e),
            (this.mounted = !1),
            (this.dom = document.createElement("div")),
            this.dom.classList.add("cm-tooltip-hover"),
            (this.manager = new cf(
              e,
              or,
              (t, i) => this.createHostedView(t, i),
              (t) => t.dom.remove()
            ));
        }
        createHostedView(e, t) {
          let i = e.create(this.view);
          return (
            i.dom.classList.add("cm-tooltip-section"),
            this.dom.insertBefore(
              i.dom,
              t ? t.dom.nextSibling : this.dom.firstChild
            ),
            this.mounted && i.mount && i.mount(this.view),
            i
          );
        }
        mount(e) {
          for (let t of this.manager.tooltipViews) t.mount && t.mount(e);
          this.mounted = !0;
        }
        positioned(e) {
          for (let t of this.manager.tooltipViews)
            t.positioned && t.positioned(e);
        }
        update(e) {
          this.manager.update(e);
        }
        destroy() {
          var e;
          for (let t of this.manager.tooltipViews)
            (e = t.destroy) === null || e === void 0 || e.call(t);
        }
        passProp(e) {
          let t;
          for (let i of this.manager.tooltipViews) {
            let r = i[e];
            if (r !== void 0) {
              if (t === void 0) t = r;
              else if (t !== r) return;
            }
          }
          return t;
        }
        get offset() {
          return this.passProp("offset");
        }
        get getCoords() {
          return this.passProp("getCoords");
        }
        get overlap() {
          return this.passProp("overlap");
        }
        get resize() {
          return this.passProp("resize");
        }
      }
      const rm = Lo.compute([or], (n) => {
        let e = n.facet(or);
        return e.length === 0
          ? null
          : {
              pos: Math.min(...e.map((t) => t.pos)),
              end: Math.max(
                ...e.map((t) => {
                  var i;
                  return (i = t.end) !== null && i !== void 0 ? i : t.pos;
                })
              ),
              create: Yr.create,
              above: e[0].above,
              arrow: e.some((t) => t.arrow),
            };
      });
      class sm {
        constructor(e, t, i, r, s) {
          (this.view = e),
            (this.source = t),
            (this.field = i),
            (this.setHover = r),
            (this.hoverTime = s),
            (this.hoverTimeout = -1),
            (this.restartTimeout = -1),
            (this.pending = null),
            (this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }),
            (this.checkHover = this.checkHover.bind(this)),
            e.dom.addEventListener(
              "mouseleave",
              (this.mouseleave = this.mouseleave.bind(this))
            ),
            e.dom.addEventListener(
              "mousemove",
              (this.mousemove = this.mousemove.bind(this))
            );
        }
        update() {
          this.pending &&
            ((this.pending = null),
            clearTimeout(this.restartTimeout),
            (this.restartTimeout = setTimeout(() => this.startHover(), 20)));
        }
        get active() {
          return this.view.state.field(this.field);
        }
        checkHover() {
          if (((this.hoverTimeout = -1), this.active.length)) return;
          let e = Date.now() - this.lastMove.time;
          e < this.hoverTime
            ? (this.hoverTimeout = setTimeout(
                this.checkHover,
                this.hoverTime - e
              ))
            : this.startHover();
        }
        startHover() {
          clearTimeout(this.restartTimeout);
          let { view: e, lastMove: t } = this,
            i = e.docView.nearest(t.target);
          if (!i) return;
          let r,
            s = 1;
          if (i instanceof kt) r = i.posAtStart;
          else {
            if (((r = e.posAtCoords(t)), r == null)) return;
            let l = e.coordsAtPos(r);
            if (
              !l ||
              t.y < l.top ||
              t.y > l.bottom ||
              t.x < l.left - e.defaultCharacterWidth ||
              t.x > l.right + e.defaultCharacterWidth
            )
              return;
            let a = e
                .bidiSpans(e.state.doc.lineAt(r))
                .find((c) => c.from <= r && c.to >= r),
              h = a && a.dir == F.RTL ? -1 : 1;
            s = t.x < l.left ? -h : h;
          }
          let o = this.source(e, r, s);
          if (o?.then) {
            let l = (this.pending = { pos: r });
            o.then(
              (a) => {
                this.pending == l &&
                  ((this.pending = null),
                  a &&
                    !(Array.isArray(a) && !a.length) &&
                    e.dispatch({
                      effects: this.setHover.of(Array.isArray(a) ? a : [a]),
                    }));
              },
              (a) => ke(e.state, a, "hover tooltip")
            );
          } else
            o &&
              !(Array.isArray(o) && !o.length) &&
              e.dispatch({
                effects: this.setHover.of(Array.isArray(o) ? o : [o]),
              });
        }
        get tooltip() {
          let e = this.view.plugin(Wo),
            t = e
              ? e.manager.tooltips.findIndex((i) => i.create == Yr.create)
              : -1;
          return t > -1 ? e.manager.tooltipViews[t] : null;
        }
        mousemove(e) {
          var t, i;
          (this.lastMove = {
            x: e.clientX,
            y: e.clientY,
            target: e.target,
            time: Date.now(),
          }),
            this.hoverTimeout < 0 &&
              (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
          let { active: r, tooltip: s } = this;
          if ((r.length && s && !om(s.dom, e)) || this.pending) {
            let { pos: o } = r[0] || this.pending,
              l =
                (i = (t = r[0]) === null || t === void 0 ? void 0 : t.end) !==
                  null && i !== void 0
                  ? i
                  : o;
            (o == l
              ? this.view.posAtCoords(this.lastMove) != o
              : !lm(this.view, o, l, e.clientX, e.clientY)) &&
              (this.view.dispatch({ effects: this.setHover.of([]) }),
              (this.pending = null));
          }
        }
        mouseleave(e) {
          clearTimeout(this.hoverTimeout), (this.hoverTimeout = -1);
          let { active: t } = this;
          if (t.length) {
            let { tooltip: i } = this;
            i && i.dom.contains(e.relatedTarget)
              ? this.watchTooltipLeave(i.dom)
              : this.view.dispatch({ effects: this.setHover.of([]) });
          }
        }
        watchTooltipLeave(e) {
          let t = (i) => {
            e.removeEventListener("mouseleave", t),
              this.active.length &&
                !this.view.dom.contains(i.relatedTarget) &&
                this.view.dispatch({ effects: this.setHover.of([]) });
          };
          e.addEventListener("mouseleave", t);
        }
        destroy() {
          clearTimeout(this.hoverTimeout),
            this.view.dom.removeEventListener("mouseleave", this.mouseleave),
            this.view.dom.removeEventListener("mousemove", this.mousemove);
        }
      }
      const vn = 4;
      function om(n, e) {
        let {
            left: t,
            right: i,
            top: r,
            bottom: s,
          } = n.getBoundingClientRect(),
          o;
        if ((o = n.querySelector(".cm-tooltip-arrow"))) {
          let l = o.getBoundingClientRect();
          (r = Math.min(l.top, r)), (s = Math.max(l.bottom, s));
        }
        return (
          e.clientX >= t - vn &&
          e.clientX <= i + vn &&
          e.clientY >= r - vn &&
          e.clientY <= s + vn
        );
      }
      function lm(n, e, t, i, r, s) {
        let o = n.scrollDOM.getBoundingClientRect(),
          l = n.documentTop + n.documentPadding.top + n.contentHeight;
        if (o.left > i || o.right < i || o.top > r || Math.min(o.bottom, l) < r)
          return !1;
        let a = n.posAtCoords({ x: i, y: r }, !1);
        return a >= e && a <= t;
      }
      function am(n, e = {}) {
        let t = R.define(),
          i = oe.define({
            create() {
              return [];
            },
            update(r, s) {
              if (
                r.length &&
                (e.hideOnChange && (s.docChanged || s.selection)
                  ? (r = [])
                  : e.hideOn && (r = r.filter((o) => !e.hideOn(s, o))),
                s.docChanged)
              ) {
                let o = [];
                for (let l of r) {
                  let a = s.changes.mapPos(l.pos, -1, ce.TrackDel);
                  if (a != null) {
                    let h = Object.assign(Object.create(null), l);
                    (h.pos = a),
                      h.end != null && (h.end = s.changes.mapPos(h.end)),
                      o.push(h);
                  }
                }
                r = o;
              }
              for (let o of s.effects)
                o.is(t) && (r = o.value), o.is(hm) && (r = []);
              return r;
            },
            provide: (r) => or.from(r),
          });
        return {
          active: i,
          extension: [
            i,
            ne.define((r) => new sm(r, n, i, t, e.hoverTime || 300)),
            rm,
          ],
        };
      }
      function ff(n, e) {
        let t = n.plugin(Wo);
        if (!t) return null;
        let i = t.manager.tooltips.indexOf(e);
        return i < 0 ? null : t.manager.tooltipViews[i];
      }
      const hm = R.define(),
        pa = C.define({
          combine(n) {
            let e, t;
            for (let i of n)
              (e = e || i.topContainer), (t = t || i.bottomContainer);
            return { topContainer: e, bottomContainer: t };
          },
        });
      function Gi(n, e) {
        let t = n.plugin(uf),
          i = t ? t.specs.indexOf(e) : -1;
        return i > -1 ? t.panels[i] : null;
      }
      const uf = ne.fromClass(
        class {
          constructor(n) {
            (this.input = n.state.facet(Ni)),
              (this.specs = this.input.filter((t) => t)),
              (this.panels = this.specs.map((t) => t(n)));
            let e = n.state.facet(pa);
            (this.top = new Tn(n, !0, e.topContainer)),
              (this.bottom = new Tn(n, !1, e.bottomContainer)),
              this.top.sync(this.panels.filter((t) => t.top)),
              this.bottom.sync(this.panels.filter((t) => !t.top));
            for (let t of this.panels)
              t.dom.classList.add("cm-panel"), t.mount && t.mount();
          }
          update(n) {
            let e = n.state.facet(pa);
            this.top.container != e.topContainer &&
              (this.top.sync([]),
              (this.top = new Tn(n.view, !0, e.topContainer))),
              this.bottom.container != e.bottomContainer &&
                (this.bottom.sync([]),
                (this.bottom = new Tn(n.view, !1, e.bottomContainer))),
              this.top.syncClasses(),
              this.bottom.syncClasses();
            let t = n.state.facet(Ni);
            if (t != this.input) {
              let i = t.filter((a) => a),
                r = [],
                s = [],
                o = [],
                l = [];
              for (let a of i) {
                let h = this.specs.indexOf(a),
                  c;
                h < 0
                  ? ((c = a(n.view)), l.push(c))
                  : ((c = this.panels[h]), c.update && c.update(n)),
                  r.push(c),
                  (c.top ? s : o).push(c);
              }
              (this.specs = i),
                (this.panels = r),
                this.top.sync(s),
                this.bottom.sync(o);
              for (let a of l)
                a.dom.classList.add("cm-panel"), a.mount && a.mount();
            } else for (let i of this.panels) i.update && i.update(n);
          }
          destroy() {
            this.top.sync([]), this.bottom.sync([]);
          }
        },
        {
          provide: (n) =>
            v.scrollMargins.of((e) => {
              let t = e.plugin(n);
              return (
                t && {
                  top: t.top.scrollMargin(),
                  bottom: t.bottom.scrollMargin(),
                }
              );
            }),
        }
      );
      class Tn {
        constructor(e, t, i) {
          (this.view = e),
            (this.top = t),
            (this.container = i),
            (this.dom = void 0),
            (this.classes = ""),
            (this.panels = []),
            this.syncClasses();
        }
        sync(e) {
          for (let t of this.panels)
            t.destroy && e.indexOf(t) < 0 && t.destroy();
          (this.panels = e), this.syncDOM();
        }
        syncDOM() {
          if (this.panels.length == 0) {
            this.dom && (this.dom.remove(), (this.dom = void 0));
            return;
          }
          if (!this.dom) {
            (this.dom = document.createElement("div")),
              (this.dom.className = this.top
                ? "cm-panels cm-panels-top"
                : "cm-panels cm-panels-bottom"),
              (this.dom.style[this.top ? "top" : "bottom"] = "0");
            let t = this.container || this.view.dom;
            t.insertBefore(this.dom, this.top ? t.firstChild : null);
          }
          let e = this.dom.firstChild;
          for (let t of this.panels)
            if (t.dom.parentNode == this.dom) {
              for (; e != t.dom; ) e = ma(e);
              e = e.nextSibling;
            } else this.dom.insertBefore(t.dom, e);
          for (; e; ) e = ma(e);
        }
        scrollMargin() {
          return !this.dom || this.container
            ? 0
            : Math.max(
                0,
                this.top
                  ? this.dom.getBoundingClientRect().bottom -
                      Math.max(
                        0,
                        this.view.scrollDOM.getBoundingClientRect().top
                      )
                  : Math.min(
                      innerHeight,
                      this.view.scrollDOM.getBoundingClientRect().bottom
                    ) - this.dom.getBoundingClientRect().top
              );
        }
        syncClasses() {
          if (!(!this.container || this.classes == this.view.themeClasses)) {
            for (let e of this.classes.split(" "))
              e && this.container.classList.remove(e);
            for (let e of (this.classes = this.view.themeClasses).split(" "))
              e && this.container.classList.add(e);
          }
        }
      }
      function ma(n) {
        let e = n.nextSibling;
        return n.remove(), e;
      }
      const Ni = C.define({ enables: uf });
      class gt extends qt {
        compare(e) {
          return this == e || (this.constructor == e.constructor && this.eq(e));
        }
        eq(e) {
          return !1;
        }
        destroy(e) {}
      }
      gt.prototype.elementClass = "";
      gt.prototype.toDOM = void 0;
      gt.prototype.mapMode = ce.TrackBefore;
      gt.prototype.startSide = gt.prototype.endSide = -1;
      gt.prototype.point = !0;
      const In = C.define(),
        cm = C.define(),
        fm = {
          class: "",
          renderEmptyElements: !1,
          elementStyle: "",
          markers: () => V.empty,
          lineMarker: () => null,
          widgetMarker: () => null,
          lineMarkerChange: null,
          initialSpacer: null,
          updateSpacer: null,
          domEventHandlers: {},
          side: "before",
        },
        Ei = C.define();
      function um(n) {
        return [df(), Ei.of({ ...fm, ...n })];
      }
      const ga = C.define({ combine: (n) => n.some((e) => e) });
      function df(n) {
        return [dm];
      }
      const dm = ne.fromClass(
        class {
          constructor(n) {
            (this.view = n),
              (this.domAfter = null),
              (this.prevViewport = n.viewport),
              (this.dom = document.createElement("div")),
              (this.dom.className = "cm-gutters cm-gutters-before"),
              this.dom.setAttribute("aria-hidden", "true"),
              (this.dom.style.minHeight =
                this.view.contentHeight / this.view.scaleY + "px"),
              (this.gutters = n.state.facet(Ei).map((e) => new Sa(n, e))),
              (this.fixed = !n.state.facet(ga));
            for (let e of this.gutters)
              e.config.side == "after"
                ? this.getDOMAfter().appendChild(e.dom)
                : this.dom.appendChild(e.dom);
            this.fixed && (this.dom.style.position = "sticky"),
              this.syncGutters(!1),
              n.scrollDOM.insertBefore(this.dom, n.contentDOM);
          }
          getDOMAfter() {
            return (
              this.domAfter ||
                ((this.domAfter = document.createElement("div")),
                (this.domAfter.className = "cm-gutters cm-gutters-after"),
                this.domAfter.setAttribute("aria-hidden", "true"),
                (this.domAfter.style.minHeight =
                  this.view.contentHeight / this.view.scaleY + "px"),
                (this.domAfter.style.position = this.fixed ? "sticky" : ""),
                this.view.scrollDOM.appendChild(this.domAfter)),
              this.domAfter
            );
          }
          update(n) {
            if (this.updateGutters(n)) {
              let e = this.prevViewport,
                t = n.view.viewport,
                i = Math.min(e.to, t.to) - Math.max(e.from, t.from);
              this.syncGutters(i < (t.to - t.from) * 0.8);
            }
            if (n.geometryChanged) {
              let e = this.view.contentHeight / this.view.scaleY + "px";
              (this.dom.style.minHeight = e),
                this.domAfter && (this.domAfter.style.minHeight = e);
            }
            this.view.state.facet(ga) != !this.fixed &&
              ((this.fixed = !this.fixed),
              (this.dom.style.position = this.fixed ? "sticky" : ""),
              this.domAfter &&
                (this.domAfter.style.position = this.fixed ? "sticky" : "")),
              (this.prevViewport = n.view.viewport);
          }
          syncGutters(n) {
            let e = this.dom.nextSibling;
            n && (this.dom.remove(), this.domAfter && this.domAfter.remove());
            let t = V.iter(this.view.state.facet(In), this.view.viewport.from),
              i = [],
              r = this.gutters.map(
                (s) =>
                  new Om(s, this.view.viewport, -this.view.documentPadding.top)
              );
            for (let s of this.view.viewportLineBlocks)
              if ((i.length && (i = []), Array.isArray(s.type))) {
                let o = !0;
                for (let l of s.type)
                  if (l.type == ge.Text && o) {
                    co(t, i, l.from);
                    for (let a of r) a.line(this.view, l, i);
                    o = !1;
                  } else if (l.widget) for (let a of r) a.widget(this.view, l);
              } else if (s.type == ge.Text) {
                co(t, i, s.from);
                for (let o of r) o.line(this.view, s, i);
              } else if (s.widget) for (let o of r) o.widget(this.view, s);
            for (let s of r) s.finish();
            n &&
              (this.view.scrollDOM.insertBefore(this.dom, e),
              this.domAfter && this.view.scrollDOM.appendChild(this.domAfter));
          }
          updateGutters(n) {
            let e = n.startState.facet(Ei),
              t = n.state.facet(Ei),
              i =
                n.docChanged ||
                n.heightChanged ||
                n.viewportChanged ||
                !V.eq(
                  n.startState.facet(In),
                  n.state.facet(In),
                  n.view.viewport.from,
                  n.view.viewport.to
                );
            if (e == t) for (let r of this.gutters) r.update(n) && (i = !0);
            else {
              i = !0;
              let r = [];
              for (let s of t) {
                let o = e.indexOf(s);
                o < 0
                  ? r.push(new Sa(this.view, s))
                  : (this.gutters[o].update(n), r.push(this.gutters[o]));
              }
              for (let s of this.gutters)
                s.dom.remove(), r.indexOf(s) < 0 && s.destroy();
              for (let s of r)
                s.config.side == "after"
                  ? this.getDOMAfter().appendChild(s.dom)
                  : this.dom.appendChild(s.dom);
              this.gutters = r;
            }
            return i;
          }
          destroy() {
            for (let n of this.gutters) n.destroy();
            this.dom.remove(), this.domAfter && this.domAfter.remove();
          }
        },
        {
          provide: (n) =>
            v.scrollMargins.of((e) => {
              let t = e.plugin(n);
              if (!t || t.gutters.length == 0 || !t.fixed) return null;
              let i = t.dom.offsetWidth * e.scaleX,
                r = t.domAfter ? t.domAfter.offsetWidth * e.scaleX : 0;
              return e.textDirection == F.LTR
                ? { left: i, right: r }
                : { right: i, left: r };
            }),
        }
      );
      function Qa(n) {
        return Array.isArray(n) ? n : [n];
      }
      function co(n, e, t) {
        for (; n.value && n.from <= t; )
          n.from == t && e.push(n.value), n.next();
      }
      class Om {
        constructor(e, t, i) {
          (this.gutter = e),
            (this.height = i),
            (this.i = 0),
            (this.cursor = V.iter(e.markers, t.from));
        }
        addElement(e, t, i) {
          let { gutter: r } = this,
            s = (t.top - this.height) / e.scaleY,
            o = t.height / e.scaleY;
          if (this.i == r.elements.length) {
            let l = new Of(e, o, s, i);
            r.elements.push(l), r.dom.appendChild(l.dom);
          } else r.elements[this.i].update(e, o, s, i);
          (this.height = t.bottom), this.i++;
        }
        line(e, t, i) {
          let r = [];
          co(this.cursor, r, t.from), i.length && (r = r.concat(i));
          let s = this.gutter.config.lineMarker(e, t, r);
          s && r.unshift(s);
          let o = this.gutter;
          (r.length == 0 && !o.config.renderEmptyElements) ||
            this.addElement(e, t, r);
        }
        widget(e, t) {
          let i = this.gutter.config.widgetMarker(e, t.widget, t),
            r = i ? [i] : null;
          for (let s of e.state.facet(cm)) {
            let o = s(e, t.widget, t);
            o && (r || (r = [])).push(o);
          }
          r && this.addElement(e, t, r);
        }
        finish() {
          let e = this.gutter;
          for (; e.elements.length > this.i; ) {
            let t = e.elements.pop();
            e.dom.removeChild(t.dom), t.destroy();
          }
        }
      }
      class Sa {
        constructor(e, t) {
          (this.view = e),
            (this.config = t),
            (this.elements = []),
            (this.spacer = null),
            (this.dom = document.createElement("div")),
            (this.dom.className =
              "cm-gutter" + (this.config.class ? " " + this.config.class : ""));
          for (let i in t.domEventHandlers)
            this.dom.addEventListener(i, (r) => {
              let s = r.target,
                o;
              if (s != this.dom && this.dom.contains(s)) {
                for (; s.parentNode != this.dom; ) s = s.parentNode;
                let a = s.getBoundingClientRect();
                o = (a.top + a.bottom) / 2;
              } else o = r.clientY;
              let l = e.lineBlockAtHeight(o - e.documentTop);
              t.domEventHandlers[i](e, l, r) && r.preventDefault();
            });
          (this.markers = Qa(t.markers(e))),
            t.initialSpacer &&
              ((this.spacer = new Of(e, 0, 0, [t.initialSpacer(e)])),
              this.dom.appendChild(this.spacer.dom),
              (this.spacer.dom.style.cssText +=
                "visibility: hidden; pointer-events: none"));
        }
        update(e) {
          let t = this.markers;
          if (
            ((this.markers = Qa(this.config.markers(e.view))),
            this.spacer && this.config.updateSpacer)
          ) {
            let r = this.config.updateSpacer(this.spacer.markers[0], e);
            r != this.spacer.markers[0] &&
              this.spacer.update(e.view, 0, 0, [r]);
          }
          let i = e.view.viewport;
          return (
            !V.eq(this.markers, t, i.from, i.to) ||
            (this.config.lineMarkerChange
              ? this.config.lineMarkerChange(e)
              : !1)
          );
        }
        destroy() {
          for (let e of this.elements) e.destroy();
        }
      }
      class Of {
        constructor(e, t, i, r) {
          (this.height = -1),
            (this.above = 0),
            (this.markers = []),
            (this.dom = document.createElement("div")),
            (this.dom.className = "cm-gutterElement"),
            this.update(e, t, i, r);
        }
        update(e, t, i, r) {
          this.height != t &&
            ((this.height = t), (this.dom.style.height = t + "px")),
            this.above != i &&
              (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""),
            pm(this.markers, r) || this.setMarkers(e, r);
        }
        setMarkers(e, t) {
          let i = "cm-gutterElement",
            r = this.dom.firstChild;
          for (let s = 0, o = 0; ; ) {
            let l = o,
              a = s < t.length ? t[s++] : null,
              h = !1;
            if (a) {
              let c = a.elementClass;
              c && (i += " " + c);
              for (let f = o; f < this.markers.length; f++)
                if (this.markers[f].compare(a)) {
                  (l = f), (h = !0);
                  break;
                }
            } else l = this.markers.length;
            for (; o < l; ) {
              let c = this.markers[o++];
              if (c.toDOM) {
                c.destroy(r);
                let f = r.nextSibling;
                r.remove(), (r = f);
              }
            }
            if (!a) break;
            a.toDOM &&
              (h ? (r = r.nextSibling) : this.dom.insertBefore(a.toDOM(e), r)),
              h && o++;
          }
          (this.dom.className = i), (this.markers = t);
        }
        destroy() {
          this.setMarkers(null, []);
        }
      }
      function pm(n, e) {
        if (n.length != e.length) return !1;
        for (let t = 0; t < n.length; t++) if (!n[t].compare(e[t])) return !1;
        return !0;
      }
      const mm = C.define(),
        gm = C.define(),
        Ht = C.define({
          combine(n) {
            return lt(
              n,
              { formatNumber: String, domEventHandlers: {} },
              {
                domEventHandlers(e, t) {
                  let i = Object.assign({}, e);
                  for (let r in t) {
                    let s = i[r],
                      o = t[r];
                    i[r] = s ? (l, a, h) => s(l, a, h) || o(l, a, h) : o;
                  }
                  return i;
                },
              }
            );
          },
        });
      class rs extends gt {
        constructor(e) {
          super(), (this.number = e);
        }
        eq(e) {
          return this.number == e.number;
        }
        toDOM() {
          return document.createTextNode(this.number);
        }
      }
      function ss(n, e) {
        return n.state.facet(Ht).formatNumber(e, n.state);
      }
      const Qm = Ei.compute([Ht], (n) => ({
        class: "cm-lineNumbers",
        renderEmptyElements: !1,
        markers(e) {
          return e.state.facet(mm);
        },
        lineMarker(e, t, i) {
          return i.some((r) => r.toDOM)
            ? null
            : new rs(ss(e, e.state.doc.lineAt(t.from).number));
        },
        widgetMarker: (e, t, i) => {
          for (let r of e.state.facet(gm)) {
            let s = r(e, t, i);
            if (s) return s;
          }
          return null;
        },
        lineMarkerChange: (e) => e.startState.facet(Ht) != e.state.facet(Ht),
        initialSpacer(e) {
          return new rs(ss(e, ya(e.state.doc.lines)));
        },
        updateSpacer(e, t) {
          let i = ss(t.view, ya(t.view.state.doc.lines));
          return i == e.number ? e : new rs(i);
        },
        domEventHandlers: n.facet(Ht).domEventHandlers,
        side: "before",
      }));
      function Sm(n = {}) {
        return [Ht.of(n), df(), Qm];
      }
      function ya(n) {
        let e = 9;
        for (; e < n; ) e = e * 10 + 9;
        return e;
      }
      const ym = new (class extends gt {
          constructor() {
            super(...arguments), (this.elementClass = "cm-activeLineGutter");
          }
        })(),
        bm = In.compute(["selection"], (n) => {
          let e = [],
            t = -1;
          for (let i of n.selection.ranges) {
            let r = n.doc.lineAt(i.head).from;
            r > t && ((t = r), e.push(ym.range(r)));
          }
          return V.of(e);
        });
      function xm() {
        return bm;
      }
      const pf = 1024;
      let wm = 0;
      class ze {
        constructor(e, t) {
          (this.from = e), (this.to = t);
        }
      }
      class Y {
        constructor(e = {}) {
          (this.id = wm++),
            (this.perNode = !!e.perNode),
            (this.deserialize =
              e.deserialize ||
              (() => {
                throw new Error(
                  "This node type doesn't define a deserialize function"
                );
              }));
        }
        add(e) {
          if (this.perNode)
            throw new RangeError("Can't add per-node props to node types");
          return (
            typeof e != "function" && (e = Se.match(e)),
            (t) => {
              let i = e(t);
              return i === void 0 ? null : [this, i];
            }
          );
        }
      }
      Y.closedBy = new Y({ deserialize: (n) => n.split(" ") });
      Y.openedBy = new Y({ deserialize: (n) => n.split(" ") });
      Y.group = new Y({ deserialize: (n) => n.split(" ") });
      Y.isolate = new Y({
        deserialize: (n) => {
          if (n && n != "rtl" && n != "ltr" && n != "auto")
            throw new RangeError("Invalid value for isolate: " + n);
          return n || "auto";
        },
      });
      Y.contextHash = new Y({ perNode: !0 });
      Y.lookAhead = new Y({ perNode: !0 });
      Y.mounted = new Y({ perNode: !0 });
      class Ui {
        constructor(e, t, i) {
          (this.tree = e), (this.overlay = t), (this.parser = i);
        }
        static get(e) {
          return e && e.props && e.props[Y.mounted.id];
        }
      }
      const km = Object.create(null);
      class Se {
        constructor(e, t, i, r = 0) {
          (this.name = e), (this.props = t), (this.id = i), (this.flags = r);
        }
        static define(e) {
          let t = e.props && e.props.length ? Object.create(null) : km,
            i =
              (e.top ? 1 : 0) |
              (e.skipped ? 2 : 0) |
              (e.error ? 4 : 0) |
              (e.name == null ? 8 : 0),
            r = new Se(e.name || "", t, e.id, i);
          if (e.props) {
            for (let s of e.props)
              if ((Array.isArray(s) || (s = s(r)), s)) {
                if (s[0].perNode)
                  throw new RangeError(
                    "Can't store a per-node prop on a node type"
                  );
                t[s[0].id] = s[1];
              }
          }
          return r;
        }
        prop(e) {
          return this.props[e.id];
        }
        get isTop() {
          return (this.flags & 1) > 0;
        }
        get isSkipped() {
          return (this.flags & 2) > 0;
        }
        get isError() {
          return (this.flags & 4) > 0;
        }
        get isAnonymous() {
          return (this.flags & 8) > 0;
        }
        is(e) {
          if (typeof e == "string") {
            if (this.name == e) return !0;
            let t = this.prop(Y.group);
            return t ? t.indexOf(e) > -1 : !1;
          }
          return this.id == e;
        }
        static match(e) {
          let t = Object.create(null);
          for (let i in e) for (let r of i.split(" ")) t[r] = e[i];
          return (i) => {
            for (let r = i.prop(Y.group), s = -1; s < (r ? r.length : 0); s++) {
              let o = t[s < 0 ? i.name : r[s]];
              if (o) return o;
            }
          };
        }
      }
      Se.none = new Se("", Object.create(null), 0, 8);
      class jo {
        constructor(e) {
          this.types = e;
          for (let t = 0; t < e.length; t++)
            if (e[t].id != t)
              throw new RangeError(
                "Node type ids should correspond to array positions when creating a node set"
              );
        }
        extend(...e) {
          let t = [];
          for (let i of this.types) {
            let r = null;
            for (let s of e) {
              let o = s(i);
              o && (r || (r = Object.assign({}, i.props)), (r[o[0].id] = o[1]));
            }
            t.push(r ? new Se(i.name, r, i.id, i.flags) : i);
          }
          return new jo(t);
        }
      }
      const Cn = new WeakMap(),
        ba = new WeakMap();
      var N;
      (function (n) {
        (n[(n.ExcludeBuffers = 1)] = "ExcludeBuffers"),
          (n[(n.IncludeAnonymous = 2)] = "IncludeAnonymous"),
          (n[(n.IgnoreMounts = 4)] = "IgnoreMounts"),
          (n[(n.IgnoreOverlays = 8)] = "IgnoreOverlays");
      })(N || (N = {}));
      class K {
        constructor(e, t, i, r, s) {
          if (
            ((this.type = e),
            (this.children = t),
            (this.positions = i),
            (this.length = r),
            (this.props = null),
            s && s.length)
          ) {
            this.props = Object.create(null);
            for (let [o, l] of s)
              this.props[typeof o == "number" ? o : o.id] = l;
          }
        }
        toString() {
          let e = Ui.get(this);
          if (e && !e.overlay) return e.tree.toString();
          let t = "";
          for (let i of this.children) {
            let r = i.toString();
            r && (t && (t += ","), (t += r));
          }
          return this.type.name
            ? (/\W/.test(this.type.name) && !this.type.isError
                ? JSON.stringify(this.type.name)
                : this.type.name) + (t.length ? "(" + t + ")" : "")
            : t;
        }
        cursor(e = 0) {
          return new lr(this.topNode, e);
        }
        cursorAt(e, t = 0, i = 0) {
          let r = Cn.get(this) || this.topNode,
            s = new lr(r);
          return s.moveTo(e, t), Cn.set(this, s._tree), s;
        }
        get topNode() {
          return new Oe(this, 0, 0, null);
        }
        resolve(e, t = 0) {
          let i = Fi(Cn.get(this) || this.topNode, e, t, !1);
          return Cn.set(this, i), i;
        }
        resolveInner(e, t = 0) {
          let i = Fi(ba.get(this) || this.topNode, e, t, !0);
          return ba.set(this, i), i;
        }
        resolveStack(e, t = 0) {
          return vm(this, e, t);
        }
        iterate(e) {
          let { enter: t, leave: i, from: r = 0, to: s = this.length } = e,
            o = e.mode || 0,
            l = (o & N.IncludeAnonymous) > 0;
          for (let a = this.cursor(o | N.IncludeAnonymous); ; ) {
            let h = !1;
            if (
              a.from <= s &&
              a.to >= r &&
              ((!l && a.type.isAnonymous) || t(a) !== !1)
            ) {
              if (a.firstChild()) continue;
              h = !0;
            }
            for (
              ;
              h && i && (l || !a.type.isAnonymous) && i(a), !a.nextSibling();

            ) {
              if (!a.parent()) return;
              h = !0;
            }
          }
        }
        prop(e) {
          return e.perNode
            ? this.props
              ? this.props[e.id]
              : void 0
            : this.type.prop(e);
        }
        get propValues() {
          let e = [];
          if (this.props) for (let t in this.props) e.push([+t, this.props[t]]);
          return e;
        }
        balance(e = {}) {
          return this.children.length <= 8
            ? this
            : Go(
                Se.none,
                this.children,
                this.positions,
                0,
                this.children.length,
                0,
                this.length,
                (t, i, r) => new K(this.type, t, i, r, this.propValues),
                e.makeTree || ((t, i, r) => new K(Se.none, t, i, r))
              );
        }
        static build(e) {
          return Tm(e);
        }
      }
      K.empty = new K(Se.none, [], [], 0);
      class Bo {
        constructor(e, t) {
          (this.buffer = e), (this.index = t);
        }
        get id() {
          return this.buffer[this.index - 4];
        }
        get start() {
          return this.buffer[this.index - 3];
        }
        get end() {
          return this.buffer[this.index - 2];
        }
        get size() {
          return this.buffer[this.index - 1];
        }
        get pos() {
          return this.index;
        }
        next() {
          this.index -= 4;
        }
        fork() {
          return new Bo(this.buffer, this.index);
        }
      }
      class Zt {
        constructor(e, t, i) {
          (this.buffer = e), (this.length = t), (this.set = i);
        }
        get type() {
          return Se.none;
        }
        toString() {
          let e = [];
          for (let t = 0; t < this.buffer.length; )
            e.push(this.childString(t)), (t = this.buffer[t + 3]);
          return e.join(",");
        }
        childString(e) {
          let t = this.buffer[e],
            i = this.buffer[e + 3],
            r = this.set.types[t],
            s = r.name;
          if (
            (/\W/.test(s) && !r.isError && (s = JSON.stringify(s)),
            (e += 4),
            i == e)
          )
            return s;
          let o = [];
          for (; e < i; ) o.push(this.childString(e)), (e = this.buffer[e + 3]);
          return s + "(" + o.join(",") + ")";
        }
        findChild(e, t, i, r, s) {
          let { buffer: o } = this,
            l = -1;
          for (
            let a = e;
            a != t && !(mf(s, r, o[a + 1], o[a + 2]) && ((l = a), i > 0));
            a = o[a + 3]
          );
          return l;
        }
        slice(e, t, i) {
          let r = this.buffer,
            s = new Uint16Array(t - e),
            o = 0;
          for (let l = e, a = 0; l < t; ) {
            (s[a++] = r[l++]), (s[a++] = r[l++] - i);
            let h = (s[a++] = r[l++] - i);
            (s[a++] = r[l++] - e), (o = Math.max(o, h));
          }
          return new Zt(s, o, this.set);
        }
      }
      function mf(n, e, t, i) {
        switch (n) {
          case -2:
            return t < e;
          case -1:
            return i >= e && t < e;
          case 0:
            return t < e && i > e;
          case 1:
            return t <= e && i > e;
          case 2:
            return i > e;
          case 4:
            return !0;
        }
      }
      function Fi(n, e, t, i) {
        for (
          var r;
          n.from == n.to ||
          (t < 1 ? n.from >= e : n.from > e) ||
          (t > -1 ? n.to <= e : n.to < e);

        ) {
          let o = !i && n instanceof Oe && n.index < 0 ? null : n.parent;
          if (!o) return n;
          n = o;
        }
        let s = i ? 0 : N.IgnoreOverlays;
        if (i)
          for (let o = n, l = o.parent; l; o = l, l = o.parent)
            o instanceof Oe &&
              o.index < 0 &&
              ((r = l.enter(e, t, s)) === null || r === void 0
                ? void 0
                : r.from) != o.from &&
              (n = l);
        for (;;) {
          let o = n.enter(e, t, s);
          if (!o) return n;
          n = o;
        }
      }
      class gf {
        cursor(e = 0) {
          return new lr(this, e);
        }
        getChild(e, t = null, i = null) {
          let r = xa(this, e, t, i);
          return r.length ? r[0] : null;
        }
        getChildren(e, t = null, i = null) {
          return xa(this, e, t, i);
        }
        resolve(e, t = 0) {
          return Fi(this, e, t, !1);
        }
        resolveInner(e, t = 0) {
          return Fi(this, e, t, !0);
        }
        matchContext(e) {
          return fo(this.parent, e);
        }
        enterUnfinishedNodesBefore(e) {
          let t = this.childBefore(e),
            i = this;
          for (; t; ) {
            let r = t.lastChild;
            if (!r || r.to != t.to) break;
            r.type.isError && r.from == r.to
              ? ((i = t), (t = r.prevSibling))
              : (t = r);
          }
          return i;
        }
        get node() {
          return this;
        }
        get next() {
          return this.parent;
        }
      }
      class Oe extends gf {
        constructor(e, t, i, r) {
          super(),
            (this._tree = e),
            (this.from = t),
            (this.index = i),
            (this._parent = r);
        }
        get type() {
          return this._tree.type;
        }
        get name() {
          return this._tree.type.name;
        }
        get to() {
          return this.from + this._tree.length;
        }
        nextChild(e, t, i, r, s = 0) {
          for (let o = this; ; ) {
            for (
              let { children: l, positions: a } = o._tree,
                h = t > 0 ? l.length : -1;
              e != h;
              e += t
            ) {
              let c = l[e],
                f = a[e] + o.from;
              if (mf(r, i, f, f + c.length)) {
                if (c instanceof Zt) {
                  if (s & N.ExcludeBuffers) continue;
                  let u = c.findChild(0, c.buffer.length, t, i - f, r);
                  if (u > -1) return new tt(new $m(o, c, e, f), null, u);
                } else if (
                  s & N.IncludeAnonymous ||
                  !c.type.isAnonymous ||
                  Io(c)
                ) {
                  let u;
                  if (!(s & N.IgnoreMounts) && (u = Ui.get(c)) && !u.overlay)
                    return new Oe(u.tree, f, e, o);
                  let d = new Oe(c, f, e, o);
                  return s & N.IncludeAnonymous || !d.type.isAnonymous
                    ? d
                    : d.nextChild(t < 0 ? c.children.length - 1 : 0, t, i, r);
                }
              }
            }
            if (
              s & N.IncludeAnonymous ||
              !o.type.isAnonymous ||
              (o.index >= 0
                ? (e = o.index + t)
                : (e = t < 0 ? -1 : o._parent._tree.children.length),
              (o = o._parent),
              !o)
            )
              return null;
          }
        }
        get firstChild() {
          return this.nextChild(0, 1, 0, 4);
        }
        get lastChild() {
          return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
        }
        childAfter(e) {
          return this.nextChild(0, 1, e, 2);
        }
        childBefore(e) {
          return this.nextChild(this._tree.children.length - 1, -1, e, -2);
        }
        enter(e, t, i = 0) {
          let r;
          if (
            !(i & N.IgnoreOverlays) &&
            (r = Ui.get(this._tree)) &&
            r.overlay
          ) {
            let s = e - this.from;
            for (let { from: o, to: l } of r.overlay)
              if ((t > 0 ? o <= s : o < s) && (t < 0 ? l >= s : l > s))
                return new Oe(r.tree, r.overlay[0].from + this.from, -1, this);
          }
          return this.nextChild(0, 1, e, t, i);
        }
        nextSignificantParent() {
          let e = this;
          for (; e.type.isAnonymous && e._parent; ) e = e._parent;
          return e;
        }
        get parent() {
          return this._parent ? this._parent.nextSignificantParent() : null;
        }
        get nextSibling() {
          return this._parent && this.index >= 0
            ? this._parent.nextChild(this.index + 1, 1, 0, 4)
            : null;
        }
        get prevSibling() {
          return this._parent && this.index >= 0
            ? this._parent.nextChild(this.index - 1, -1, 0, 4)
            : null;
        }
        get tree() {
          return this._tree;
        }
        toTree() {
          return this._tree;
        }
        toString() {
          return this._tree.toString();
        }
      }
      function xa(n, e, t, i) {
        let r = n.cursor(),
          s = [];
        if (!r.firstChild()) return s;
        if (t != null) {
          for (let o = !1; !o; )
            if (((o = r.type.is(t)), !r.nextSibling())) return s;
        }
        for (;;) {
          if (i != null && r.type.is(i)) return s;
          if ((r.type.is(e) && s.push(r.node), !r.nextSibling()))
            return i == null ? s : [];
        }
      }
      function fo(n, e, t = e.length - 1) {
        for (let i = n; t >= 0; i = i.parent) {
          if (!i) return !1;
          if (!i.type.isAnonymous) {
            if (e[t] && e[t] != i.name) return !1;
            t--;
          }
        }
        return !0;
      }
      class $m {
        constructor(e, t, i, r) {
          (this.parent = e),
            (this.buffer = t),
            (this.index = i),
            (this.start = r);
        }
      }
      class tt extends gf {
        get name() {
          return this.type.name;
        }
        get from() {
          return (
            this.context.start + this.context.buffer.buffer[this.index + 1]
          );
        }
        get to() {
          return (
            this.context.start + this.context.buffer.buffer[this.index + 2]
          );
        }
        constructor(e, t, i) {
          super(),
            (this.context = e),
            (this._parent = t),
            (this.index = i),
            (this.type = e.buffer.set.types[e.buffer.buffer[i]]);
        }
        child(e, t, i) {
          let { buffer: r } = this.context,
            s = r.findChild(
              this.index + 4,
              r.buffer[this.index + 3],
              e,
              t - this.context.start,
              i
            );
          return s < 0 ? null : new tt(this.context, this, s);
        }
        get firstChild() {
          return this.child(1, 0, 4);
        }
        get lastChild() {
          return this.child(-1, 0, 4);
        }
        childAfter(e) {
          return this.child(1, e, 2);
        }
        childBefore(e) {
          return this.child(-1, e, -2);
        }
        enter(e, t, i = 0) {
          if (i & N.ExcludeBuffers) return null;
          let { buffer: r } = this.context,
            s = r.findChild(
              this.index + 4,
              r.buffer[this.index + 3],
              t > 0 ? 1 : -1,
              e - this.context.start,
              t
            );
          return s < 0 ? null : new tt(this.context, this, s);
        }
        get parent() {
          return this._parent || this.context.parent.nextSignificantParent();
        }
        externalSibling(e) {
          return this._parent
            ? null
            : this.context.parent.nextChild(this.context.index + e, e, 0, 4);
        }
        get nextSibling() {
          let { buffer: e } = this.context,
            t = e.buffer[this.index + 3];
          return t <
            (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length)
            ? new tt(this.context, this._parent, t)
            : this.externalSibling(1);
        }
        get prevSibling() {
          let { buffer: e } = this.context,
            t = this._parent ? this._parent.index + 4 : 0;
          return this.index == t
            ? this.externalSibling(-1)
            : new tt(
                this.context,
                this._parent,
                e.findChild(t, this.index, -1, 0, 4)
              );
        }
        get tree() {
          return null;
        }
        toTree() {
          let e = [],
            t = [],
            { buffer: i } = this.context,
            r = this.index + 4,
            s = i.buffer[this.index + 3];
          if (s > r) {
            let o = i.buffer[this.index + 1];
            e.push(i.slice(r, s, o)), t.push(0);
          }
          return new K(this.type, e, t, this.to - this.from);
        }
        toString() {
          return this.context.buffer.childString(this.index);
        }
      }
      function Qf(n) {
        if (!n.length) return null;
        let e = 0,
          t = n[0];
        for (let s = 1; s < n.length; s++) {
          let o = n[s];
          (o.from > t.from || o.to < t.to) && ((t = o), (e = s));
        }
        let i = t instanceof Oe && t.index < 0 ? null : t.parent,
          r = n.slice();
        return i ? (r[e] = i) : r.splice(e, 1), new Pm(r, t);
      }
      class Pm {
        constructor(e, t) {
          (this.heads = e), (this.node = t);
        }
        get next() {
          return Qf(this.heads);
        }
      }
      function vm(n, e, t) {
        let i = n.resolveInner(e, t),
          r = null;
        for (let s = i instanceof Oe ? i : i.context.parent; s; s = s.parent)
          if (s.index < 0) {
            let o = s.parent;
            (r || (r = [i])).push(o.resolve(e, t)), (s = o);
          } else {
            let o = Ui.get(s.tree);
            if (
              o &&
              o.overlay &&
              o.overlay[0].from <= e &&
              o.overlay[o.overlay.length - 1].to >= e
            ) {
              let l = new Oe(o.tree, o.overlay[0].from + s.from, -1, s);
              (r || (r = [i])).push(Fi(l, e, t, !1));
            }
          }
        return r ? Qf(r) : i;
      }
      class lr {
        get name() {
          return this.type.name;
        }
        constructor(e, t = 0) {
          if (
            ((this.mode = t),
            (this.buffer = null),
            (this.stack = []),
            (this.index = 0),
            (this.bufferNode = null),
            e instanceof Oe)
          )
            this.yieldNode(e);
          else {
            (this._tree = e.context.parent), (this.buffer = e.context);
            for (let i = e._parent; i; i = i._parent)
              this.stack.unshift(i.index);
            (this.bufferNode = e), this.yieldBuf(e.index);
          }
        }
        yieldNode(e) {
          return e
            ? ((this._tree = e),
              (this.type = e.type),
              (this.from = e.from),
              (this.to = e.to),
              !0)
            : !1;
        }
        yieldBuf(e, t) {
          this.index = e;
          let { start: i, buffer: r } = this.buffer;
          return (
            (this.type = t || r.set.types[r.buffer[e]]),
            (this.from = i + r.buffer[e + 1]),
            (this.to = i + r.buffer[e + 2]),
            !0
          );
        }
        yield(e) {
          return e
            ? e instanceof Oe
              ? ((this.buffer = null), this.yieldNode(e))
              : ((this.buffer = e.context), this.yieldBuf(e.index, e.type))
            : !1;
        }
        toString() {
          return this.buffer
            ? this.buffer.buffer.childString(this.index)
            : this._tree.toString();
        }
        enterChild(e, t, i) {
          if (!this.buffer)
            return this.yield(
              this._tree.nextChild(
                e < 0 ? this._tree._tree.children.length - 1 : 0,
                e,
                t,
                i,
                this.mode
              )
            );
          let { buffer: r } = this.buffer,
            s = r.findChild(
              this.index + 4,
              r.buffer[this.index + 3],
              e,
              t - this.buffer.start,
              i
            );
          return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
        }
        firstChild() {
          return this.enterChild(1, 0, 4);
        }
        lastChild() {
          return this.enterChild(-1, 0, 4);
        }
        childAfter(e) {
          return this.enterChild(1, e, 2);
        }
        childBefore(e) {
          return this.enterChild(-1, e, -2);
        }
        enter(e, t, i = this.mode) {
          return this.buffer
            ? i & N.ExcludeBuffers
              ? !1
              : this.enterChild(1, e, t)
            : this.yield(this._tree.enter(e, t, i));
        }
        parent() {
          if (!this.buffer)
            return this.yieldNode(
              this.mode & N.IncludeAnonymous
                ? this._tree._parent
                : this._tree.parent
            );
          if (this.stack.length) return this.yieldBuf(this.stack.pop());
          let e =
            this.mode & N.IncludeAnonymous
              ? this.buffer.parent
              : this.buffer.parent.nextSignificantParent();
          return (this.buffer = null), this.yieldNode(e);
        }
        sibling(e) {
          if (!this.buffer)
            return this._tree._parent
              ? this.yield(
                  this._tree.index < 0
                    ? null
                    : this._tree._parent.nextChild(
                        this._tree.index + e,
                        e,
                        0,
                        4,
                        this.mode
                      )
                )
              : !1;
          let { buffer: t } = this.buffer,
            i = this.stack.length - 1;
          if (e < 0) {
            let r = i < 0 ? 0 : this.stack[i] + 4;
            if (this.index != r)
              return this.yieldBuf(t.findChild(r, this.index, -1, 0, 4));
          } else {
            let r = t.buffer[this.index + 3];
            if (r < (i < 0 ? t.buffer.length : t.buffer[this.stack[i] + 3]))
              return this.yieldBuf(r);
          }
          return i < 0
            ? this.yield(
                this.buffer.parent.nextChild(
                  this.buffer.index + e,
                  e,
                  0,
                  4,
                  this.mode
                )
              )
            : !1;
        }
        nextSibling() {
          return this.sibling(1);
        }
        prevSibling() {
          return this.sibling(-1);
        }
        atLastNode(e) {
          let t,
            i,
            { buffer: r } = this;
          if (r) {
            if (e > 0) {
              if (this.index < r.buffer.buffer.length) return !1;
            } else
              for (let s = 0; s < this.index; s++)
                if (r.buffer.buffer[s + 3] < this.index) return !1;
            ({ index: t, parent: i } = r);
          } else ({ index: t, _parent: i } = this._tree);
          for (; i; { index: t, _parent: i } = i)
            if (t > -1)
              for (
                let s = t + e, o = e < 0 ? -1 : i._tree.children.length;
                s != o;
                s += e
              ) {
                let l = i._tree.children[s];
                if (
                  this.mode & N.IncludeAnonymous ||
                  l instanceof Zt ||
                  !l.type.isAnonymous ||
                  Io(l)
                )
                  return !1;
              }
          return !0;
        }
        move(e, t) {
          if (t && this.enterChild(e, 0, 4)) return !0;
          for (;;) {
            if (this.sibling(e)) return !0;
            if (this.atLastNode(e) || !this.parent()) return !1;
          }
        }
        next(e = !0) {
          return this.move(1, e);
        }
        prev(e = !0) {
          return this.move(-1, e);
        }
        moveTo(e, t = 0) {
          for (
            ;
            (this.from == this.to ||
              (t < 1 ? this.from >= e : this.from > e) ||
              (t > -1 ? this.to <= e : this.to < e)) &&
            this.parent();

          );
          for (; this.enterChild(1, e, t); );
          return this;
        }
        get node() {
          if (!this.buffer) return this._tree;
          let e = this.bufferNode,
            t = null,
            i = 0;
          if (e && e.context == this.buffer)
            e: for (let r = this.index, s = this.stack.length; s >= 0; ) {
              for (let o = e; o; o = o._parent)
                if (o.index == r) {
                  if (r == this.index) return o;
                  (t = o), (i = s + 1);
                  break e;
                }
              r = this.stack[--s];
            }
          for (let r = i; r < this.stack.length; r++)
            t = new tt(this.buffer, t, this.stack[r]);
          return (this.bufferNode = new tt(this.buffer, t, this.index));
        }
        get tree() {
          return this.buffer ? null : this._tree._tree;
        }
        iterate(e, t) {
          for (let i = 0; ; ) {
            let r = !1;
            if (this.type.isAnonymous || e(this) !== !1) {
              if (this.firstChild()) {
                i++;
                continue;
              }
              this.type.isAnonymous || (r = !0);
            }
            for (;;) {
              if ((r && t && t(this), (r = this.type.isAnonymous), !i)) return;
              if (this.nextSibling()) break;
              this.parent(), i--, (r = !0);
            }
          }
        }
        matchContext(e) {
          if (!this.buffer) return fo(this.node.parent, e);
          let { buffer: t } = this.buffer,
            { types: i } = t.set;
          for (let r = e.length - 1, s = this.stack.length - 1; r >= 0; s--) {
            if (s < 0) return fo(this._tree, e, r);
            let o = i[t.buffer[this.stack[s]]];
            if (!o.isAnonymous) {
              if (e[r] && e[r] != o.name) return !1;
              r--;
            }
          }
          return !0;
        }
      }
      function Io(n) {
        return n.children.some(
          (e) => e instanceof Zt || !e.type.isAnonymous || Io(e)
        );
      }
      function Tm(n) {
        var e;
        let {
            buffer: t,
            nodeSet: i,
            maxBufferLength: r = pf,
            reused: s = [],
            minRepeatType: o = i.types.length,
          } = n,
          l = Array.isArray(t) ? new Bo(t, t.length) : t,
          a = i.types,
          h = 0,
          c = 0;
        function f(b, w, P, M, D, L) {
          let { id: z, start: X, end: W, size: q } = l,
            G = c,
            me = h;
          for (; q < 0; )
            if ((l.next(), q == -1)) {
              let ht = s[z];
              P.push(ht), M.push(X - b);
              return;
            } else if (q == -3) {
              h = z;
              return;
            } else if (q == -4) {
              c = z;
              return;
            } else throw new RangeError(`Unrecognized record size: ${q}`);
          let Pe = a[z],
            Ie,
            le,
            Re = X - b;
          if (W - X <= r && (le = g(l.pos - w, D))) {
            let ht = new Uint16Array(le.size - le.skip),
              Me = l.pos - le.size,
              Ge = ht.length;
            for (; l.pos > Me; ) Ge = Q(le.start, ht, Ge);
            (Ie = new Zt(ht, W - le.start, i)), (Re = le.start - b);
          } else {
            let ht = l.pos - q;
            l.next();
            let Me = [],
              Ge = [],
              Mt = z >= o ? z : -1,
              It = 0,
              On = W;
            for (; l.pos > ht; )
              Mt >= 0 && l.id == Mt && l.size >= 0
                ? (l.end <= On - r &&
                    (O(Me, Ge, X, It, l.end, On, Mt, G, me),
                    (It = Me.length),
                    (On = l.end)),
                  l.next())
                : L > 2500
                ? u(X, ht, Me, Ge)
                : f(X, ht, Me, Ge, Mt, L + 1);
            if (
              (Mt >= 0 &&
                It > 0 &&
                It < Me.length &&
                O(Me, Ge, X, It, X, On, Mt, G, me),
              Me.reverse(),
              Ge.reverse(),
              Mt > -1 && It > 0)
            ) {
              let gl = d(Pe, me);
              Ie = Go(Pe, Me, Ge, 0, Me.length, 0, W - X, gl, gl);
            } else Ie = m(Pe, Me, Ge, W - X, G - W, me);
          }
          P.push(Ie), M.push(Re);
        }
        function u(b, w, P, M) {
          let D = [],
            L = 0,
            z = -1;
          for (; l.pos > w; ) {
            let { id: X, start: W, end: q, size: G } = l;
            if (G > 4) l.next();
            else {
              if (z > -1 && W < z) break;
              z < 0 && (z = q - r), D.push(X, W, q), L++, l.next();
            }
          }
          if (L) {
            let X = new Uint16Array(L * 4),
              W = D[D.length - 2];
            for (let q = D.length - 3, G = 0; q >= 0; q -= 3)
              (X[G++] = D[q]),
                (X[G++] = D[q + 1] - W),
                (X[G++] = D[q + 2] - W),
                (X[G++] = G);
            P.push(new Zt(X, D[2] - W, i)), M.push(W - b);
          }
        }
        function d(b, w) {
          return (P, M, D) => {
            let L = 0,
              z = P.length - 1,
              X,
              W;
            if (z >= 0 && (X = P[z]) instanceof K) {
              if (!z && X.type == b && X.length == D) return X;
              (W = X.prop(Y.lookAhead)) && (L = M[z] + X.length + W);
            }
            return m(b, P, M, D, L, w);
          };
        }
        function O(b, w, P, M, D, L, z, X, W) {
          let q = [],
            G = [];
          for (; b.length > M; ) q.push(b.pop()), G.push(w.pop() + P - D);
          b.push(m(i.types[z], q, G, L - D, X - L, W)), w.push(D - P);
        }
        function m(b, w, P, M, D, L, z) {
          if (L) {
            let X = [Y.contextHash, L];
            z = z ? [X].concat(z) : [X];
          }
          if (D > 25) {
            let X = [Y.lookAhead, D];
            z = z ? [X].concat(z) : [X];
          }
          return new K(b, w, P, M, z);
        }
        function g(b, w) {
          let P = l.fork(),
            M = 0,
            D = 0,
            L = 0,
            z = P.end - r,
            X = { size: 0, start: 0, skip: 0 };
          e: for (let W = P.pos - b; P.pos > W; ) {
            let q = P.size;
            if (P.id == w && q >= 0) {
              (X.size = M),
                (X.start = D),
                (X.skip = L),
                (L += 4),
                (M += 4),
                P.next();
              continue;
            }
            let G = P.pos - q;
            if (q < 0 || G < W || P.start < z) break;
            let me = P.id >= o ? 4 : 0,
              Pe = P.start;
            for (P.next(); P.pos > G; ) {
              if (P.size < 0)
                if (P.size == -3) me += 4;
                else break e;
              else P.id >= o && (me += 4);
              P.next();
            }
            (D = Pe), (M += q), (L += me);
          }
          return (
            (w < 0 || M == b) && ((X.size = M), (X.start = D), (X.skip = L)),
            X.size > 4 ? X : void 0
          );
        }
        function Q(b, w, P) {
          let { id: M, start: D, end: L, size: z } = l;
          if ((l.next(), z >= 0 && M < o)) {
            let X = P;
            if (z > 4) {
              let W = l.pos - (z - 4);
              for (; l.pos > W; ) P = Q(b, w, P);
            }
            (w[--P] = X), (w[--P] = L - b), (w[--P] = D - b), (w[--P] = M);
          } else z == -3 ? (h = M) : z == -4 && (c = M);
          return P;
        }
        let y = [],
          x = [];
        for (; l.pos > 0; ) f(n.start || 0, n.bufferStart || 0, y, x, -1, 0);
        let k =
          (e = n.length) !== null && e !== void 0
            ? e
            : y.length
            ? x[0] + y[0].length
            : 0;
        return new K(a[n.topID], y.reverse(), x.reverse(), k);
      }
      const wa = new WeakMap();
      function Gn(n, e) {
        if (!n.isAnonymous || e instanceof Zt || e.type != n) return 1;
        let t = wa.get(e);
        if (t == null) {
          t = 1;
          for (let i of e.children) {
            if (i.type != n || !(i instanceof K)) {
              t = 1;
              break;
            }
            t += Gn(n, i);
          }
          wa.set(e, t);
        }
        return t;
      }
      function Go(n, e, t, i, r, s, o, l, a) {
        let h = 0;
        for (let O = i; O < r; O++) h += Gn(n, e[O]);
        let c = Math.ceil((h * 1.5) / 8),
          f = [],
          u = [];
        function d(O, m, g, Q, y) {
          for (let x = g; x < Q; ) {
            let k = x,
              b = m[x],
              w = Gn(n, O[x]);
            for (x++; x < Q; x++) {
              let P = Gn(n, O[x]);
              if (w + P >= c) break;
              w += P;
            }
            if (x == k + 1) {
              if (w > c) {
                let P = O[k];
                d(P.children, P.positions, 0, P.children.length, m[k] + y);
                continue;
              }
              f.push(O[k]);
            } else {
              let P = m[x - 1] + O[x - 1].length - b;
              f.push(Go(n, O, m, k, x, b, P, null, a));
            }
            u.push(b + y - s);
          }
        }
        return d(e, t, i, r, 0), (l || a)(f, u, o);
      }
      class Sf {
        constructor() {
          this.map = new WeakMap();
        }
        setBuffer(e, t, i) {
          let r = this.map.get(e);
          r || this.map.set(e, (r = new Map())), r.set(t, i);
        }
        getBuffer(e, t) {
          let i = this.map.get(e);
          return i && i.get(t);
        }
        set(e, t) {
          e instanceof tt
            ? this.setBuffer(e.context.buffer, e.index, t)
            : e instanceof Oe && this.map.set(e.tree, t);
        }
        get(e) {
          return e instanceof tt
            ? this.getBuffer(e.context.buffer, e.index)
            : e instanceof Oe
            ? this.map.get(e.tree)
            : void 0;
        }
        cursorSet(e, t) {
          e.buffer
            ? this.setBuffer(e.buffer.buffer, e.index, t)
            : this.map.set(e.tree, t);
        }
        cursorGet(e) {
          return e.buffer
            ? this.getBuffer(e.buffer.buffer, e.index)
            : this.map.get(e.tree);
        }
      }
      class Ot {
        constructor(e, t, i, r, s = !1, o = !1) {
          (this.from = e),
            (this.to = t),
            (this.tree = i),
            (this.offset = r),
            (this.open = (s ? 1 : 0) | (o ? 2 : 0));
        }
        get openStart() {
          return (this.open & 1) > 0;
        }
        get openEnd() {
          return (this.open & 2) > 0;
        }
        static addTree(e, t = [], i = !1) {
          let r = [new Ot(0, e.length, e, 0, !1, i)];
          for (let s of t) s.to > e.length && r.push(s);
          return r;
        }
        static applyChanges(e, t, i = 128) {
          if (!t.length) return e;
          let r = [],
            s = 1,
            o = e.length ? e[0] : null;
          for (let l = 0, a = 0, h = 0; ; l++) {
            let c = l < t.length ? t[l] : null,
              f = c ? c.fromA : 1e9;
            if (f - a >= i)
              for (; o && o.from < f; ) {
                let u = o;
                if (a >= u.from || f <= u.to || h) {
                  let d = Math.max(u.from, a) - h,
                    O = Math.min(u.to, f) - h;
                  u =
                    d >= O
                      ? null
                      : new Ot(d, O, u.tree, u.offset + h, l > 0, !!c);
                }
                if ((u && r.push(u), o.to > f)) break;
                o = s < e.length ? e[s++] : null;
              }
            if (!c) break;
            (a = c.toA), (h = c.toA - c.toB);
          }
          return r;
        }
      }
      class yf {
        startParse(e, t, i) {
          return (
            typeof e == "string" && (e = new Cm(e)),
            (i = i
              ? i.length
                ? i.map((r) => new ze(r.from, r.to))
                : [new ze(0, 0)]
              : [new ze(0, e.length)]),
            this.createParse(e, t || [], i)
          );
        }
        parse(e, t, i) {
          let r = this.startParse(e, t, i);
          for (;;) {
            let s = r.advance();
            if (s) return s;
          }
        }
      }
      class Cm {
        constructor(e) {
          this.string = e;
        }
        get length() {
          return this.string.length;
        }
        chunk(e) {
          return this.string.slice(e);
        }
        get lineChunks() {
          return !1;
        }
        read(e, t) {
          return this.string.slice(e, t);
        }
      }
      function Zm(n) {
        return (e, t, i, r) => new Xm(e, n, t, i, r);
      }
      class ka {
        constructor(e, t, i, r, s) {
          (this.parser = e),
            (this.parse = t),
            (this.overlay = i),
            (this.target = r),
            (this.from = s);
        }
      }
      function $a(n) {
        if (!n.length || n.some((e) => e.from >= e.to))
          throw new RangeError(
            "Invalid inner parse ranges given: " + JSON.stringify(n)
          );
      }
      class Am {
        constructor(e, t, i, r, s, o, l) {
          (this.parser = e),
            (this.predicate = t),
            (this.mounts = i),
            (this.index = r),
            (this.start = s),
            (this.target = o),
            (this.prev = l),
            (this.depth = 0),
            (this.ranges = []);
        }
      }
      const uo = new Y({ perNode: !0 });
      class Xm {
        constructor(e, t, i, r, s) {
          (this.nest = t),
            (this.input = i),
            (this.fragments = r),
            (this.ranges = s),
            (this.inner = []),
            (this.innerDone = 0),
            (this.baseTree = null),
            (this.stoppedAt = null),
            (this.baseParse = e);
        }
        advance() {
          if (this.baseParse) {
            let i = this.baseParse.advance();
            if (!i) return null;
            if (
              ((this.baseParse = null),
              (this.baseTree = i),
              this.startInner(),
              this.stoppedAt != null)
            )
              for (let r of this.inner) r.parse.stopAt(this.stoppedAt);
          }
          if (this.innerDone == this.inner.length) {
            let i = this.baseTree;
            return (
              this.stoppedAt != null &&
                (i = new K(
                  i.type,
                  i.children,
                  i.positions,
                  i.length,
                  i.propValues.concat([[uo, this.stoppedAt]])
                )),
              i
            );
          }
          let e = this.inner[this.innerDone],
            t = e.parse.advance();
          if (t) {
            this.innerDone++;
            let i = Object.assign(Object.create(null), e.target.props);
            (i[Y.mounted.id] = new Ui(t, e.overlay, e.parser)),
              (e.target.props = i);
          }
          return null;
        }
        get parsedPos() {
          if (this.baseParse) return 0;
          let e = this.input.length;
          for (let t = this.innerDone; t < this.inner.length; t++)
            this.inner[t].from < e &&
              (e = Math.min(e, this.inner[t].parse.parsedPos));
          return e;
        }
        stopAt(e) {
          if (((this.stoppedAt = e), this.baseParse)) this.baseParse.stopAt(e);
          else
            for (let t = this.innerDone; t < this.inner.length; t++)
              this.inner[t].parse.stopAt(e);
        }
        startInner() {
          let e = new Ym(this.fragments),
            t = null,
            i = null,
            r = new lr(
              new Oe(this.baseTree, this.ranges[0].from, 0, null),
              N.IncludeAnonymous | N.IgnoreMounts
            );
          e: for (let s, o; ; ) {
            let l = !0,
              a;
            if (this.stoppedAt != null && r.from >= this.stoppedAt) l = !1;
            else if (e.hasNode(r)) {
              if (t) {
                let h = t.mounts.find(
                  (c) =>
                    c.frag.from <= r.from &&
                    c.frag.to >= r.to &&
                    c.mount.overlay
                );
                if (h)
                  for (let c of h.mount.overlay) {
                    let f = c.from + h.pos,
                      u = c.to + h.pos;
                    f >= r.from &&
                      u <= r.to &&
                      !t.ranges.some((d) => d.from < u && d.to > f) &&
                      t.ranges.push({ from: f, to: u });
                  }
              }
              l = !1;
            } else if (i && (o = Rm(i.ranges, r.from, r.to))) l = o != 2;
            else if (
              !r.type.isAnonymous &&
              (s = this.nest(r, this.input)) &&
              (r.from < r.to || !s.overlay)
            ) {
              r.tree || Mm(r);
              let h = e.findMounts(r.from, s.parser);
              if (typeof s.overlay == "function")
                t = new Am(
                  s.parser,
                  s.overlay,
                  h,
                  this.inner.length,
                  r.from,
                  r.tree,
                  t
                );
              else {
                let c = Ta(
                  this.ranges,
                  s.overlay || (r.from < r.to ? [new ze(r.from, r.to)] : [])
                );
                c.length && $a(c),
                  (c.length || !s.overlay) &&
                    this.inner.push(
                      new ka(
                        s.parser,
                        c.length
                          ? s.parser.startParse(this.input, Ca(h, c), c)
                          : s.parser.startParse(""),
                        s.overlay
                          ? s.overlay.map(
                              (f) => new ze(f.from - r.from, f.to - r.from)
                            )
                          : null,
                        r.tree,
                        c.length ? c[0].from : r.from
                      )
                    ),
                  s.overlay
                    ? c.length && (i = { ranges: c, depth: 0, prev: i })
                    : (l = !1);
              }
            } else if (
              t &&
              (a = t.predicate(r)) &&
              (a === !0 && (a = new ze(r.from, r.to)), a.from < a.to)
            ) {
              let h = t.ranges.length - 1;
              h >= 0 && t.ranges[h].to == a.from
                ? (t.ranges[h] = { from: t.ranges[h].from, to: a.to })
                : t.ranges.push(a);
            }
            if (l && r.firstChild()) t && t.depth++, i && i.depth++;
            else
              for (; !r.nextSibling(); ) {
                if (!r.parent()) break e;
                if (t && !--t.depth) {
                  let h = Ta(this.ranges, t.ranges);
                  h.length &&
                    ($a(h),
                    this.inner.splice(
                      t.index,
                      0,
                      new ka(
                        t.parser,
                        t.parser.startParse(this.input, Ca(t.mounts, h), h),
                        t.ranges.map(
                          (c) => new ze(c.from - t.start, c.to - t.start)
                        ),
                        t.target,
                        h[0].from
                      )
                    )),
                    (t = t.prev);
                }
                i && !--i.depth && (i = i.prev);
              }
          }
        }
      }
      function Rm(n, e, t) {
        for (let i of n) {
          if (i.from >= t) break;
          if (i.to > e) return i.from <= e && i.to >= t ? 2 : 1;
        }
        return 0;
      }
      function Pa(n, e, t, i, r, s) {
        if (e < t) {
          let o = n.buffer[e + 1];
          i.push(n.slice(e, t, o)), r.push(o - s);
        }
      }
      function Mm(n) {
        let { node: e } = n,
          t = [],
          i = e.context.buffer;
        do t.push(n.index), n.parent();
        while (!n.tree);
        let r = n.tree,
          s = r.children.indexOf(i),
          o = r.children[s],
          l = o.buffer,
          a = [s];
        function h(c, f, u, d, O, m) {
          let g = t[m],
            Q = [],
            y = [];
          Pa(o, c, g, Q, y, d);
          let x = l[g + 1],
            k = l[g + 2];
          a.push(Q.length);
          let b = m
            ? h(g + 4, l[g + 3], o.set.types[l[g]], x, k - x, m - 1)
            : e.toTree();
          return (
            Q.push(b),
            y.push(x - d),
            Pa(o, l[g + 3], f, Q, y, d),
            new K(u, Q, y, O)
          );
        }
        r.children[s] = h(0, l.length, Se.none, 0, o.length, t.length - 1);
        for (let c of a) {
          let f = n.tree.children[c],
            u = n.tree.positions[c];
          n.yield(new Oe(f, u + n.from, c, n._tree));
        }
      }
      class va {
        constructor(e, t) {
          (this.offset = t),
            (this.done = !1),
            (this.cursor = e.cursor(N.IncludeAnonymous | N.IgnoreMounts));
        }
        moveTo(e) {
          let { cursor: t } = this,
            i = e - this.offset;
          for (; !this.done && t.from < i; )
            (t.to >= e && t.enter(i, 1, N.IgnoreOverlays | N.ExcludeBuffers)) ||
              t.next(!1) ||
              (this.done = !0);
        }
        hasNode(e) {
          if (
            (this.moveTo(e.from),
            !this.done &&
              this.cursor.from + this.offset == e.from &&
              this.cursor.tree)
          )
            for (let t = this.cursor.tree; ; ) {
              if (t == e.tree) return !0;
              if (
                t.children.length &&
                t.positions[0] == 0 &&
                t.children[0] instanceof K
              )
                t = t.children[0];
              else break;
            }
          return !1;
        }
      }
      let Ym = class {
        constructor(e) {
          var t;
          if (
            ((this.fragments = e), (this.curTo = 0), (this.fragI = 0), e.length)
          ) {
            let i = (this.curFrag = e[0]);
            (this.curTo =
              (t = i.tree.prop(uo)) !== null && t !== void 0 ? t : i.to),
              (this.inner = new va(i.tree, -i.offset));
          } else this.curFrag = this.inner = null;
        }
        hasNode(e) {
          for (; this.curFrag && e.from >= this.curTo; ) this.nextFrag();
          return (
            this.curFrag &&
            this.curFrag.from <= e.from &&
            this.curTo >= e.to &&
            this.inner.hasNode(e)
          );
        }
        nextFrag() {
          var e;
          if ((this.fragI++, this.fragI == this.fragments.length))
            this.curFrag = this.inner = null;
          else {
            let t = (this.curFrag = this.fragments[this.fragI]);
            (this.curTo =
              (e = t.tree.prop(uo)) !== null && e !== void 0 ? e : t.to),
              (this.inner = new va(t.tree, -t.offset));
          }
        }
        findMounts(e, t) {
          var i;
          let r = [];
          if (this.inner) {
            this.inner.cursor.moveTo(e, 1);
            for (let s = this.inner.cursor.node; s; s = s.parent) {
              let o =
                (i = s.tree) === null || i === void 0
                  ? void 0
                  : i.prop(Y.mounted);
              if (o && o.parser == t)
                for (let l = this.fragI; l < this.fragments.length; l++) {
                  let a = this.fragments[l];
                  if (a.from >= s.to) break;
                  a.tree == this.curFrag.tree &&
                    r.push({ frag: a, pos: s.from - a.offset, mount: o });
                }
            }
          }
          return r;
        }
      };
      function Ta(n, e) {
        let t = null,
          i = e;
        for (let r = 1, s = 0; r < n.length; r++) {
          let o = n[r - 1].to,
            l = n[r].from;
          for (; s < i.length; s++) {
            let a = i[s];
            if (a.from >= l) break;
            a.to <= o ||
              (t || (i = t = e.slice()),
              a.from < o
                ? ((t[s] = new ze(a.from, o)),
                  a.to > l && t.splice(s + 1, 0, new ze(l, a.to)))
                : a.to > l
                ? (t[s--] = new ze(l, a.to))
                : t.splice(s--, 1));
          }
        }
        return i;
      }
      function zm(n, e, t, i) {
        let r = 0,
          s = 0,
          o = !1,
          l = !1,
          a = -1e9,
          h = [];
        for (;;) {
          let c = r == n.length ? 1e9 : o ? n[r].to : n[r].from,
            f = s == e.length ? 1e9 : l ? e[s].to : e[s].from;
          if (o != l) {
            let u = Math.max(a, t),
              d = Math.min(c, f, i);
            u < d && h.push(new ze(u, d));
          }
          if (((a = Math.min(c, f)), a == 1e9)) break;
          c == a && (o ? ((o = !1), r++) : (o = !0)),
            f == a && (l ? ((l = !1), s++) : (l = !0));
        }
        return h;
      }
      function Ca(n, e) {
        let t = [];
        for (let { pos: i, mount: r, frag: s } of n) {
          let o = i + (r.overlay ? r.overlay[0].from : 0),
            l = o + r.tree.length,
            a = Math.max(s.from, o),
            h = Math.min(s.to, l);
          if (r.overlay) {
            let c = r.overlay.map((u) => new ze(u.from + i, u.to + i)),
              f = zm(e, c, a, h);
            for (let u = 0, d = a; ; u++) {
              let O = u == f.length,
                m = O ? h : f[u].from;
              if (
                (m > d &&
                  t.push(
                    new Ot(
                      d,
                      m,
                      r.tree,
                      -o,
                      s.from >= d || s.openStart,
                      s.to <= m || s.openEnd
                    )
                  ),
                O)
              )
                break;
              d = f[u].to;
            }
          } else
            t.push(
              new Ot(
                a,
                h,
                r.tree,
                -o,
                s.from >= o || s.openStart,
                s.to <= l || s.openEnd
              )
            );
        }
        return t;
      }
      let Dm = 0;
      class Ye {
        constructor(e, t, i, r) {
          (this.name = e),
            (this.set = t),
            (this.base = i),
            (this.modified = r),
            (this.id = Dm++);
        }
        toString() {
          let { name: e } = this;
          for (let t of this.modified) t.name && (e = `${t.name}(${e})`);
          return e;
        }
        static define(e, t) {
          let i = typeof e == "string" ? e : "?";
          if ((e instanceof Ye && (t = e), t?.base))
            throw new Error("Can not derive from a modified tag");
          let r = new Ye(i, [], null, []);
          if ((r.set.push(r), t)) for (let s of t.set) r.set.push(s);
          return r;
        }
        static defineModifier(e) {
          let t = new ar(e);
          return (i) =>
            i.modified.indexOf(t) > -1
              ? i
              : ar.get(
                  i.base || i,
                  i.modified.concat(t).sort((r, s) => r.id - s.id)
                );
        }
      }
      let Em = 0;
      class ar {
        constructor(e) {
          (this.name = e), (this.instances = []), (this.id = Em++);
        }
        static get(e, t) {
          if (!t.length) return e;
          let i = t[0].instances.find((l) => l.base == e && _m(t, l.modified));
          if (i) return i;
          let r = [],
            s = new Ye(e.name, r, e, t);
          for (let l of t) l.instances.push(s);
          let o = Vm(t);
          for (let l of e.set)
            if (!l.modified.length) for (let a of o) r.push(ar.get(l, a));
          return s;
        }
      }
      function _m(n, e) {
        return n.length == e.length && n.every((t, i) => t == e[i]);
      }
      function Vm(n) {
        let e = [[]];
        for (let t = 0; t < n.length; t++)
          for (let i = 0, r = e.length; i < r; i++) e.push(e[i].concat(n[t]));
        return e.sort((t, i) => i.length - t.length);
      }
      function zr(n) {
        let e = Object.create(null);
        for (let t in n) {
          let i = n[t];
          Array.isArray(i) || (i = [i]);
          for (let r of t.split(" "))
            if (r) {
              let s = [],
                o = 2,
                l = r;
              for (let f = 0; ; ) {
                if (l == "..." && f > 0 && f + 3 == r.length) {
                  o = 1;
                  break;
                }
                let u = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(l);
                if (!u) throw new RangeError("Invalid path: " + r);
                if (
                  (s.push(
                    u[0] == "*" ? "" : u[0][0] == '"' ? JSON.parse(u[0]) : u[0]
                  ),
                  (f += u[0].length),
                  f == r.length)
                )
                  break;
                let d = r[f++];
                if (f == r.length && d == "!") {
                  o = 0;
                  break;
                }
                if (d != "/") throw new RangeError("Invalid path: " + r);
                l = r.slice(f);
              }
              let a = s.length - 1,
                h = s[a];
              if (!h) throw new RangeError("Invalid path: " + r);
              let c = new hr(i, o, a > 0 ? s.slice(0, a) : null);
              e[h] = c.sort(e[h]);
            }
        }
        return bf.add(e);
      }
      const bf = new Y();
      class hr {
        constructor(e, t, i, r) {
          (this.tags = e), (this.mode = t), (this.context = i), (this.next = r);
        }
        get opaque() {
          return this.mode == 0;
        }
        get inherit() {
          return this.mode == 1;
        }
        sort(e) {
          return !e || e.depth < this.depth
            ? ((this.next = e), this)
            : ((e.next = this.sort(e.next)), e);
        }
        get depth() {
          return this.context ? this.context.length : 0;
        }
      }
      hr.empty = new hr([], 2, null);
      function xf(n, e) {
        let t = Object.create(null);
        for (let s of n)
          if (!Array.isArray(s.tag)) t[s.tag.id] = s.class;
          else for (let o of s.tag) t[o.id] = s.class;
        let { scope: i, all: r = null } = e || {};
        return {
          style: (s) => {
            let o = r;
            for (let l of s)
              for (let a of l.set) {
                let h = t[a.id];
                if (h) {
                  o = o ? o + " " + h : h;
                  break;
                }
              }
            return o;
          },
          scope: i,
        };
      }
      function qm(n, e) {
        let t = null;
        for (let i of n) {
          let r = i.style(e);
          r && (t = t ? t + " " + r : r);
        }
        return t;
      }
      function Wm(n, e, t, i = 0, r = n.length) {
        let s = new Lm(i, Array.isArray(e) ? e : [e], t);
        s.highlightRange(n.cursor(), i, r, "", s.highlighters), s.flush(r);
      }
      class Lm {
        constructor(e, t, i) {
          (this.at = e),
            (this.highlighters = t),
            (this.span = i),
            (this.class = "");
        }
        startSpan(e, t) {
          t != this.class &&
            (this.flush(e), e > this.at && (this.at = e), (this.class = t));
        }
        flush(e) {
          e > this.at && this.class && this.span(this.at, e, this.class);
        }
        highlightRange(e, t, i, r, s) {
          let { type: o, from: l, to: a } = e;
          if (l >= i || a <= t) return;
          o.isTop &&
            (s = this.highlighters.filter((d) => !d.scope || d.scope(o)));
          let h = r,
            c = jm(e) || hr.empty,
            f = qm(s, c.tags);
          if (
            (f &&
              (h && (h += " "),
              (h += f),
              c.mode == 1 && (r += (r ? " " : "") + f)),
            this.startSpan(Math.max(t, l), h),
            c.opaque)
          )
            return;
          let u = e.tree && e.tree.prop(Y.mounted);
          if (u && u.overlay) {
            let d = e.node.enter(u.overlay[0].from + l, 1),
              O = this.highlighters.filter(
                (g) => !g.scope || g.scope(u.tree.type)
              ),
              m = e.firstChild();
            for (let g = 0, Q = l; ; g++) {
              let y = g < u.overlay.length ? u.overlay[g] : null,
                x = y ? y.from + l : a,
                k = Math.max(t, Q),
                b = Math.min(i, x);
              if (k < b && m)
                for (
                  ;
                  e.from < b &&
                  (this.highlightRange(e, k, b, r, s),
                  this.startSpan(Math.min(b, e.to), h),
                  !(e.to >= x || !e.nextSibling()));

                );
              if (!y || x > i) break;
              (Q = y.to + l),
                Q > t &&
                  (this.highlightRange(
                    d.cursor(),
                    Math.max(t, y.from + l),
                    Math.min(i, Q),
                    "",
                    O
                  ),
                  this.startSpan(Math.min(i, Q), h));
            }
            m && e.parent();
          } else if (e.firstChild()) {
            u && (r = "");
            do
              if (!(e.to <= t)) {
                if (e.from >= i) break;
                this.highlightRange(e, t, i, r, s),
                  this.startSpan(Math.min(i, e.to), h);
              }
            while (e.nextSibling());
            e.parent();
          }
        }
      }
      function jm(n) {
        let e = n.type.prop(bf);
        for (; e && e.context && !n.matchContext(e.context); ) e = e.next;
        return e || null;
      }
      const $ = Ye.define,
        Zn = $(),
        yt = $(),
        Za = $(yt),
        Aa = $(yt),
        bt = $(),
        An = $(bt),
        os = $(bt),
        He = $(),
        Yt = $(He),
        Ue = $(),
        Fe = $(),
        Oo = $(),
        ki = $(Oo),
        Xn = $(),
        p = {
          comment: Zn,
          lineComment: $(Zn),
          blockComment: $(Zn),
          docComment: $(Zn),
          name: yt,
          variableName: $(yt),
          typeName: Za,
          tagName: $(Za),
          propertyName: Aa,
          attributeName: $(Aa),
          className: $(yt),
          labelName: $(yt),
          namespace: $(yt),
          macroName: $(yt),
          literal: bt,
          string: An,
          docString: $(An),
          character: $(An),
          attributeValue: $(An),
          number: os,
          integer: $(os),
          float: $(os),
          bool: $(bt),
          regexp: $(bt),
          escape: $(bt),
          color: $(bt),
          url: $(bt),
          keyword: Ue,
          self: $(Ue),
          null: $(Ue),
          atom: $(Ue),
          unit: $(Ue),
          modifier: $(Ue),
          operatorKeyword: $(Ue),
          controlKeyword: $(Ue),
          definitionKeyword: $(Ue),
          moduleKeyword: $(Ue),
          operator: Fe,
          derefOperator: $(Fe),
          arithmeticOperator: $(Fe),
          logicOperator: $(Fe),
          bitwiseOperator: $(Fe),
          compareOperator: $(Fe),
          updateOperator: $(Fe),
          definitionOperator: $(Fe),
          typeOperator: $(Fe),
          controlOperator: $(Fe),
          punctuation: Oo,
          separator: $(Oo),
          bracket: ki,
          angleBracket: $(ki),
          squareBracket: $(ki),
          paren: $(ki),
          brace: $(ki),
          content: He,
          heading: Yt,
          heading1: $(Yt),
          heading2: $(Yt),
          heading3: $(Yt),
          heading4: $(Yt),
          heading5: $(Yt),
          heading6: $(Yt),
          contentSeparator: $(He),
          list: $(He),
          quote: $(He),
          emphasis: $(He),
          strong: $(He),
          link: $(He),
          monospace: $(He),
          strikethrough: $(He),
          inserted: $(),
          deleted: $(),
          changed: $(),
          invalid: $(),
          meta: Xn,
          documentMeta: $(Xn),
          annotation: $(Xn),
          processingInstruction: $(Xn),
          definition: Ye.defineModifier("definition"),
          constant: Ye.defineModifier("constant"),
          function: Ye.defineModifier("function"),
          standard: Ye.defineModifier("standard"),
          local: Ye.defineModifier("local"),
          special: Ye.defineModifier("special"),
        };
      for (let n in p) {
        let e = p[n];
        e instanceof Ye && (e.name = n);
      }
      xf([
        { tag: p.link, class: "tok-link" },
        { tag: p.heading, class: "tok-heading" },
        { tag: p.emphasis, class: "tok-emphasis" },
        { tag: p.strong, class: "tok-strong" },
        { tag: p.keyword, class: "tok-keyword" },
        { tag: p.atom, class: "tok-atom" },
        { tag: p.bool, class: "tok-bool" },
        { tag: p.url, class: "tok-url" },
        { tag: p.labelName, class: "tok-labelName" },
        { tag: p.inserted, class: "tok-inserted" },
        { tag: p.deleted, class: "tok-deleted" },
        { tag: p.literal, class: "tok-literal" },
        { tag: p.string, class: "tok-string" },
        { tag: p.number, class: "tok-number" },
        {
          tag: [p.regexp, p.escape, p.special(p.string)],
          class: "tok-string2",
        },
        { tag: p.variableName, class: "tok-variableName" },
        { tag: p.local(p.variableName), class: "tok-variableName tok-local" },
        {
          tag: p.definition(p.variableName),
          class: "tok-variableName tok-definition",
        },
        { tag: p.special(p.variableName), class: "tok-variableName2" },
        {
          tag: p.definition(p.propertyName),
          class: "tok-propertyName tok-definition",
        },
        { tag: p.typeName, class: "tok-typeName" },
        { tag: p.namespace, class: "tok-namespace" },
        { tag: p.className, class: "tok-className" },
        { tag: p.macroName, class: "tok-macroName" },
        { tag: p.propertyName, class: "tok-propertyName" },
        { tag: p.operator, class: "tok-operator" },
        { tag: p.comment, class: "tok-comment" },
        { tag: p.meta, class: "tok-meta" },
        { tag: p.invalid, class: "tok-invalid" },
        { tag: p.punctuation, class: "tok-punctuation" },
      ]);
      var ls;
      const Kt = new Y();
      function wf(n) {
        return C.define({ combine: n ? (e) => e.concat(n) : void 0 });
      }
      const No = new Y();
      class We {
        constructor(e, t, i = [], r = "") {
          (this.data = e),
            (this.name = r),
            _.prototype.hasOwnProperty("tree") ||
              Object.defineProperty(_.prototype, "tree", {
                get() {
                  return J(this);
                },
              }),
            (this.parser = t),
            (this.extension = [
              At.of(this),
              _.languageData.of((s, o, l) => {
                let a = Xa(s, o, l),
                  h = a.type.prop(Kt);
                if (!h) return [];
                let c = s.facet(h),
                  f = a.type.prop(No);
                if (f) {
                  let u = a.resolve(o - a.from, l);
                  for (let d of f)
                    if (d.test(u, s)) {
                      let O = s.facet(d.facet);
                      return d.type == "replace" ? O : O.concat(c);
                    }
                }
                return c;
              }),
            ].concat(i));
        }
        isActiveAt(e, t, i = -1) {
          return Xa(e, t, i).type.prop(Kt) == this.data;
        }
        findRegions(e) {
          let t = e.facet(At);
          if (t?.data == this.data) return [{ from: 0, to: e.doc.length }];
          if (!t || !t.allowsNesting) return [];
          let i = [],
            r = (s, o) => {
              if (s.prop(Kt) == this.data) {
                i.push({ from: o, to: o + s.length });
                return;
              }
              let l = s.prop(Y.mounted);
              if (l) {
                if (l.tree.prop(Kt) == this.data) {
                  if (l.overlay)
                    for (let a of l.overlay)
                      i.push({ from: a.from + o, to: a.to + o });
                  else i.push({ from: o, to: o + s.length });
                  return;
                } else if (l.overlay) {
                  let a = i.length;
                  if ((r(l.tree, l.overlay[0].from + o), i.length > a)) return;
                }
              }
              for (let a = 0; a < s.children.length; a++) {
                let h = s.children[a];
                h instanceof K && r(h, s.positions[a] + o);
              }
            };
          return r(J(e), 0), i;
        }
        get allowsNesting() {
          return !0;
        }
      }
      We.setState = R.define();
      function Xa(n, e, t) {
        let i = n.facet(At),
          r = J(n).topNode;
        if (!i || i.allowsNesting)
          for (let s = r; s; s = s.enter(e, t, N.ExcludeBuffers))
            s.type.isTop && (r = s);
        return r;
      }
      class ci extends We {
        constructor(e, t, i) {
          super(e, t, [], i), (this.parser = t);
        }
        static define(e) {
          let t = wf(e.languageData);
          return new ci(
            t,
            e.parser.configure({
              props: [Kt.add((i) => (i.isTop ? t : void 0))],
            }),
            e.name
          );
        }
        configure(e, t) {
          return new ci(this.data, this.parser.configure(e), t || this.name);
        }
        get allowsNesting() {
          return this.parser.hasWrappers();
        }
      }
      function J(n) {
        let e = n.field(We.state, !1);
        return e ? e.tree : K.empty;
      }
      class Bm {
        constructor(e) {
          (this.doc = e),
            (this.cursorPos = 0),
            (this.string = ""),
            (this.cursor = e.iter());
        }
        get length() {
          return this.doc.length;
        }
        syncTo(e) {
          return (
            (this.string = this.cursor.next(e - this.cursorPos).value),
            (this.cursorPos = e + this.string.length),
            this.cursorPos - this.string.length
          );
        }
        chunk(e) {
          return this.syncTo(e), this.string;
        }
        get lineChunks() {
          return !0;
        }
        read(e, t) {
          let i = this.cursorPos - this.string.length;
          return e < i || t >= this.cursorPos
            ? this.doc.sliceString(e, t)
            : this.string.slice(e - i, t - i);
        }
      }
      let $i = null;
      class cr {
        constructor(e, t, i = [], r, s, o, l, a) {
          (this.parser = e),
            (this.state = t),
            (this.fragments = i),
            (this.tree = r),
            (this.treeLen = s),
            (this.viewport = o),
            (this.skipped = l),
            (this.scheduleOn = a),
            (this.parse = null),
            (this.tempSkipped = []);
        }
        static create(e, t, i) {
          return new cr(e, t, [], K.empty, 0, i, [], null);
        }
        startParse() {
          return this.parser.startParse(new Bm(this.state.doc), this.fragments);
        }
        work(e, t) {
          return (
            t != null && t >= this.state.doc.length && (t = void 0),
            this.tree != K.empty && this.isDone(t ?? this.state.doc.length)
              ? (this.takeTree(), !0)
              : this.withContext(() => {
                  var i;
                  if (typeof e == "number") {
                    let r = Date.now() + e;
                    e = () => Date.now() > r;
                  }
                  for (
                    this.parse || (this.parse = this.startParse()),
                      t != null &&
                        (this.parse.stoppedAt == null ||
                          this.parse.stoppedAt > t) &&
                        t < this.state.doc.length &&
                        this.parse.stopAt(t);
                    ;

                  ) {
                    let r = this.parse.advance();
                    if (r)
                      if (
                        ((this.fragments = this.withoutTempSkipped(
                          Ot.addTree(
                            r,
                            this.fragments,
                            this.parse.stoppedAt != null
                          )
                        )),
                        (this.treeLen =
                          (i = this.parse.stoppedAt) !== null && i !== void 0
                            ? i
                            : this.state.doc.length),
                        (this.tree = r),
                        (this.parse = null),
                        this.treeLen < (t ?? this.state.doc.length))
                      )
                        this.parse = this.startParse();
                      else return !0;
                    if (e()) return !1;
                  }
                })
          );
        }
        takeTree() {
          let e, t;
          this.parse &&
            (e = this.parse.parsedPos) >= this.treeLen &&
            ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) &&
              this.parse.stopAt(e),
            this.withContext(() => {
              for (; !(t = this.parse.advance()); );
            }),
            (this.treeLen = e),
            (this.tree = t),
            (this.fragments = this.withoutTempSkipped(
              Ot.addTree(this.tree, this.fragments, !0)
            )),
            (this.parse = null));
        }
        withContext(e) {
          let t = $i;
          $i = this;
          try {
            return e();
          } finally {
            $i = t;
          }
        }
        withoutTempSkipped(e) {
          for (let t; (t = this.tempSkipped.pop()); ) e = Ra(e, t.from, t.to);
          return e;
        }
        changes(e, t) {
          let {
            fragments: i,
            tree: r,
            treeLen: s,
            viewport: o,
            skipped: l,
          } = this;
          if ((this.takeTree(), !e.empty)) {
            let a = [];
            if (
              (e.iterChangedRanges((h, c, f, u) =>
                a.push({ fromA: h, toA: c, fromB: f, toB: u })
              ),
              (i = Ot.applyChanges(i, a)),
              (r = K.empty),
              (s = 0),
              (o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }),
              this.skipped.length)
            ) {
              l = [];
              for (let h of this.skipped) {
                let c = e.mapPos(h.from, 1),
                  f = e.mapPos(h.to, -1);
                c < f && l.push({ from: c, to: f });
              }
            }
          }
          return new cr(this.parser, t, i, r, s, o, l, this.scheduleOn);
        }
        updateViewport(e) {
          if (this.viewport.from == e.from && this.viewport.to == e.to)
            return !1;
          this.viewport = e;
          let t = this.skipped.length;
          for (let i = 0; i < this.skipped.length; i++) {
            let { from: r, to: s } = this.skipped[i];
            r < e.to &&
              s > e.from &&
              ((this.fragments = Ra(this.fragments, r, s)),
              this.skipped.splice(i--, 1));
          }
          return this.skipped.length >= t ? !1 : (this.reset(), !0);
        }
        reset() {
          this.parse && (this.takeTree(), (this.parse = null));
        }
        skipUntilInView(e, t) {
          this.skipped.push({ from: e, to: t });
        }
        static getSkippingParser(e) {
          return new (class extends yf {
            createParse(t, i, r) {
              let s = r[0].from,
                o = r[r.length - 1].to;
              return {
                parsedPos: s,
                advance() {
                  let a = $i;
                  if (a) {
                    for (let h of r) a.tempSkipped.push(h);
                    e &&
                      (a.scheduleOn = a.scheduleOn
                        ? Promise.all([a.scheduleOn, e])
                        : e);
                  }
                  return (this.parsedPos = o), new K(Se.none, [], [], o - s);
                },
                stoppedAt: null,
                stopAt() {},
              };
            }
          })();
        }
        isDone(e) {
          e = Math.min(e, this.state.doc.length);
          let t = this.fragments;
          return (
            this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e
          );
        }
        static get() {
          return $i;
        }
      }
      function Ra(n, e, t) {
        return Ot.applyChanges(n, [{ fromA: e, toA: t, fromB: e, toB: t }]);
      }
      class fi {
        constructor(e) {
          (this.context = e), (this.tree = e.tree);
        }
        apply(e) {
          if (!e.docChanged && this.tree == this.context.tree) return this;
          let t = this.context.changes(e.changes, e.state),
            i =
              this.context.treeLen == e.startState.doc.length
                ? void 0
                : Math.max(
                    e.changes.mapPos(this.context.treeLen),
                    t.viewport.to
                  );
          return t.work(20, i) || t.takeTree(), new fi(t);
        }
        static init(e) {
          let t = Math.min(3e3, e.doc.length),
            i = cr.create(e.facet(At).parser, e, { from: 0, to: t });
          return i.work(20, t) || i.takeTree(), new fi(i);
        }
      }
      We.state = oe.define({
        create: fi.init,
        update(n, e) {
          for (let t of e.effects) if (t.is(We.setState)) return t.value;
          return e.startState.facet(At) != e.state.facet(At)
            ? fi.init(e.state)
            : n.apply(e);
        },
      });
      let kf = (n) => {
        let e = setTimeout(() => n(), 500);
        return () => clearTimeout(e);
      };
      typeof requestIdleCallback < "u" &&
        (kf = (n) => {
          let e = -1,
            t = setTimeout(() => {
              e = requestIdleCallback(n, { timeout: 400 });
            }, 100);
          return () => (e < 0 ? clearTimeout(t) : cancelIdleCallback(e));
        });
      const as =
          typeof navigator < "u" &&
          !((ls = navigator.scheduling) === null || ls === void 0) &&
          ls.isInputPending
            ? () => navigator.scheduling.isInputPending()
            : null,
        Im = ne.fromClass(
          class {
            constructor(e) {
              (this.view = e),
                (this.working = null),
                (this.workScheduled = 0),
                (this.chunkEnd = -1),
                (this.chunkBudget = -1),
                (this.work = this.work.bind(this)),
                this.scheduleWork();
            }
            update(e) {
              let t = this.view.state.field(We.state).context;
              (t.updateViewport(e.view.viewport) ||
                this.view.viewport.to > t.treeLen) &&
                this.scheduleWork(),
                (e.docChanged || e.selectionSet) &&
                  (this.view.hasFocus && (this.chunkBudget += 50),
                  this.scheduleWork()),
                this.checkAsyncSchedule(t);
            }
            scheduleWork() {
              if (this.working) return;
              let { state: e } = this.view,
                t = e.field(We.state);
              (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) &&
                (this.working = kf(this.work));
            }
            work(e) {
              this.working = null;
              let t = Date.now();
              if (
                (this.chunkEnd < t &&
                  (this.chunkEnd < 0 || this.view.hasFocus) &&
                  ((this.chunkEnd = t + 3e4), (this.chunkBudget = 3e3)),
                this.chunkBudget <= 0)
              )
                return;
              let {
                  state: i,
                  viewport: { to: r },
                } = this.view,
                s = i.field(We.state);
              if (s.tree == s.context.tree && s.context.isDone(r + 1e5)) return;
              let o =
                  Date.now() +
                  Math.min(
                    this.chunkBudget,
                    100,
                    e && !as ? Math.max(25, e.timeRemaining() - 5) : 1e9
                  ),
                l = s.context.treeLen < r && i.doc.length > r + 1e3,
                a = s.context.work(
                  () => (as && as()) || Date.now() > o,
                  r + (l ? 0 : 1e5)
                );
              (this.chunkBudget -= Date.now() - t),
                (a || this.chunkBudget <= 0) &&
                  (s.context.takeTree(),
                  this.view.dispatch({
                    effects: We.setState.of(new fi(s.context)),
                  })),
                this.chunkBudget > 0 && !(a && !l) && this.scheduleWork(),
                this.checkAsyncSchedule(s.context);
            }
            checkAsyncSchedule(e) {
              e.scheduleOn &&
                (this.workScheduled++,
                e.scheduleOn
                  .then(() => this.scheduleWork())
                  .catch((t) => ke(this.view.state, t))
                  .then(() => this.workScheduled--),
                (e.scheduleOn = null));
            }
            destroy() {
              this.working && this.working();
            }
            isWorking() {
              return !!(this.working || this.workScheduled > 0);
            }
          },
          {
            eventHandlers: {
              focus() {
                this.scheduleWork();
              },
            },
          }
        ),
        At = C.define({
          combine(n) {
            return n.length ? n[0] : null;
          },
          enables: (n) => [
            We.state,
            Im,
            v.contentAttributes.compute([n], (e) => {
              let t = e.facet(n);
              return t && t.name ? { "data-language": t.name } : {};
            }),
          ],
        });
      class Uo {
        constructor(e, t = []) {
          (this.language = e), (this.support = t), (this.extension = [e, t]);
        }
      }
      const Gm = C.define(),
        Dr = C.define({
          combine: (n) => {
            if (!n.length) return "  ";
            let e = n[0];
            if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
              throw new Error("Invalid indent unit: " + JSON.stringify(n[0]));
            return e;
          },
        });
      function fr(n) {
        let e = n.facet(Dr);
        return e.charCodeAt(0) == 9 ? n.tabSize * e.length : e.length;
      }
      function Hi(n, e) {
        let t = "",
          i = n.tabSize,
          r = n.facet(Dr)[0];
        if (r == "	") {
          for (; e >= i; ) (t += "	"), (e -= i);
          r = " ";
        }
        for (let s = 0; s < e; s++) t += r;
        return t;
      }
      function Fo(n, e) {
        n instanceof _ && (n = new Er(n));
        for (let i of n.state.facet(Gm)) {
          let r = i(n, e);
          if (r !== void 0) return r;
        }
        let t = J(n.state);
        return t.length >= e ? Nm(n, t, e) : null;
      }
      class Er {
        constructor(e, t = {}) {
          (this.state = e), (this.options = t), (this.unit = fr(e));
        }
        lineAt(e, t = 1) {
          let i = this.state.doc.lineAt(e),
            { simulateBreak: r, simulateDoubleBreak: s } = this.options;
          return r != null && r >= i.from && r <= i.to
            ? s && r == e
              ? { text: "", from: e }
              : (t < 0 ? r < e : r <= e)
              ? { text: i.text.slice(r - i.from), from: r }
              : { text: i.text.slice(0, r - i.from), from: i.from }
            : i;
        }
        textAfterPos(e, t = 1) {
          if (
            this.options.simulateDoubleBreak &&
            e == this.options.simulateBreak
          )
            return "";
          let { text: i, from: r } = this.lineAt(e, t);
          return i.slice(e - r, Math.min(i.length, e + 100 - r));
        }
        column(e, t = 1) {
          let { text: i, from: r } = this.lineAt(e, t),
            s = this.countColumn(i, e - r),
            o = this.options.overrideIndentation
              ? this.options.overrideIndentation(r)
              : -1;
          return o > -1 && (s += o - this.countColumn(i, i.search(/\S|$/))), s;
        }
        countColumn(e, t = e.length) {
          return gi(e, this.state.tabSize, t);
        }
        lineIndent(e, t = 1) {
          let { text: i, from: r } = this.lineAt(e, t),
            s = this.options.overrideIndentation;
          if (s) {
            let o = s(r);
            if (o > -1) return o;
          }
          return this.countColumn(i, i.search(/\S|$/));
        }
        get simulatedBreak() {
          return this.options.simulateBreak || null;
        }
      }
      const _r = new Y();
      function Nm(n, e, t) {
        let i = e.resolveStack(t),
          r = e.resolveInner(t, -1).resolve(t, 0).enterUnfinishedNodesBefore(t);
        if (r != i.node) {
          let s = [];
          for (
            let o = r;
            o &&
            !(
              o.from < i.node.from ||
              o.to > i.node.to ||
              (o.from == i.node.from && o.type == i.node.type)
            );
            o = o.parent
          )
            s.push(o);
          for (let o = s.length - 1; o >= 0; o--) i = { node: s[o], next: i };
        }
        return $f(i, n, t);
      }
      function $f(n, e, t) {
        for (let i = n; i; i = i.next) {
          let r = Fm(i.node);
          if (r) return r(Ho.create(e, t, i));
        }
        return 0;
      }
      function Um(n) {
        return (
          n.pos == n.options.simulateBreak && n.options.simulateDoubleBreak
        );
      }
      function Fm(n) {
        let e = n.type.prop(_r);
        if (e) return e;
        let t = n.firstChild,
          i;
        if (t && (i = t.type.prop(Y.closedBy))) {
          let r = n.lastChild,
            s = r && i.indexOf(r.name) > -1;
          return (o) => Pf(o, !0, 1, void 0, s && !Um(o) ? r.from : void 0);
        }
        return n.parent == null ? Hm : null;
      }
      function Hm() {
        return 0;
      }
      class Ho extends Er {
        constructor(e, t, i) {
          super(e.state, e.options),
            (this.base = e),
            (this.pos = t),
            (this.context = i);
        }
        get node() {
          return this.context.node;
        }
        static create(e, t, i) {
          return new Ho(e, t, i);
        }
        get textAfter() {
          return this.textAfterPos(this.pos);
        }
        get baseIndent() {
          return this.baseIndentFor(this.node);
        }
        baseIndentFor(e) {
          let t = this.state.doc.lineAt(e.from);
          for (;;) {
            let i = e.resolve(t.from);
            for (; i.parent && i.parent.from == i.from; ) i = i.parent;
            if (Km(i, e)) break;
            t = this.state.doc.lineAt(i.from);
          }
          return this.lineIndent(t.from);
        }
        continue() {
          return $f(this.context.next, this.base, this.pos);
        }
      }
      function Km(n, e) {
        for (let t = e; t; t = t.parent) if (n == t) return !0;
        return !1;
      }
      function Jm(n) {
        let e = n.node,
          t = e.childAfter(e.from),
          i = e.lastChild;
        if (!t) return null;
        let r = n.options.simulateBreak,
          s = n.state.doc.lineAt(t.from),
          o = r == null || r <= s.from ? s.to : Math.min(s.to, r);
        for (let l = t.to; ; ) {
          let a = e.childAfter(l);
          if (!a || a == i) return null;
          if (!a.type.isSkipped) {
            if (a.from >= o) return null;
            let h = /^ */.exec(s.text.slice(t.to - s.from))[0].length;
            return { from: t.from, to: t.to + h };
          }
          l = a.to;
        }
      }
      function eg({ closing: n, align: e = !0, units: t = 1 }) {
        return (i) => Pf(i, e, t, n);
      }
      function Pf(n, e, t, i, r) {
        let s = n.textAfter,
          o = s.match(/^\s*/)[0].length,
          l = (i && s.slice(o, o + i.length) == i) || r == n.pos + o,
          a = e ? Jm(n) : null;
        return a
          ? l
            ? n.column(a.from)
            : n.column(a.to)
          : n.baseIndent + (l ? 0 : n.unit * t);
      }
      const tg = (n) => n.baseIndent;
      function Nn({ except: n, units: e = 1 } = {}) {
        return (t) => {
          let i = n && n.test(t.textAfter);
          return t.baseIndent + (i ? 0 : e * t.unit);
        };
      }
      const ig = 200;
      function ng() {
        return _.transactionFilter.of((n) => {
          if (
            !n.docChanged ||
            (!n.isUserEvent("input.type") && !n.isUserEvent("input.complete"))
          )
            return n;
          let e = n.startState.languageDataAt(
            "indentOnInput",
            n.startState.selection.main.head
          );
          if (!e.length) return n;
          let t = n.newDoc,
            { head: i } = n.newSelection.main,
            r = t.lineAt(i);
          if (i > r.from + ig) return n;
          let s = t.sliceString(r.from, i);
          if (!e.some((h) => h.test(s))) return n;
          let { state: o } = n,
            l = -1,
            a = [];
          for (let { head: h } of o.selection.ranges) {
            let c = o.doc.lineAt(h);
            if (c.from == l) continue;
            l = c.from;
            let f = Fo(o, c.from);
            if (f == null) continue;
            let u = /^\s*/.exec(c.text)[0],
              d = Hi(o, f);
            u != d &&
              a.push({ from: c.from, to: c.from + u.length, insert: d });
          }
          return a.length ? [n, { changes: a, sequential: !0 }] : n;
        });
      }
      const rg = C.define(),
        Vr = new Y();
      function vf(n) {
        let e = n.firstChild,
          t = n.lastChild;
        return e && e.to < t.from
          ? { from: e.to, to: t.type.isError ? n.to : t.from }
          : null;
      }
      function sg(n, e, t) {
        let i = J(n);
        if (i.length < t) return null;
        let r = i.resolveStack(t, 1),
          s = null;
        for (let o = r; o; o = o.next) {
          let l = o.node;
          if (l.to <= t || l.from > t) continue;
          if (s && l.from < e) break;
          let a = l.type.prop(Vr);
          if (
            a &&
            (l.to < i.length - 50 || i.length == n.doc.length || !og(l))
          ) {
            let h = a(l, n);
            h && h.from <= t && h.from >= e && h.to > t && (s = h);
          }
        }
        return s;
      }
      function og(n) {
        let e = n.lastChild;
        return e && e.to == n.to && e.type.isError;
      }
      function ur(n, e, t) {
        for (let i of n.facet(rg)) {
          let r = i(n, e, t);
          if (r) return r;
        }
        return sg(n, e, t);
      }
      function Tf(n, e) {
        let t = e.mapPos(n.from, 1),
          i = e.mapPos(n.to, -1);
        return t >= i ? void 0 : { from: t, to: i };
      }
      const qr = R.define({ map: Tf }),
        hn = R.define({ map: Tf });
      function Cf(n) {
        let e = [];
        for (let { head: t } of n.state.selection.ranges)
          e.some((i) => i.from <= t && i.to >= t) || e.push(n.lineBlockAt(t));
        return e;
      }
      const Bt = oe.define({
        create() {
          return A.none;
        },
        update(n, e) {
          e.isUserEvent("delete") &&
            e.changes.iterChangedRanges((t, i) => (n = Ma(n, t, i))),
            (n = n.map(e.changes));
          for (let t of e.effects)
            if (t.is(qr) && !lg(n, t.value.from, t.value.to)) {
              let { preparePlaceholder: i } = e.state.facet(Xf),
                r = i ? A.replace({ widget: new Og(i(e.state, t.value)) }) : Ya;
              n = n.update({ add: [r.range(t.value.from, t.value.to)] });
            } else
              t.is(hn) &&
                (n = n.update({
                  filter: (i, r) => t.value.from != i || t.value.to != r,
                  filterFrom: t.value.from,
                  filterTo: t.value.to,
                }));
          return e.selection && (n = Ma(n, e.selection.main.head)), n;
        },
        provide: (n) => v.decorations.from(n),
        toJSON(n, e) {
          let t = [];
          return (
            n.between(0, e.doc.length, (i, r) => {
              t.push(i, r);
            }),
            t
          );
        },
        fromJSON(n) {
          if (!Array.isArray(n) || n.length % 2)
            throw new RangeError("Invalid JSON for fold state");
          let e = [];
          for (let t = 0; t < n.length; ) {
            let i = n[t++],
              r = n[t++];
            if (typeof i != "number" || typeof r != "number")
              throw new RangeError("Invalid JSON for fold state");
            e.push(Ya.range(i, r));
          }
          return A.set(e, !0);
        },
      });
      function Ma(n, e, t = e) {
        let i = !1;
        return (
          n.between(e, t, (r, s) => {
            r < t && s > e && (i = !0);
          }),
          i
            ? n.update({
                filterFrom: e,
                filterTo: t,
                filter: (r, s) => r >= t || s <= e,
              })
            : n
        );
      }
      function dr(n, e, t) {
        var i;
        let r = null;
        return (
          (i = n.field(Bt, !1)) === null ||
            i === void 0 ||
            i.between(e, t, (s, o) => {
              (!r || r.from > s) && (r = { from: s, to: o });
            }),
          r
        );
      }
      function lg(n, e, t) {
        let i = !1;
        return (
          n.between(e, e, (r, s) => {
            r == e && s == t && (i = !0);
          }),
          i
        );
      }
      function Zf(n, e) {
        return n.field(Bt, !1) ? e : e.concat(R.appendConfig.of(Rf()));
      }
      const ag = (n) => {
          for (let e of Cf(n)) {
            let t = ur(n.state, e.from, e.to);
            if (t)
              return (
                n.dispatch({ effects: Zf(n.state, [qr.of(t), Af(n, t)]) }), !0
              );
          }
          return !1;
        },
        hg = (n) => {
          if (!n.state.field(Bt, !1)) return !1;
          let e = [];
          for (let t of Cf(n)) {
            let i = dr(n.state, t.from, t.to);
            i && e.push(hn.of(i), Af(n, i, !1));
          }
          return e.length && n.dispatch({ effects: e }), e.length > 0;
        };
      function Af(n, e, t = !0) {
        let i = n.state.doc.lineAt(e.from).number,
          r = n.state.doc.lineAt(e.to).number;
        return v.announce.of(
          `${n.state.phrase(
            t ? "Folded lines" : "Unfolded lines"
          )} ${i} ${n.state.phrase("to")} ${r}.`
        );
      }
      const cg = (n) => {
          let { state: e } = n,
            t = [];
          for (let i = 0; i < e.doc.length; ) {
            let r = n.lineBlockAt(i),
              s = ur(e, r.from, r.to);
            s && t.push(qr.of(s)), (i = (s ? n.lineBlockAt(s.to) : r).to + 1);
          }
          return (
            t.length && n.dispatch({ effects: Zf(n.state, t) }), !!t.length
          );
        },
        fg = (n) => {
          let e = n.state.field(Bt, !1);
          if (!e || !e.size) return !1;
          let t = [];
          return (
            e.between(0, n.state.doc.length, (i, r) => {
              t.push(hn.of({ from: i, to: r }));
            }),
            n.dispatch({ effects: t }),
            !0
          );
        },
        ug = [
          { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: ag },
          { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: hg },
          { key: "Ctrl-Alt-[", run: cg },
          { key: "Ctrl-Alt-]", run: fg },
        ],
        dg = {
          placeholderDOM: null,
          preparePlaceholder: null,
          placeholderText: "",
        },
        Xf = C.define({
          combine(n) {
            return lt(n, dg);
          },
        });
      function Rf(n) {
        return [Bt, gg];
      }
      function Mf(n, e) {
        let { state: t } = n,
          i = t.facet(Xf),
          r = (o) => {
            let l = n.lineBlockAt(n.posAtDOM(o.target)),
              a = dr(n.state, l.from, l.to);
            a && n.dispatch({ effects: hn.of(a) }), o.preventDefault();
          };
        if (i.placeholderDOM) return i.placeholderDOM(n, r, e);
        let s = document.createElement("span");
        return (
          (s.textContent = i.placeholderText),
          s.setAttribute("aria-label", t.phrase("folded code")),
          (s.title = t.phrase("unfold")),
          (s.className = "cm-foldPlaceholder"),
          (s.onclick = r),
          s
        );
      }
      const Ya = A.replace({
        widget: new (class extends St {
          toDOM(n) {
            return Mf(n, null);
          }
        })(),
      });
      class Og extends St {
        constructor(e) {
          super(), (this.value = e);
        }
        eq(e) {
          return this.value == e.value;
        }
        toDOM(e) {
          return Mf(e, this.value);
        }
      }
      const pg = {
        openText: "",
        closedText: "",
        markerDOM: null,
        domEventHandlers: {},
        foldingChanged: () => !1,
      };
      class hs extends gt {
        constructor(e, t) {
          super(), (this.config = e), (this.open = t);
        }
        eq(e) {
          return this.config == e.config && this.open == e.open;
        }
        toDOM(e) {
          if (this.config.markerDOM) return this.config.markerDOM(this.open);
          let t = document.createElement("span");
          return (
            (t.textContent = this.open
              ? this.config.openText
              : this.config.closedText),
            (t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line")),
            t
          );
        }
      }
      function mg(n = {}) {
        let e = { ...pg, ...n },
          t = new hs(e, !0),
          i = new hs(e, !1),
          r = ne.fromClass(
            class {
              constructor(o) {
                (this.from = o.viewport.from),
                  (this.markers = this.buildMarkers(o));
              }
              update(o) {
                (o.docChanged ||
                  o.viewportChanged ||
                  o.startState.facet(At) != o.state.facet(At) ||
                  o.startState.field(Bt, !1) != o.state.field(Bt, !1) ||
                  J(o.startState) != J(o.state) ||
                  e.foldingChanged(o)) &&
                  (this.markers = this.buildMarkers(o.view));
              }
              buildMarkers(o) {
                let l = new pt();
                for (let a of o.viewportLineBlocks) {
                  let h = dr(o.state, a.from, a.to)
                    ? i
                    : ur(o.state, a.from, a.to)
                    ? t
                    : null;
                  h && l.add(a.from, a.from, h);
                }
                return l.finish();
              }
            }
          ),
          { domEventHandlers: s } = e;
        return [
          r,
          um({
            class: "cm-foldGutter",
            markers(o) {
              var l;
              return (
                ((l = o.plugin(r)) === null || l === void 0
                  ? void 0
                  : l.markers) || V.empty
              );
            },
            initialSpacer() {
              return new hs(e, !1);
            },
            domEventHandlers: {
              ...s,
              click: (o, l, a) => {
                if (s.click && s.click(o, l, a)) return !0;
                let h = dr(o.state, l.from, l.to);
                if (h) return o.dispatch({ effects: hn.of(h) }), !0;
                let c = ur(o.state, l.from, l.to);
                return c ? (o.dispatch({ effects: qr.of(c) }), !0) : !1;
              },
            },
          }),
          Rf(),
        ];
      }
      const gg = v.baseTheme({
        ".cm-foldPlaceholder": {
          backgroundColor: "#eee",
          border: "1px solid #ddd",
          color: "#888",
          borderRadius: ".2em",
          margin: "0 1px",
          padding: "0 1px",
          cursor: "pointer",
        },
        ".cm-foldGutter span": { padding: "0 1px", cursor: "pointer" },
      });
      class cn {
        constructor(e, t) {
          this.specs = e;
          let i;
          function r(l) {
            let a = vt.newName();
            return ((i || (i = Object.create(null)))["." + a] = l), a;
          }
          const s =
              typeof t.all == "string" ? t.all : t.all ? r(t.all) : void 0,
            o = t.scope;
          (this.scope =
            o instanceof We
              ? (l) => l.prop(Kt) == o.data
              : o
              ? (l) => l == o
              : void 0),
            (this.style = xf(
              e.map((l) => ({
                tag: l.tag,
                class: l.class || r(Object.assign({}, l, { tag: null })),
              })),
              { all: s }
            ).style),
            (this.module = i ? new vt(i) : null),
            (this.themeType = t.themeType);
        }
        static define(e, t) {
          return new cn(e, t || {});
        }
      }
      const po = C.define(),
        Yf = C.define({
          combine(n) {
            return n.length ? [n[0]] : null;
          },
        });
      function cs(n) {
        let e = n.facet(po);
        return e.length ? e : n.facet(Yf);
      }
      function zf(n, e) {
        let t = [Sg],
          i;
        return (
          n instanceof cn &&
            (n.module && t.push(v.styleModule.of(n.module)), (i = n.themeType)),
          e?.fallback
            ? t.push(Yf.of(n))
            : i
            ? t.push(
                po.computeN([v.darkTheme], (r) =>
                  r.facet(v.darkTheme) == (i == "dark") ? [n] : []
                )
              )
            : t.push(po.of(n)),
          t
        );
      }
      class Qg {
        constructor(e) {
          (this.markCache = Object.create(null)),
            (this.tree = J(e.state)),
            (this.decorations = this.buildDeco(e, cs(e.state))),
            (this.decoratedTo = e.viewport.to);
        }
        update(e) {
          let t = J(e.state),
            i = cs(e.state),
            r = i != cs(e.startState),
            { viewport: s } = e.view,
            o = e.changes.mapPos(this.decoratedTo, 1);
          t.length < s.to && !r && t.type == this.tree.type && o >= s.to
            ? ((this.decorations = this.decorations.map(e.changes)),
              (this.decoratedTo = o))
            : (t != this.tree || e.viewportChanged || r) &&
              ((this.tree = t),
              (this.decorations = this.buildDeco(e.view, i)),
              (this.decoratedTo = s.to));
        }
        buildDeco(e, t) {
          if (!t || !this.tree.length) return A.none;
          let i = new pt();
          for (let { from: r, to: s } of e.visibleRanges)
            Wm(
              this.tree,
              t,
              (o, l, a) => {
                i.add(
                  o,
                  l,
                  this.markCache[a] ||
                    (this.markCache[a] = A.mark({ class: a }))
                );
              },
              r,
              s
            );
          return i.finish();
        }
      }
      const Sg = Xt.high(
          ne.fromClass(Qg, { decorations: (n) => n.decorations })
        ),
        yg = cn.define([
          { tag: p.meta, color: "#404740" },
          { tag: p.link, textDecoration: "underline" },
          { tag: p.heading, textDecoration: "underline", fontWeight: "bold" },
          { tag: p.emphasis, fontStyle: "italic" },
          { tag: p.strong, fontWeight: "bold" },
          { tag: p.strikethrough, textDecoration: "line-through" },
          { tag: p.keyword, color: "#708" },
          {
            tag: [p.atom, p.bool, p.url, p.contentSeparator, p.labelName],
            color: "#219",
          },
          { tag: [p.literal, p.inserted], color: "#164" },
          { tag: [p.string, p.deleted], color: "#a11" },
          { tag: [p.regexp, p.escape, p.special(p.string)], color: "#e40" },
          { tag: p.definition(p.variableName), color: "#00f" },
          { tag: p.local(p.variableName), color: "#30a" },
          { tag: [p.typeName, p.namespace], color: "#085" },
          { tag: p.className, color: "#167" },
          { tag: [p.special(p.variableName), p.macroName], color: "#256" },
          { tag: p.definition(p.propertyName), color: "#00c" },
          { tag: p.comment, color: "#940" },
          { tag: p.invalid, color: "#f00" },
        ]),
        bg = v.baseTheme({
          "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
          "&.cm-focused .cm-nonmatchingBracket": {
            backgroundColor: "#bb555544",
          },
        }),
        Df = 1e4,
        Ef = "()[]{}",
        _f = C.define({
          combine(n) {
            return lt(n, {
              afterCursor: !0,
              brackets: Ef,
              maxScanDistance: Df,
              renderMatch: kg,
            });
          },
        }),
        xg = A.mark({ class: "cm-matchingBracket" }),
        wg = A.mark({ class: "cm-nonmatchingBracket" });
      function kg(n) {
        let e = [],
          t = n.matched ? xg : wg;
        return (
          e.push(t.range(n.start.from, n.start.to)),
          n.end && e.push(t.range(n.end.from, n.end.to)),
          e
        );
      }
      const $g = oe.define({
          create() {
            return A.none;
          },
          update(n, e) {
            if (!e.docChanged && !e.selection) return n;
            let t = [],
              i = e.state.facet(_f);
            for (let r of e.state.selection.ranges) {
              if (!r.empty) continue;
              let s =
                it(e.state, r.head, -1, i) ||
                (r.head > 0 && it(e.state, r.head - 1, 1, i)) ||
                (i.afterCursor &&
                  (it(e.state, r.head, 1, i) ||
                    (r.head < e.state.doc.length &&
                      it(e.state, r.head + 1, -1, i))));
              s && (t = t.concat(i.renderMatch(s, e.state)));
            }
            return A.set(t, !0);
          },
          provide: (n) => v.decorations.from(n),
        }),
        Pg = [$g, bg];
      function vg(n = {}) {
        return [_f.of(n), Pg];
      }
      const Vf = new Y();
      function mo(n, e, t) {
        let i = n.prop(e < 0 ? Y.openedBy : Y.closedBy);
        if (i) return i;
        if (n.name.length == 1) {
          let r = t.indexOf(n.name);
          if (r > -1 && r % 2 == (e < 0 ? 1 : 0)) return [t[r + e]];
        }
        return null;
      }
      function go(n) {
        let e = n.type.prop(Vf);
        return e ? e(n.node) : n;
      }
      function it(n, e, t, i = {}) {
        let r = i.maxScanDistance || Df,
          s = i.brackets || Ef,
          o = J(n),
          l = o.resolveInner(e, t);
        for (let a = l; a; a = a.parent) {
          let h = mo(a.type, t, s);
          if (h && a.from < a.to) {
            let c = go(a);
            if (
              c &&
              (t > 0 ? e >= c.from && e < c.to : e > c.from && e <= c.to)
            )
              return Tg(n, e, t, a, c, h, s);
          }
        }
        return Cg(n, e, t, o, l.type, r, s);
      }
      function Tg(n, e, t, i, r, s, o) {
        let l = i.parent,
          a = { from: r.from, to: r.to },
          h = 0,
          c = l?.cursor();
        if (c && (t < 0 ? c.childBefore(i.from) : c.childAfter(i.to)))
          do
            if (t < 0 ? c.to <= i.from : c.from >= i.to) {
              if (h == 0 && s.indexOf(c.type.name) > -1 && c.from < c.to) {
                let f = go(c);
                return {
                  start: a,
                  end: f ? { from: f.from, to: f.to } : void 0,
                  matched: !0,
                };
              } else if (mo(c.type, t, o)) h++;
              else if (mo(c.type, -t, o)) {
                if (h == 0) {
                  let f = go(c);
                  return {
                    start: a,
                    end:
                      f && f.from < f.to ? { from: f.from, to: f.to } : void 0,
                    matched: !1,
                  };
                }
                h--;
              }
            }
          while (t < 0 ? c.prevSibling() : c.nextSibling());
        return { start: a, matched: !1 };
      }
      function Cg(n, e, t, i, r, s, o) {
        let l = t < 0 ? n.sliceDoc(e - 1, e) : n.sliceDoc(e, e + 1),
          a = o.indexOf(l);
        if (a < 0 || (a % 2 == 0) != t > 0) return null;
        let h = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e },
          c = n.doc.iterRange(e, t > 0 ? n.doc.length : 0),
          f = 0;
        for (let u = 0; !c.next().done && u <= s; ) {
          let d = c.value;
          t < 0 && (u += d.length);
          let O = e + u * t;
          for (
            let m = t > 0 ? 0 : d.length - 1, g = t > 0 ? d.length : -1;
            m != g;
            m += t
          ) {
            let Q = o.indexOf(d[m]);
            if (!(Q < 0 || i.resolveInner(O + m, 1).type != r))
              if ((Q % 2 == 0) == t > 0) f++;
              else {
                if (f == 1)
                  return {
                    start: h,
                    end: { from: O + m, to: O + m + 1 },
                    matched: Q >> 1 == a >> 1,
                  };
                f--;
              }
          }
          t > 0 && (u += d.length);
        }
        return c.done ? { start: h, matched: !1 } : null;
      }
      const Zg = Object.create(null),
        za = [Se.none],
        Da = [],
        Ea = Object.create(null),
        Ag = Object.create(null);
      for (let [n, e] of [
        ["variable", "variableName"],
        ["variable-2", "variableName.special"],
        ["string-2", "string.special"],
        ["def", "variableName.definition"],
        ["tag", "tagName"],
        ["attribute", "attributeName"],
        ["type", "typeName"],
        ["builtin", "variableName.standard"],
        ["qualifier", "modifier"],
        ["error", "invalid"],
        ["header", "heading"],
        ["property", "propertyName"],
      ])
        Ag[n] = Xg(Zg, e);
      function fs(n, e) {
        Da.indexOf(n) > -1 || (Da.push(n), console.warn(e));
      }
      function Xg(n, e) {
        let t = [];
        for (let l of e.split(" ")) {
          let a = [];
          for (let h of l.split(".")) {
            let c = n[h] || p[h];
            c
              ? typeof c == "function"
                ? a.length
                  ? (a = a.map(c))
                  : fs(h, `Modifier ${h} used at start of tag`)
                : a.length
                ? fs(h, `Tag ${h} used as modifier`)
                : (a = Array.isArray(c) ? c : [c])
              : fs(h, `Unknown highlighting tag ${h}`);
          }
          for (let h of a) t.push(h);
        }
        if (!t.length) return 0;
        let i = e.replace(/ /g, "_"),
          r = i + " " + t.map((l) => l.id),
          s = Ea[r];
        if (s) return s.id;
        let o = (Ea[r] = Se.define({
          id: za.length,
          name: i,
          props: [zr({ [i]: t })],
        }));
        return za.push(o), o.id;
      }
      F.RTL, F.LTR;
      const Rg = (n) => {
        let { state: e } = n,
          t = e.doc.lineAt(e.selection.main.from),
          i = Jo(n.state, t.from);
        return i.line ? Mg(n) : i.block ? zg(n) : !1;
      };
      function Ko(n, e) {
        return ({ state: t, dispatch: i }) => {
          if (t.readOnly) return !1;
          let r = n(e, t);
          return r ? (i(t.update(r)), !0) : !1;
        };
      }
      const Mg = Ko(_g, 0),
        Yg = Ko(qf, 0),
        zg = Ko((n, e) => qf(n, e, Eg(e)), 0);
      function Jo(n, e) {
        let t = n.languageDataAt("commentTokens", e, 1);
        return t.length ? t[0] : {};
      }
      const Pi = 50;
      function Dg(n, { open: e, close: t }, i, r) {
        let s = n.sliceDoc(i - Pi, i),
          o = n.sliceDoc(r, r + Pi),
          l = /\s*$/.exec(s)[0].length,
          a = /^\s*/.exec(o)[0].length,
          h = s.length - l;
        if (s.slice(h - e.length, h) == e && o.slice(a, a + t.length) == t)
          return {
            open: { pos: i - l, margin: l && 1 },
            close: { pos: r + a, margin: a && 1 },
          };
        let c, f;
        r - i <= 2 * Pi
          ? (c = f = n.sliceDoc(i, r))
          : ((c = n.sliceDoc(i, i + Pi)), (f = n.sliceDoc(r - Pi, r)));
        let u = /^\s*/.exec(c)[0].length,
          d = /\s*$/.exec(f)[0].length,
          O = f.length - d - t.length;
        return c.slice(u, u + e.length) == e && f.slice(O, O + t.length) == t
          ? {
              open: {
                pos: i + u + e.length,
                margin: /\s/.test(c.charAt(u + e.length)) ? 1 : 0,
              },
              close: {
                pos: r - d - t.length,
                margin: /\s/.test(f.charAt(O - 1)) ? 1 : 0,
              },
            }
          : null;
      }
      function Eg(n) {
        let e = [];
        for (let t of n.selection.ranges) {
          let i = n.doc.lineAt(t.from),
            r = t.to <= i.to ? i : n.doc.lineAt(t.to);
          r.from > i.from &&
            r.from == t.to &&
            (r = t.to == i.to + 1 ? i : n.doc.lineAt(t.to - 1));
          let s = e.length - 1;
          s >= 0 && e[s].to > i.from
            ? (e[s].to = r.to)
            : e.push({
                from: i.from + /^\s*/.exec(i.text)[0].length,
                to: r.to,
              });
        }
        return e;
      }
      function qf(n, e, t = e.selection.ranges) {
        let i = t.map((s) => Jo(e, s.from).block);
        if (!i.every((s) => s)) return null;
        let r = t.map((s, o) => Dg(e, i[o], s.from, s.to));
        if (n != 2 && !r.every((s) => s))
          return {
            changes: e.changes(
              t.map((s, o) =>
                r[o]
                  ? []
                  : [
                      { from: s.from, insert: i[o].open + " " },
                      { from: s.to, insert: " " + i[o].close },
                    ]
              )
            ),
          };
        if (n != 1 && r.some((s) => s)) {
          let s = [];
          for (let o = 0, l; o < r.length; o++)
            if ((l = r[o])) {
              let a = i[o],
                { open: h, close: c } = l;
              s.push(
                { from: h.pos - a.open.length, to: h.pos + h.margin },
                { from: c.pos - c.margin, to: c.pos + a.close.length }
              );
            }
          return { changes: s };
        }
        return null;
      }
      function _g(n, e, t = e.selection.ranges) {
        let i = [],
          r = -1;
        for (let { from: s, to: o } of t) {
          let l = i.length,
            a = 1e9,
            h = Jo(e, s).line;
          if (h) {
            for (let c = s; c <= o; ) {
              let f = e.doc.lineAt(c);
              if (f.from > r && (s == o || o > f.from)) {
                r = f.from;
                let u = /^\s*/.exec(f.text)[0].length,
                  d = u == f.length,
                  O = f.text.slice(u, u + h.length) == h ? u : -1;
                u < f.text.length && u < a && (a = u),
                  i.push({
                    line: f,
                    comment: O,
                    token: h,
                    indent: u,
                    empty: d,
                    single: !1,
                  });
              }
              c = f.to + 1;
            }
            if (a < 1e9)
              for (let c = l; c < i.length; c++)
                i[c].indent < i[c].line.text.length && (i[c].indent = a);
            i.length == l + 1 && (i[l].single = !0);
          }
        }
        if (n != 2 && i.some((s) => s.comment < 0 && (!s.empty || s.single))) {
          let s = [];
          for (let { line: l, token: a, indent: h, empty: c, single: f } of i)
            (f || !c) && s.push({ from: l.from + h, insert: a + " " });
          let o = e.changes(s);
          return { changes: o, selection: e.selection.map(o, 1) };
        } else if (n != 1 && i.some((s) => s.comment >= 0)) {
          let s = [];
          for (let { line: o, comment: l, token: a } of i)
            if (l >= 0) {
              let h = o.from + l,
                c = h + a.length;
              o.text[c - o.from] == " " && c++, s.push({ from: h, to: c });
            }
          return { changes: s };
        }
        return null;
      }
      const Qo = Qt.define(),
        Vg = Qt.define(),
        qg = C.define(),
        Wf = C.define({
          combine(n) {
            return lt(
              n,
              { minDepth: 100, newGroupDelay: 500, joinToEvent: (e, t) => t },
              {
                minDepth: Math.max,
                newGroupDelay: Math.min,
                joinToEvent: (e, t) => (i, r) => e(i, r) || t(i, r),
              }
            );
          },
        }),
        Lf = oe.define({
          create() {
            return nt.empty;
          },
          update(n, e) {
            let t = e.state.facet(Wf),
              i = e.annotation(Qo);
            if (i) {
              let a = $e.fromTransaction(e, i.selection),
                h = i.side,
                c = h == 0 ? n.undone : n.done;
              return (
                a
                  ? (c = Or(c, c.length, t.minDepth, a))
                  : (c = If(c, e.startState.selection)),
                new nt(h == 0 ? i.rest : c, h == 0 ? c : i.rest)
              );
            }
            let r = e.annotation(Vg);
            if (
              ((r == "full" || r == "before") && (n = n.isolate()),
              e.annotation(ie.addToHistory) === !1)
            )
              return e.changes.empty ? n : n.addMapping(e.changes.desc);
            let s = $e.fromTransaction(e),
              o = e.annotation(ie.time),
              l = e.annotation(ie.userEvent);
            return (
              s
                ? (n = n.addChanges(s, o, l, t, e))
                : e.selection &&
                  (n = n.addSelection(
                    e.startState.selection,
                    o,
                    l,
                    t.newGroupDelay
                  )),
              (r == "full" || r == "after") && (n = n.isolate()),
              n
            );
          },
          toJSON(n) {
            return {
              done: n.done.map((e) => e.toJSON()),
              undone: n.undone.map((e) => e.toJSON()),
            };
          },
          fromJSON(n) {
            return new nt(n.done.map($e.fromJSON), n.undone.map($e.fromJSON));
          },
        });
      function Wg(n = {}) {
        return [
          Lf,
          Wf.of(n),
          v.domEventHandlers({
            beforeinput(e, t) {
              let i =
                e.inputType == "historyUndo"
                  ? jf
                  : e.inputType == "historyRedo"
                  ? So
                  : null;
              return i ? (e.preventDefault(), i(t)) : !1;
            },
          }),
        ];
      }
      function Wr(n, e) {
        return function ({ state: t, dispatch: i }) {
          if (!e && t.readOnly) return !1;
          let r = t.field(Lf, !1);
          if (!r) return !1;
          let s = r.pop(n, t, e);
          return s ? (i(s), !0) : !1;
        };
      }
      const jf = Wr(0, !1),
        So = Wr(1, !1),
        Lg = Wr(0, !0),
        jg = Wr(1, !0);
      class $e {
        constructor(e, t, i, r, s) {
          (this.changes = e),
            (this.effects = t),
            (this.mapped = i),
            (this.startSelection = r),
            (this.selectionsAfter = s);
        }
        setSelAfter(e) {
          return new $e(
            this.changes,
            this.effects,
            this.mapped,
            this.startSelection,
            e
          );
        }
        toJSON() {
          var e, t, i;
          return {
            changes:
              (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
            mapped:
              (t = this.mapped) === null || t === void 0 ? void 0 : t.toJSON(),
            startSelection:
              (i = this.startSelection) === null || i === void 0
                ? void 0
                : i.toJSON(),
            selectionsAfter: this.selectionsAfter.map((r) => r.toJSON()),
          };
        }
        static fromJSON(e) {
          return new $e(
            e.changes && re.fromJSON(e.changes),
            [],
            e.mapped && rt.fromJSON(e.mapped),
            e.startSelection && S.fromJSON(e.startSelection),
            e.selectionsAfter.map(S.fromJSON)
          );
        }
        static fromTransaction(e, t) {
          let i = De;
          for (let r of e.startState.facet(qg)) {
            let s = r(e);
            s.length && (i = i.concat(s));
          }
          return !i.length && e.changes.empty
            ? null
            : new $e(
                e.changes.invert(e.startState.doc),
                i,
                void 0,
                t || e.startState.selection,
                De
              );
        }
        static selection(e) {
          return new $e(void 0, De, void 0, void 0, e);
        }
      }
      function Or(n, e, t, i) {
        let r = e + 1 > t + 20 ? e - t - 1 : 0,
          s = n.slice(r, e);
        return s.push(i), s;
      }
      function Bg(n, e) {
        let t = [],
          i = !1;
        return (
          n.iterChangedRanges((r, s) => t.push(r, s)),
          e.iterChangedRanges((r, s, o, l) => {
            for (let a = 0; a < t.length; ) {
              let h = t[a++],
                c = t[a++];
              l >= h && o <= c && (i = !0);
            }
          }),
          i
        );
      }
      function Ig(n, e) {
        return (
          n.ranges.length == e.ranges.length &&
          n.ranges.filter((t, i) => t.empty != e.ranges[i].empty).length === 0
        );
      }
      function Bf(n, e) {
        return n.length ? (e.length ? n.concat(e) : n) : e;
      }
      const De = [],
        Gg = 200;
      function If(n, e) {
        if (n.length) {
          let t = n[n.length - 1],
            i = t.selectionsAfter.slice(
              Math.max(0, t.selectionsAfter.length - Gg)
            );
          return i.length && i[i.length - 1].eq(e)
            ? n
            : (i.push(e), Or(n, n.length - 1, 1e9, t.setSelAfter(i)));
        } else return [$e.selection([e])];
      }
      function Ng(n) {
        let e = n[n.length - 1],
          t = n.slice();
        return (
          (t[n.length - 1] = e.setSelAfter(
            e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)
          )),
          t
        );
      }
      function us(n, e) {
        if (!n.length) return n;
        let t = n.length,
          i = De;
        for (; t; ) {
          let r = Ug(n[t - 1], e, i);
          if ((r.changes && !r.changes.empty) || r.effects.length) {
            let s = n.slice(0, t);
            return (s[t - 1] = r), s;
          } else (e = r.mapped), t--, (i = r.selectionsAfter);
        }
        return i.length ? [$e.selection(i)] : De;
      }
      function Ug(n, e, t) {
        let i = Bf(
          n.selectionsAfter.length
            ? n.selectionsAfter.map((l) => l.map(e))
            : De,
          t
        );
        if (!n.changes) return $e.selection(i);
        let r = n.changes.map(e),
          s = e.mapDesc(n.changes, !0),
          o = n.mapped ? n.mapped.composeDesc(s) : s;
        return new $e(
          r,
          R.mapEffects(n.effects, e),
          o,
          n.startSelection.map(s),
          i
        );
      }
      const Fg = /^(input\.type|delete)($|\.)/;
      class nt {
        constructor(e, t, i = 0, r = void 0) {
          (this.done = e),
            (this.undone = t),
            (this.prevTime = i),
            (this.prevUserEvent = r);
        }
        isolate() {
          return this.prevTime ? new nt(this.done, this.undone) : this;
        }
        addChanges(e, t, i, r, s) {
          let o = this.done,
            l = o[o.length - 1];
          return (
            l &&
            l.changes &&
            !l.changes.empty &&
            e.changes &&
            (!i || Fg.test(i)) &&
            ((!l.selectionsAfter.length &&
              t - this.prevTime < r.newGroupDelay &&
              r.joinToEvent(s, Bg(l.changes, e.changes))) ||
              i == "input.type.compose")
              ? (o = Or(
                  o,
                  o.length - 1,
                  r.minDepth,
                  new $e(
                    e.changes.compose(l.changes),
                    Bf(R.mapEffects(e.effects, l.changes), l.effects),
                    l.mapped,
                    l.startSelection,
                    De
                  )
                ))
              : (o = Or(o, o.length, r.minDepth, e)),
            new nt(o, De, t, i)
          );
        }
        addSelection(e, t, i, r) {
          let s = this.done.length
            ? this.done[this.done.length - 1].selectionsAfter
            : De;
          return s.length > 0 &&
            t - this.prevTime < r &&
            i == this.prevUserEvent &&
            i &&
            /^select($|\.)/.test(i) &&
            Ig(s[s.length - 1], e)
            ? this
            : new nt(If(this.done, e), this.undone, t, i);
        }
        addMapping(e) {
          return new nt(
            us(this.done, e),
            us(this.undone, e),
            this.prevTime,
            this.prevUserEvent
          );
        }
        pop(e, t, i) {
          let r = e == 0 ? this.done : this.undone;
          if (r.length == 0) return null;
          let s = r[r.length - 1],
            o = s.selectionsAfter[0] || t.selection;
          if (i && s.selectionsAfter.length)
            return t.update({
              selection: s.selectionsAfter[s.selectionsAfter.length - 1],
              annotations: Qo.of({ side: e, rest: Ng(r), selection: o }),
              userEvent: e == 0 ? "select.undo" : "select.redo",
              scrollIntoView: !0,
            });
          if (s.changes) {
            let l = r.length == 1 ? De : r.slice(0, r.length - 1);
            return (
              s.mapped && (l = us(l, s.mapped)),
              t.update({
                changes: s.changes,
                selection: s.startSelection,
                effects: s.effects,
                annotations: Qo.of({ side: e, rest: l, selection: o }),
                filter: !1,
                userEvent: e == 0 ? "undo" : "redo",
                scrollIntoView: !0,
              })
            );
          } else return null;
        }
      }
      nt.empty = new nt(De, De);
      const Hg = [
        { key: "Mod-z", run: jf, preventDefault: !0 },
        { key: "Mod-y", mac: "Mod-Shift-z", run: So, preventDefault: !0 },
        { linux: "Ctrl-Shift-z", run: So, preventDefault: !0 },
        { key: "Mod-u", run: Lg, preventDefault: !0 },
        { key: "Alt-u", mac: "Mod-Shift-u", run: jg, preventDefault: !0 },
      ];
      function Qi(n, e) {
        return S.create(n.ranges.map(e), n.mainIndex);
      }
      function at(n, e) {
        return n.update({
          selection: e,
          scrollIntoView: !0,
          userEvent: "select",
        });
      }
      function Be({ state: n, dispatch: e }, t) {
        let i = Qi(n.selection, t);
        return i.eq(n.selection, !0) ? !1 : (e(at(n, i)), !0);
      }
      function Lr(n, e) {
        return S.cursor(e ? n.to : n.from);
      }
      function Gf(n, e) {
        return Be(n, (t) => (t.empty ? n.moveByChar(t, e) : Lr(t, e)));
      }
      function pe(n) {
        return n.textDirectionAt(n.state.selection.main.head) == F.LTR;
      }
      const Nf = (n) => Gf(n, !pe(n)),
        Uf = (n) => Gf(n, pe(n));
      function Ff(n, e) {
        return Be(n, (t) => (t.empty ? n.moveByGroup(t, e) : Lr(t, e)));
      }
      const Kg = (n) => Ff(n, !pe(n)),
        Jg = (n) => Ff(n, pe(n));
      function e0(n, e, t) {
        if (e.type.prop(t)) return !0;
        let i = e.to - e.from;
        return (
          (i && (i > 2 || /[^\s,.;:]/.test(n.sliceDoc(e.from, e.to)))) ||
          e.firstChild
        );
      }
      function jr(n, e, t) {
        let i = J(n).resolveInner(e.head),
          r = t ? Y.closedBy : Y.openedBy;
        for (let a = e.head; ; ) {
          let h = t ? i.childAfter(a) : i.childBefore(a);
          if (!h) break;
          e0(n, h, r) ? (i = h) : (a = t ? h.to : h.from);
        }
        let s = i.type.prop(r),
          o,
          l;
        return (
          s && (o = t ? it(n, i.from, 1) : it(n, i.to, -1)) && o.matched
            ? (l = t ? o.end.to : o.end.from)
            : (l = t ? i.to : i.from),
          S.cursor(l, t ? -1 : 1)
        );
      }
      const t0 = (n) => Be(n, (e) => jr(n.state, e, !pe(n))),
        i0 = (n) => Be(n, (e) => jr(n.state, e, pe(n)));
      function Hf(n, e) {
        return Be(n, (t) => {
          if (!t.empty) return Lr(t, e);
          let i = n.moveVertically(t, e);
          return i.head != t.head ? i : n.moveToLineBoundary(t, e);
        });
      }
      const Kf = (n) => Hf(n, !1),
        Jf = (n) => Hf(n, !0);
      function eu(n) {
        let e = n.scrollDOM.clientHeight < n.scrollDOM.scrollHeight - 2,
          t = 0,
          i = 0,
          r;
        if (e) {
          for (let s of n.state.facet(v.scrollMargins)) {
            let o = s(n);
            o?.top && (t = Math.max(o?.top, t)),
              o?.bottom && (i = Math.max(o?.bottom, i));
          }
          r = n.scrollDOM.clientHeight - t - i;
        } else r = (n.dom.ownerDocument.defaultView || window).innerHeight;
        return {
          marginTop: t,
          marginBottom: i,
          selfScroll: e,
          height: Math.max(n.defaultLineHeight, r - 5),
        };
      }
      function tu(n, e) {
        let t = eu(n),
          { state: i } = n,
          r = Qi(i.selection, (o) =>
            o.empty ? n.moveVertically(o, e, t.height) : Lr(o, e)
          );
        if (r.eq(i.selection)) return !1;
        let s;
        if (t.selfScroll) {
          let o = n.coordsAtPos(i.selection.main.head),
            l = n.scrollDOM.getBoundingClientRect(),
            a = l.top + t.marginTop,
            h = l.bottom - t.marginBottom;
          o &&
            o.top > a &&
            o.bottom < h &&
            (s = v.scrollIntoView(r.main.head, {
              y: "start",
              yMargin: o.top - a,
            }));
        }
        return n.dispatch(at(i, r), { effects: s }), !0;
      }
      const _a = (n) => tu(n, !1),
        yo = (n) => tu(n, !0);
      function Rt(n, e, t) {
        let i = n.lineBlockAt(e.head),
          r = n.moveToLineBoundary(e, t);
        if (
          (r.head == e.head &&
            r.head != (t ? i.to : i.from) &&
            (r = n.moveToLineBoundary(e, t, !1)),
          !t && r.head == i.from && i.length)
        ) {
          let s = /^\s*/.exec(
            n.state.sliceDoc(i.from, Math.min(i.from + 100, i.to))
          )[0].length;
          s && e.head != i.from + s && (r = S.cursor(i.from + s));
        }
        return r;
      }
      const n0 = (n) => Be(n, (e) => Rt(n, e, !0)),
        r0 = (n) => Be(n, (e) => Rt(n, e, !1)),
        s0 = (n) => Be(n, (e) => Rt(n, e, !pe(n))),
        o0 = (n) => Be(n, (e) => Rt(n, e, pe(n))),
        l0 = (n) => Be(n, (e) => S.cursor(n.lineBlockAt(e.head).from, 1)),
        a0 = (n) => Be(n, (e) => S.cursor(n.lineBlockAt(e.head).to, -1));
      function h0(n, e, t) {
        let i = !1,
          r = Qi(n.selection, (s) => {
            let o =
              it(n, s.head, -1) ||
              it(n, s.head, 1) ||
              (s.head > 0 && it(n, s.head - 1, 1)) ||
              (s.head < n.doc.length && it(n, s.head + 1, -1));
            if (!o || !o.end) return s;
            i = !0;
            let l = o.start.from == s.head ? o.end.to : o.end.from;
            return S.cursor(l);
          });
        return i ? (e(at(n, r)), !0) : !1;
      }
      const c0 = ({ state: n, dispatch: e }) => h0(n, e);
      function qe(n, e) {
        let t = Qi(n.state.selection, (i) => {
          let r = e(i);
          return S.range(i.anchor, r.head, r.goalColumn, r.bidiLevel || void 0);
        });
        return t.eq(n.state.selection) ? !1 : (n.dispatch(at(n.state, t)), !0);
      }
      function iu(n, e) {
        return qe(n, (t) => n.moveByChar(t, e));
      }
      const nu = (n) => iu(n, !pe(n)),
        ru = (n) => iu(n, pe(n));
      function su(n, e) {
        return qe(n, (t) => n.moveByGroup(t, e));
      }
      const f0 = (n) => su(n, !pe(n)),
        u0 = (n) => su(n, pe(n)),
        d0 = (n) => qe(n, (e) => jr(n.state, e, !pe(n))),
        O0 = (n) => qe(n, (e) => jr(n.state, e, pe(n)));
      function ou(n, e) {
        return qe(n, (t) => n.moveVertically(t, e));
      }
      const lu = (n) => ou(n, !1),
        au = (n) => ou(n, !0);
      function hu(n, e) {
        return qe(n, (t) => n.moveVertically(t, e, eu(n).height));
      }
      const Va = (n) => hu(n, !1),
        qa = (n) => hu(n, !0),
        p0 = (n) => qe(n, (e) => Rt(n, e, !0)),
        m0 = (n) => qe(n, (e) => Rt(n, e, !1)),
        g0 = (n) => qe(n, (e) => Rt(n, e, !pe(n))),
        Q0 = (n) => qe(n, (e) => Rt(n, e, pe(n))),
        S0 = (n) => qe(n, (e) => S.cursor(n.lineBlockAt(e.head).from)),
        y0 = (n) => qe(n, (e) => S.cursor(n.lineBlockAt(e.head).to)),
        Wa = ({ state: n, dispatch: e }) => (e(at(n, { anchor: 0 })), !0),
        La = ({ state: n, dispatch: e }) => (
          e(at(n, { anchor: n.doc.length })), !0
        ),
        ja = ({ state: n, dispatch: e }) => (
          e(at(n, { anchor: n.selection.main.anchor, head: 0 })), !0
        ),
        Ba = ({ state: n, dispatch: e }) => (
          e(at(n, { anchor: n.selection.main.anchor, head: n.doc.length })), !0
        ),
        b0 = ({ state: n, dispatch: e }) => (
          e(
            n.update({
              selection: { anchor: 0, head: n.doc.length },
              userEvent: "select",
            })
          ),
          !0
        ),
        x0 = ({ state: n, dispatch: e }) => {
          let t = Br(n).map(({ from: i, to: r }) =>
            S.range(i, Math.min(r + 1, n.doc.length))
          );
          return (
            e(n.update({ selection: S.create(t), userEvent: "select" })), !0
          );
        },
        w0 = ({ state: n, dispatch: e }) => {
          let t = Qi(n.selection, (i) => {
            let r = J(n),
              s = r.resolveStack(i.from, 1);
            if (i.empty) {
              let o = r.resolveStack(i.from, -1);
              o.node.from >= s.node.from && o.node.to <= s.node.to && (s = o);
            }
            for (let o = s; o; o = o.next) {
              let { node: l } = o;
              if (
                ((l.from < i.from && l.to >= i.to) ||
                  (l.to > i.to && l.from <= i.from)) &&
                o.next
              )
                return S.range(l.to, l.from);
            }
            return i;
          });
          return t.eq(n.selection) ? !1 : (e(at(n, t)), !0);
        },
        k0 = ({ state: n, dispatch: e }) => {
          let t = n.selection,
            i = null;
          return (
            t.ranges.length > 1
              ? (i = S.create([t.main]))
              : t.main.empty || (i = S.create([S.cursor(t.main.head)])),
            i ? (e(at(n, i)), !0) : !1
          );
        };
      function fn(n, e) {
        if (n.state.readOnly) return !1;
        let t = "delete.selection",
          { state: i } = n,
          r = i.changeByRange((s) => {
            let { from: o, to: l } = s;
            if (o == l) {
              let a = e(s);
              a < o
                ? ((t = "delete.backward"), (a = Rn(n, a, !1)))
                : a > o && ((t = "delete.forward"), (a = Rn(n, a, !0))),
                (o = Math.min(o, a)),
                (l = Math.max(l, a));
            } else (o = Rn(n, o, !1)), (l = Rn(n, l, !0));
            return o == l
              ? { range: s }
              : {
                  changes: { from: o, to: l },
                  range: S.cursor(o, o < s.head ? -1 : 1),
                };
          });
        return r.changes.empty
          ? !1
          : (n.dispatch(
              i.update(r, {
                scrollIntoView: !0,
                userEvent: t,
                effects:
                  t == "delete.selection"
                    ? v.announce.of(i.phrase("Selection deleted"))
                    : void 0,
              })
            ),
            !0);
      }
      function Rn(n, e, t) {
        if (n instanceof v)
          for (let i of n.state.facet(v.atomicRanges).map((r) => r(n)))
            i.between(e, e, (r, s) => {
              r < e && s > e && (e = t ? s : r);
            });
        return e;
      }
      const cu = (n, e, t) =>
          fn(n, (i) => {
            let r = i.from,
              { state: s } = n,
              o = s.doc.lineAt(r),
              l,
              a;
            if (
              t &&
              !e &&
              r > o.from &&
              r < o.from + 200 &&
              !/[^ \t]/.test((l = o.text.slice(0, r - o.from)))
            ) {
              if (l[l.length - 1] == "	") return r - 1;
              let h = gi(l, s.tabSize),
                c = h % fr(s) || fr(s);
              for (let f = 0; f < c && l[l.length - 1 - f] == " "; f++) r--;
              a = r;
            } else
              (a = fe(o.text, r - o.from, e, e) + o.from),
                a == r && o.number != (e ? s.doc.lines : 1)
                  ? (a += e ? 1 : -1)
                  : !e &&
                    /[\ufe00-\ufe0f]/.test(
                      o.text.slice(a - o.from, r - o.from)
                    ) &&
                    (a = fe(o.text, a - o.from, !1, !1) + o.from);
            return a;
          }),
        bo = (n) => cu(n, !1, !0),
        fu = (n) => cu(n, !0, !1),
        uu = (n, e) =>
          fn(n, (t) => {
            let i = t.head,
              { state: r } = n,
              s = r.doc.lineAt(i),
              o = r.charCategorizer(i);
            for (let l = null; ; ) {
              if (i == (e ? s.to : s.from)) {
                i == t.head &&
                  s.number != (e ? r.doc.lines : 1) &&
                  (i += e ? 1 : -1);
                break;
              }
              let a = fe(s.text, i - s.from, e) + s.from,
                h = s.text.slice(
                  Math.min(i, a) - s.from,
                  Math.max(i, a) - s.from
                ),
                c = o(h);
              if (l != null && c != l) break;
              (h != " " || i != t.head) && (l = c), (i = a);
            }
            return i;
          }),
        du = (n) => uu(n, !1),
        $0 = (n) => uu(n, !0),
        P0 = (n) =>
          fn(n, (e) => {
            let t = n.lineBlockAt(e.head).to;
            return e.head < t ? t : Math.min(n.state.doc.length, e.head + 1);
          }),
        v0 = (n) =>
          fn(n, (e) => {
            let t = n.moveToLineBoundary(e, !1).head;
            return e.head > t ? t : Math.max(0, e.head - 1);
          }),
        T0 = (n) =>
          fn(n, (e) => {
            let t = n.moveToLineBoundary(e, !0).head;
            return e.head < t ? t : Math.min(n.state.doc.length, e.head + 1);
          }),
        C0 = ({ state: n, dispatch: e }) => {
          if (n.readOnly) return !1;
          let t = n.changeByRange((i) => ({
            changes: { from: i.from, to: i.to, insert: E.of(["", ""]) },
            range: S.cursor(i.from),
          }));
          return e(n.update(t, { scrollIntoView: !0, userEvent: "input" })), !0;
        },
        Z0 = ({ state: n, dispatch: e }) => {
          if (n.readOnly) return !1;
          let t = n.changeByRange((i) => {
            if (!i.empty || i.from == 0 || i.from == n.doc.length)
              return { range: i };
            let r = i.from,
              s = n.doc.lineAt(r),
              o = r == s.from ? r - 1 : fe(s.text, r - s.from, !1) + s.from,
              l = r == s.to ? r + 1 : fe(s.text, r - s.from, !0) + s.from;
            return {
              changes: {
                from: o,
                to: l,
                insert: n.doc.slice(r, l).append(n.doc.slice(o, r)),
              },
              range: S.cursor(l),
            };
          });
          return t.changes.empty
            ? !1
            : (e(
                n.update(t, { scrollIntoView: !0, userEvent: "move.character" })
              ),
              !0);
        };
      function Br(n) {
        let e = [],
          t = -1;
        for (let i of n.selection.ranges) {
          let r = n.doc.lineAt(i.from),
            s = n.doc.lineAt(i.to);
          if (
            (!i.empty && i.to == s.from && (s = n.doc.lineAt(i.to - 1)),
            t >= r.number)
          ) {
            let o = e[e.length - 1];
            (o.to = s.to), o.ranges.push(i);
          } else e.push({ from: r.from, to: s.to, ranges: [i] });
          t = s.number + 1;
        }
        return e;
      }
      function Ou(n, e, t) {
        if (n.readOnly) return !1;
        let i = [],
          r = [];
        for (let s of Br(n)) {
          if (t ? s.to == n.doc.length : s.from == 0) continue;
          let o = n.doc.lineAt(t ? s.to + 1 : s.from - 1),
            l = o.length + 1;
          if (t) {
            i.push(
              { from: s.to, to: o.to },
              { from: s.from, insert: o.text + n.lineBreak }
            );
            for (let a of s.ranges)
              r.push(
                S.range(
                  Math.min(n.doc.length, a.anchor + l),
                  Math.min(n.doc.length, a.head + l)
                )
              );
          } else {
            i.push(
              { from: o.from, to: s.from },
              { from: s.to, insert: n.lineBreak + o.text }
            );
            for (let a of s.ranges) r.push(S.range(a.anchor - l, a.head - l));
          }
        }
        return i.length
          ? (e(
              n.update({
                changes: i,
                scrollIntoView: !0,
                selection: S.create(r, n.selection.mainIndex),
                userEvent: "move.line",
              })
            ),
            !0)
          : !1;
      }
      const A0 = ({ state: n, dispatch: e }) => Ou(n, e, !1),
        X0 = ({ state: n, dispatch: e }) => Ou(n, e, !0);
      function pu(n, e, t) {
        if (n.readOnly) return !1;
        let i = [];
        for (let r of Br(n))
          t
            ? i.push({
                from: r.from,
                insert: n.doc.slice(r.from, r.to) + n.lineBreak,
              })
            : i.push({
                from: r.to,
                insert: n.lineBreak + n.doc.slice(r.from, r.to),
              });
        return (
          e(
            n.update({
              changes: i,
              scrollIntoView: !0,
              userEvent: "input.copyline",
            })
          ),
          !0
        );
      }
      const R0 = ({ state: n, dispatch: e }) => pu(n, e, !1),
        M0 = ({ state: n, dispatch: e }) => pu(n, e, !0),
        Y0 = (n) => {
          if (n.state.readOnly) return !1;
          let { state: e } = n,
            t = e.changes(
              Br(e).map(
                ({ from: r, to: s }) => (
                  r > 0 ? r-- : s < e.doc.length && s++, { from: r, to: s }
                )
              )
            ),
            i = Qi(e.selection, (r) => {
              let s;
              if (n.lineWrapping) {
                let o = n.lineBlockAt(r.head),
                  l = n.coordsAtPos(r.head, r.assoc || 1);
                l &&
                  (s =
                    o.bottom +
                    n.documentTop -
                    l.bottom +
                    n.defaultLineHeight / 2);
              }
              return n.moveVertically(r, !0, s);
            }).map(t);
          return (
            n.dispatch({
              changes: t,
              selection: i,
              scrollIntoView: !0,
              userEvent: "delete.line",
            }),
            !0
          );
        };
      function z0(n, e) {
        if (/\(\)|\[\]|\{\}/.test(n.sliceDoc(e - 1, e + 1)))
          return { from: e, to: e };
        let t = J(n).resolveInner(e),
          i = t.childBefore(e),
          r = t.childAfter(e),
          s;
        return i &&
          r &&
          i.to <= e &&
          r.from >= e &&
          (s = i.type.prop(Y.closedBy)) &&
          s.indexOf(r.name) > -1 &&
          n.doc.lineAt(i.to).from == n.doc.lineAt(r.from).from &&
          !/\S/.test(n.sliceDoc(i.to, r.from))
          ? { from: i.to, to: r.from }
          : null;
      }
      const Ia = mu(!1),
        D0 = mu(!0);
      function mu(n) {
        return ({ state: e, dispatch: t }) => {
          if (e.readOnly) return !1;
          let i = e.changeByRange((r) => {
            let { from: s, to: o } = r,
              l = e.doc.lineAt(s),
              a = !n && s == o && z0(e, s);
            n && (s = o = (o <= l.to ? l : e.doc.lineAt(o)).to);
            let h = new Er(e, { simulateBreak: s, simulateDoubleBreak: !!a }),
              c = Fo(h, s);
            for (
              c == null &&
              (c = gi(/^\s*/.exec(e.doc.lineAt(s).text)[0], e.tabSize));
              o < l.to && /\s/.test(l.text[o - l.from]);

            )
              o++;
            a
              ? ({ from: s, to: o } = a)
              : s > l.from &&
                s < l.from + 100 &&
                !/\S/.test(l.text.slice(0, s)) &&
                (s = l.from);
            let f = ["", Hi(e, c)];
            return (
              a && f.push(Hi(e, h.lineIndent(l.from, -1))),
              {
                changes: { from: s, to: o, insert: E.of(f) },
                range: S.cursor(s + 1 + f[1].length),
              }
            );
          });
          return t(e.update(i, { scrollIntoView: !0, userEvent: "input" })), !0;
        };
      }
      function el(n, e) {
        let t = -1;
        return n.changeByRange((i) => {
          let r = [];
          for (let o = i.from; o <= i.to; ) {
            let l = n.doc.lineAt(o);
            l.number > t &&
              (i.empty || i.to > l.from) &&
              (e(l, r, i), (t = l.number)),
              (o = l.to + 1);
          }
          let s = n.changes(r);
          return {
            changes: r,
            range: S.range(s.mapPos(i.anchor, 1), s.mapPos(i.head, 1)),
          };
        });
      }
      const E0 = ({ state: n, dispatch: e }) => {
          if (n.readOnly) return !1;
          let t = Object.create(null),
            i = new Er(n, {
              overrideIndentation: (s) => {
                let o = t[s];
                return o ?? -1;
              },
            }),
            r = el(n, (s, o, l) => {
              let a = Fo(i, s.from);
              if (a == null) return;
              /\S/.test(s.text) || (a = 0);
              let h = /^\s*/.exec(s.text)[0],
                c = Hi(n, a);
              (h != c || l.from < s.from + h.length) &&
                ((t[s.from] = a),
                o.push({ from: s.from, to: s.from + h.length, insert: c }));
            });
          return r.changes.empty || e(n.update(r, { userEvent: "indent" })), !0;
        },
        _0 = ({ state: n, dispatch: e }) =>
          n.readOnly
            ? !1
            : (e(
                n.update(
                  el(n, (t, i) => {
                    i.push({ from: t.from, insert: n.facet(Dr) });
                  }),
                  { userEvent: "input.indent" }
                )
              ),
              !0),
        V0 = ({ state: n, dispatch: e }) =>
          n.readOnly
            ? !1
            : (e(
                n.update(
                  el(n, (t, i) => {
                    let r = /^\s*/.exec(t.text)[0];
                    if (!r) return;
                    let s = gi(r, n.tabSize),
                      o = 0,
                      l = Hi(n, Math.max(0, s - fr(n)));
                    for (
                      ;
                      o < r.length &&
                      o < l.length &&
                      r.charCodeAt(o) == l.charCodeAt(o);

                    )
                      o++;
                    i.push({
                      from: t.from + o,
                      to: t.from + r.length,
                      insert: l.slice(o),
                    });
                  }),
                  { userEvent: "delete.dedent" }
                )
              ),
              !0),
        q0 = (n) => (n.setTabFocusMode(), !0),
        W0 = [
          { key: "Ctrl-b", run: Nf, shift: nu, preventDefault: !0 },
          { key: "Ctrl-f", run: Uf, shift: ru },
          { key: "Ctrl-p", run: Kf, shift: lu },
          { key: "Ctrl-n", run: Jf, shift: au },
          { key: "Ctrl-a", run: l0, shift: S0 },
          { key: "Ctrl-e", run: a0, shift: y0 },
          { key: "Ctrl-d", run: fu },
          { key: "Ctrl-h", run: bo },
          { key: "Ctrl-k", run: P0 },
          { key: "Ctrl-Alt-h", run: du },
          { key: "Ctrl-o", run: C0 },
          { key: "Ctrl-t", run: Z0 },
          { key: "Ctrl-v", run: yo },
        ],
        L0 = [
          { key: "ArrowLeft", run: Nf, shift: nu, preventDefault: !0 },
          {
            key: "Mod-ArrowLeft",
            mac: "Alt-ArrowLeft",
            run: Kg,
            shift: f0,
            preventDefault: !0,
          },
          { mac: "Cmd-ArrowLeft", run: s0, shift: g0, preventDefault: !0 },
          { key: "ArrowRight", run: Uf, shift: ru, preventDefault: !0 },
          {
            key: "Mod-ArrowRight",
            mac: "Alt-ArrowRight",
            run: Jg,
            shift: u0,
            preventDefault: !0,
          },
          { mac: "Cmd-ArrowRight", run: o0, shift: Q0, preventDefault: !0 },
          { key: "ArrowUp", run: Kf, shift: lu, preventDefault: !0 },
          { mac: "Cmd-ArrowUp", run: Wa, shift: ja },
          { mac: "Ctrl-ArrowUp", run: _a, shift: Va },
          { key: "ArrowDown", run: Jf, shift: au, preventDefault: !0 },
          { mac: "Cmd-ArrowDown", run: La, shift: Ba },
          { mac: "Ctrl-ArrowDown", run: yo, shift: qa },
          { key: "PageUp", run: _a, shift: Va },
          { key: "PageDown", run: yo, shift: qa },
          { key: "Home", run: r0, shift: m0, preventDefault: !0 },
          { key: "Mod-Home", run: Wa, shift: ja },
          { key: "End", run: n0, shift: p0, preventDefault: !0 },
          { key: "Mod-End", run: La, shift: Ba },
          { key: "Enter", run: Ia, shift: Ia },
          { key: "Mod-a", run: b0 },
          { key: "Backspace", run: bo, shift: bo },
          { key: "Delete", run: fu },
          { key: "Mod-Backspace", mac: "Alt-Backspace", run: du },
          { key: "Mod-Delete", mac: "Alt-Delete", run: $0 },
          { mac: "Mod-Backspace", run: v0 },
          { mac: "Mod-Delete", run: T0 },
        ].concat(W0.map((n) => ({ mac: n.key, run: n.run, shift: n.shift }))),
        j0 = [
          { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: t0, shift: d0 },
          { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: i0, shift: O0 },
          { key: "Alt-ArrowUp", run: A0 },
          { key: "Shift-Alt-ArrowUp", run: R0 },
          { key: "Alt-ArrowDown", run: X0 },
          { key: "Shift-Alt-ArrowDown", run: M0 },
          { key: "Escape", run: k0 },
          { key: "Mod-Enter", run: D0 },
          { key: "Alt-l", mac: "Ctrl-l", run: x0 },
          { key: "Mod-i", run: w0, preventDefault: !0 },
          { key: "Mod-[", run: V0 },
          { key: "Mod-]", run: _0 },
          { key: "Mod-Alt-\\", run: E0 },
          { key: "Shift-Mod-k", run: Y0 },
          { key: "Shift-Mod-\\", run: c0 },
          { key: "Mod-/", run: Rg },
          { key: "Alt-A", run: Yg },
          { key: "Ctrl-m", mac: "Shift-Alt-m", run: q0 },
        ].concat(L0),
        Ga =
          typeof String.prototype.normalize == "function"
            ? (n) => n.normalize("NFKD")
            : (n) => n;
      class ui {
        constructor(e, t, i = 0, r = e.length, s, o) {
          (this.test = o),
            (this.value = { from: 0, to: 0 }),
            (this.done = !1),
            (this.matches = []),
            (this.buffer = ""),
            (this.bufferPos = 0),
            (this.iter = e.iterRange(i, r)),
            (this.bufferStart = i),
            (this.normalize = s ? (l) => s(Ga(l)) : Ga),
            (this.query = this.normalize(t));
        }
        peek() {
          if (this.bufferPos == this.buffer.length) {
            if (
              ((this.bufferStart += this.buffer.length),
              this.iter.next(),
              this.iter.done)
            )
              return -1;
            (this.bufferPos = 0), (this.buffer = this.iter.value);
          }
          return be(this.buffer, this.bufferPos);
        }
        next() {
          for (; this.matches.length; ) this.matches.pop();
          return this.nextOverlapping();
        }
        nextOverlapping() {
          for (;;) {
            let e = this.peek();
            if (e < 0) return (this.done = !0), this;
            let t = Co(e),
              i = this.bufferStart + this.bufferPos;
            this.bufferPos += Je(e);
            let r = this.normalize(t);
            if (r.length)
              for (let s = 0, o = i; ; s++) {
                let l = r.charCodeAt(s),
                  a = this.match(l, o, this.bufferPos + this.bufferStart);
                if (s == r.length - 1) {
                  if (a) return (this.value = a), this;
                  break;
                }
                o == i && s < t.length && t.charCodeAt(s) == l && o++;
              }
          }
        }
        match(e, t, i) {
          let r = null;
          for (let s = 0; s < this.matches.length; s += 2) {
            let o = this.matches[s],
              l = !1;
            this.query.charCodeAt(o) == e &&
              (o == this.query.length - 1
                ? (r = { from: this.matches[s + 1], to: i })
                : (this.matches[s]++, (l = !0))),
              l || (this.matches.splice(s, 2), (s -= 2));
          }
          return (
            this.query.charCodeAt(0) == e &&
              (this.query.length == 1
                ? (r = { from: t, to: i })
                : this.matches.push(1, t)),
            r &&
              this.test &&
              !this.test(r.from, r.to, this.buffer, this.bufferStart) &&
              (r = null),
            r
          );
        }
      }
      typeof Symbol < "u" &&
        (ui.prototype[Symbol.iterator] = function () {
          return this;
        });
      const gu = { from: -1, to: -1, match: /.*/.exec("") },
        tl = "gm" + (/x/.unicode == null ? "" : "u");
      class Qu {
        constructor(e, t, i, r = 0, s = e.length) {
          if (
            ((this.text = e),
            (this.to = s),
            (this.curLine = ""),
            (this.done = !1),
            (this.value = gu),
            /\\[sWDnr]|\n|\r|\[\^/.test(t))
          )
            return new Su(e, t, i, r, s);
          (this.re = new RegExp(t, tl + (i?.ignoreCase ? "i" : ""))),
            (this.test = i?.test),
            (this.iter = e.iter());
          let o = e.lineAt(r);
          (this.curLineStart = o.from),
            (this.matchPos = pr(e, r)),
            this.getLine(this.curLineStart);
        }
        getLine(e) {
          this.iter.next(e),
            this.iter.lineBreak
              ? (this.curLine = "")
              : ((this.curLine = this.iter.value),
                this.curLineStart + this.curLine.length > this.to &&
                  (this.curLine = this.curLine.slice(
                    0,
                    this.to - this.curLineStart
                  )),
                this.iter.next());
        }
        nextLine() {
          (this.curLineStart = this.curLineStart + this.curLine.length + 1),
            this.curLineStart > this.to ? (this.curLine = "") : this.getLine(0);
        }
        next() {
          for (let e = this.matchPos - this.curLineStart; ; ) {
            this.re.lastIndex = e;
            let t = this.matchPos <= this.to && this.re.exec(this.curLine);
            if (t) {
              let i = this.curLineStart + t.index,
                r = i + t[0].length;
              if (
                ((this.matchPos = pr(this.text, r + (i == r ? 1 : 0))),
                i == this.curLineStart + this.curLine.length && this.nextLine(),
                (i < r || i > this.value.to) &&
                  (!this.test || this.test(i, r, t)))
              )
                return (this.value = { from: i, to: r, match: t }), this;
              e = this.matchPos - this.curLineStart;
            } else if (this.curLineStart + this.curLine.length < this.to)
              this.nextLine(), (e = 0);
            else return (this.done = !0), this;
          }
        }
      }
      const ds = new WeakMap();
      class ni {
        constructor(e, t) {
          (this.from = e), (this.text = t);
        }
        get to() {
          return this.from + this.text.length;
        }
        static get(e, t, i) {
          let r = ds.get(e);
          if (!r || r.from >= i || r.to <= t) {
            let l = new ni(t, e.sliceString(t, i));
            return ds.set(e, l), l;
          }
          if (r.from == t && r.to == i) return r;
          let { text: s, from: o } = r;
          return (
            o > t && ((s = e.sliceString(t, o) + s), (o = t)),
            r.to < i && (s += e.sliceString(r.to, i)),
            ds.set(e, new ni(o, s)),
            new ni(t, s.slice(t - o, i - o))
          );
        }
      }
      class Su {
        constructor(e, t, i, r, s) {
          (this.text = e),
            (this.to = s),
            (this.done = !1),
            (this.value = gu),
            (this.matchPos = pr(e, r)),
            (this.re = new RegExp(t, tl + (i?.ignoreCase ? "i" : ""))),
            (this.test = i?.test),
            (this.flat = ni.get(e, r, this.chunkEnd(r + 5e3)));
        }
        chunkEnd(e) {
          return e >= this.to ? this.to : this.text.lineAt(e).to;
        }
        next() {
          for (;;) {
            let e = (this.re.lastIndex = this.matchPos - this.flat.from),
              t = this.re.exec(this.flat.text);
            if (
              (t &&
                !t[0] &&
                t.index == e &&
                ((this.re.lastIndex = e + 1),
                (t = this.re.exec(this.flat.text))),
              t)
            ) {
              let i = this.flat.from + t.index,
                r = i + t[0].length;
              if (
                (this.flat.to >= this.to ||
                  t.index + t[0].length <= this.flat.text.length - 10) &&
                (!this.test || this.test(i, r, t))
              )
                return (
                  (this.value = { from: i, to: r, match: t }),
                  (this.matchPos = pr(this.text, r + (i == r ? 1 : 0))),
                  this
                );
            }
            if (this.flat.to == this.to) return (this.done = !0), this;
            this.flat = ni.get(
              this.text,
              this.flat.from,
              this.chunkEnd(this.flat.from + this.flat.text.length * 2)
            );
          }
        }
      }
      typeof Symbol < "u" &&
        (Qu.prototype[Symbol.iterator] = Su.prototype[Symbol.iterator] =
          function () {
            return this;
          });
      function B0(n) {
        try {
          return new RegExp(n, tl), !0;
        } catch {
          return !1;
        }
      }
      function pr(n, e) {
        if (e >= n.length) return e;
        let t = n.lineAt(e),
          i;
        for (
          ;
          e < t.to && (i = t.text.charCodeAt(e - t.from)) >= 56320 && i < 57344;

        )
          e++;
        return e;
      }
      function xo(n) {
        let e = String(n.state.doc.lineAt(n.state.selection.main.head).number),
          t = j("input", { class: "cm-textfield", name: "line", value: e }),
          i = j(
            "form",
            {
              class: "cm-gotoLine",
              onkeydown: (s) => {
                s.keyCode == 27
                  ? (s.preventDefault(),
                    n.dispatch({ effects: _i.of(!1) }),
                    n.focus())
                  : s.keyCode == 13 && (s.preventDefault(), r());
              },
              onsubmit: (s) => {
                s.preventDefault(), r();
              },
            },
            j("label", n.state.phrase("Go to line"), ": ", t),
            " ",
            j(
              "button",
              { class: "cm-button", type: "submit" },
              n.state.phrase("go")
            ),
            j(
              "button",
              {
                name: "close",
                onclick: () => {
                  n.dispatch({ effects: _i.of(!1) }), n.focus();
                },
                "aria-label": n.state.phrase("close"),
                type: "button",
              },
              [""]
            )
          );
        function r() {
          let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(t.value);
          if (!s) return;
          let { state: o } = n,
            l = o.doc.lineAt(o.selection.main.head),
            [, a, h, c, f] = s,
            u = c ? +c.slice(1) : 0,
            d = h ? +h : l.number;
          if (h && f) {
            let g = d / 100;
            a && (g = g * (a == "-" ? -1 : 1) + l.number / o.doc.lines),
              (d = Math.round(o.doc.lines * g));
          } else h && a && (d = d * (a == "-" ? -1 : 1) + l.number);
          let O = o.doc.line(Math.max(1, Math.min(o.doc.lines, d))),
            m = S.cursor(O.from + Math.max(0, Math.min(u, O.length)));
          n.dispatch({
            effects: [_i.of(!1), v.scrollIntoView(m.from, { y: "center" })],
            selection: m,
          }),
            n.focus();
        }
        return { dom: i };
      }
      const _i = R.define(),
        Na = oe.define({
          create() {
            return !0;
          },
          update(n, e) {
            for (let t of e.effects) t.is(_i) && (n = t.value);
            return n;
          },
          provide: (n) => Ni.from(n, (e) => (e ? xo : null)),
        }),
        I0 = (n) => {
          let e = Gi(n, xo);
          if (!e) {
            let t = [_i.of(!0)];
            n.state.field(Na, !1) == null &&
              t.push(R.appendConfig.of([Na, G0])),
              n.dispatch({ effects: t }),
              (e = Gi(n, xo));
          }
          return e && e.dom.querySelector("input").select(), !0;
        },
        G0 = v.baseTheme({
          ".cm-panel.cm-gotoLine": {
            padding: "2px 6px 4px",
            position: "relative",
            "& label": { fontSize: "80%" },
            "& [name=close]": {
              position: "absolute",
              top: "0",
              bottom: "0",
              right: "4px",
              backgroundColor: "inherit",
              border: "none",
              font: "inherit",
              padding: "0",
            },
          },
        }),
        N0 = {
          highlightWordAroundCursor: !1,
          minSelectionLength: 1,
          maxMatches: 100,
          wholeWords: !1,
        },
        U0 = C.define({
          combine(n) {
            return lt(n, N0, {
              highlightWordAroundCursor: (e, t) => e || t,
              minSelectionLength: Math.min,
              maxMatches: Math.min,
            });
          },
        });
      function F0(n) {
        return [tQ, eQ];
      }
      const H0 = A.mark({ class: "cm-selectionMatch" }),
        K0 = A.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
      function Ua(n, e, t, i) {
        return (
          (t == 0 || n(e.sliceDoc(t - 1, t)) != H.Word) &&
          (i == e.doc.length || n(e.sliceDoc(i, i + 1)) != H.Word)
        );
      }
      function J0(n, e, t, i) {
        return (
          n(e.sliceDoc(t, t + 1)) == H.Word && n(e.sliceDoc(i - 1, i)) == H.Word
        );
      }
      const eQ = ne.fromClass(
          class {
            constructor(n) {
              this.decorations = this.getDeco(n);
            }
            update(n) {
              (n.selectionSet || n.docChanged || n.viewportChanged) &&
                (this.decorations = this.getDeco(n.view));
            }
            getDeco(n) {
              let e = n.state.facet(U0),
                { state: t } = n,
                i = t.selection;
              if (i.ranges.length > 1) return A.none;
              let r = i.main,
                s,
                o = null;
              if (r.empty) {
                if (!e.highlightWordAroundCursor) return A.none;
                let a = t.wordAt(r.head);
                if (!a) return A.none;
                (o = t.charCategorizer(r.head)), (s = t.sliceDoc(a.from, a.to));
              } else {
                let a = r.to - r.from;
                if (a < e.minSelectionLength || a > 200) return A.none;
                if (e.wholeWords) {
                  if (
                    ((s = t.sliceDoc(r.from, r.to)),
                    (o = t.charCategorizer(r.head)),
                    !(Ua(o, t, r.from, r.to) && J0(o, t, r.from, r.to)))
                  )
                    return A.none;
                } else if (((s = t.sliceDoc(r.from, r.to)), !s)) return A.none;
              }
              let l = [];
              for (let a of n.visibleRanges) {
                let h = new ui(t.doc, s, a.from, a.to);
                for (; !h.next().done; ) {
                  let { from: c, to: f } = h.value;
                  if (
                    (!o || Ua(o, t, c, f)) &&
                    (r.empty && c <= r.from && f >= r.to
                      ? l.push(K0.range(c, f))
                      : (c >= r.to || f <= r.from) && l.push(H0.range(c, f)),
                    l.length > e.maxMatches)
                  )
                    return A.none;
                }
              }
              return A.set(l);
            }
          },
          { decorations: (n) => n.decorations }
        ),
        tQ = v.baseTheme({
          ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
          ".cm-searchMatch .cm-selectionMatch": {
            backgroundColor: "transparent",
          },
        }),
        iQ = ({ state: n, dispatch: e }) => {
          let { selection: t } = n,
            i = S.create(
              t.ranges.map((r) => n.wordAt(r.head) || S.cursor(r.head)),
              t.mainIndex
            );
          return i.eq(t) ? !1 : (e(n.update({ selection: i })), !0);
        };
      function nQ(n, e) {
        let { main: t, ranges: i } = n.selection,
          r = n.wordAt(t.head),
          s = r && r.from == t.from && r.to == t.to;
        for (let o = !1, l = new ui(n.doc, e, i[i.length - 1].to); ; )
          if ((l.next(), l.done)) {
            if (o) return null;
            (l = new ui(n.doc, e, 0, Math.max(0, i[i.length - 1].from - 1))),
              (o = !0);
          } else {
            if (o && i.some((a) => a.from == l.value.from)) continue;
            if (s) {
              let a = n.wordAt(l.value.from);
              if (!a || a.from != l.value.from || a.to != l.value.to) continue;
            }
            return l.value;
          }
      }
      const rQ = ({ state: n, dispatch: e }) => {
          let { ranges: t } = n.selection;
          if (t.some((s) => s.from === s.to))
            return iQ({ state: n, dispatch: e });
          let i = n.sliceDoc(t[0].from, t[0].to);
          if (n.selection.ranges.some((s) => n.sliceDoc(s.from, s.to) != i))
            return !1;
          let r = nQ(n, i);
          return r
            ? (e(
                n.update({
                  selection: n.selection.addRange(S.range(r.from, r.to), !1),
                  effects: v.scrollIntoView(r.to),
                })
              ),
              !0)
            : !1;
        },
        Si = C.define({
          combine(n) {
            return lt(n, {
              top: !1,
              caseSensitive: !1,
              literal: !1,
              regexp: !1,
              wholeWord: !1,
              createPanel: (e) => new mQ(e),
              scrollToMatch: (e) => v.scrollIntoView(e),
            });
          },
        });
      class yu {
        constructor(e) {
          (this.search = e.search),
            (this.caseSensitive = !!e.caseSensitive),
            (this.literal = !!e.literal),
            (this.regexp = !!e.regexp),
            (this.replace = e.replace || ""),
            (this.valid = !!this.search && (!this.regexp || B0(this.search))),
            (this.unquoted = this.unquote(this.search)),
            (this.wholeWord = !!e.wholeWord);
        }
        unquote(e) {
          return this.literal
            ? e
            : e.replace(/\\([nrt\\])/g, (t, i) =>
                i == "n"
                  ? `
`
                  : i == "r"
                  ? "\r"
                  : i == "t"
                  ? "	"
                  : "\\"
              );
        }
        eq(e) {
          return (
            this.search == e.search &&
            this.replace == e.replace &&
            this.caseSensitive == e.caseSensitive &&
            this.regexp == e.regexp &&
            this.wholeWord == e.wholeWord
          );
        }
        create() {
          return this.regexp ? new aQ(this) : new oQ(this);
        }
        getCursor(e, t = 0, i) {
          let r = e.doc ? e : _.create({ doc: e });
          return (
            i == null && (i = r.doc.length),
            this.regexp ? Ut(this, r, t, i) : Nt(this, r, t, i)
          );
        }
      }
      class bu {
        constructor(e) {
          this.spec = e;
        }
      }
      function Nt(n, e, t, i) {
        return new ui(
          e.doc,
          n.unquoted,
          t,
          i,
          n.caseSensitive ? void 0 : (r) => r.toLowerCase(),
          n.wholeWord
            ? sQ(e.doc, e.charCategorizer(e.selection.main.head))
            : void 0
        );
      }
      function sQ(n, e) {
        return (t, i, r, s) => (
          (s > t || s + r.length < i) &&
            ((s = Math.max(0, t - 2)),
            (r = n.sliceString(s, Math.min(n.length, i + 2)))),
          (e(mr(r, t - s)) != H.Word || e(gr(r, t - s)) != H.Word) &&
            (e(gr(r, i - s)) != H.Word || e(mr(r, i - s)) != H.Word)
        );
      }
      class oQ extends bu {
        constructor(e) {
          super(e);
        }
        nextMatch(e, t, i) {
          let r = Nt(this.spec, e, i, e.doc.length).nextOverlapping();
          if (r.done) {
            let s = Math.min(e.doc.length, t + this.spec.unquoted.length);
            r = Nt(this.spec, e, 0, s).nextOverlapping();
          }
          return r.done || (r.value.from == t && r.value.to == i)
            ? null
            : r.value;
        }
        prevMatchInRange(e, t, i) {
          for (let r = i; ; ) {
            let s = Math.max(t, r - 1e4 - this.spec.unquoted.length),
              o = Nt(this.spec, e, s, r),
              l = null;
            for (; !o.nextOverlapping().done; ) l = o.value;
            if (l) return l;
            if (s == t) return null;
            r -= 1e4;
          }
        }
        prevMatch(e, t, i) {
          let r = this.prevMatchInRange(e, 0, t);
          return (
            r ||
              (r = this.prevMatchInRange(
                e,
                Math.max(0, i - this.spec.unquoted.length),
                e.doc.length
              )),
            r && (r.from != t || r.to != i) ? r : null
          );
        }
        getReplacement(e) {
          return this.spec.unquote(this.spec.replace);
        }
        matchAll(e, t) {
          let i = Nt(this.spec, e, 0, e.doc.length),
            r = [];
          for (; !i.next().done; ) {
            if (r.length >= t) return null;
            r.push(i.value);
          }
          return r;
        }
        highlight(e, t, i, r) {
          let s = Nt(
            this.spec,
            e,
            Math.max(0, t - this.spec.unquoted.length),
            Math.min(i + this.spec.unquoted.length, e.doc.length)
          );
          for (; !s.next().done; ) r(s.value.from, s.value.to);
        }
      }
      function Ut(n, e, t, i) {
        return new Qu(
          e.doc,
          n.search,
          {
            ignoreCase: !n.caseSensitive,
            test: n.wholeWord
              ? lQ(e.charCategorizer(e.selection.main.head))
              : void 0,
          },
          t,
          i
        );
      }
      function mr(n, e) {
        return n.slice(fe(n, e, !1), e);
      }
      function gr(n, e) {
        return n.slice(e, fe(n, e));
      }
      function lQ(n) {
        return (e, t, i) =>
          !i[0].length ||
          ((n(mr(i.input, i.index)) != H.Word ||
            n(gr(i.input, i.index)) != H.Word) &&
            (n(gr(i.input, i.index + i[0].length)) != H.Word ||
              n(mr(i.input, i.index + i[0].length)) != H.Word));
      }
      class aQ extends bu {
        nextMatch(e, t, i) {
          let r = Ut(this.spec, e, i, e.doc.length).next();
          return (
            r.done && (r = Ut(this.spec, e, 0, t).next()),
            r.done ? null : r.value
          );
        }
        prevMatchInRange(e, t, i) {
          for (let r = 1; ; r++) {
            let s = Math.max(t, i - r * 1e4),
              o = Ut(this.spec, e, s, i),
              l = null;
            for (; !o.next().done; ) l = o.value;
            if (l && (s == t || l.from > s + 10)) return l;
            if (s == t) return null;
          }
        }
        prevMatch(e, t, i) {
          return (
            this.prevMatchInRange(e, 0, t) ||
            this.prevMatchInRange(e, i, e.doc.length)
          );
        }
        getReplacement(e) {
          return this.spec
            .unquote(this.spec.replace)
            .replace(/\$([$&]|\d+)/g, (t, i) => {
              if (i == "&") return e.match[0];
              if (i == "$") return "$";
              for (let r = i.length; r > 0; r--) {
                let s = +i.slice(0, r);
                if (s > 0 && s < e.match.length) return e.match[s] + i.slice(r);
              }
              return t;
            });
        }
        matchAll(e, t) {
          let i = Ut(this.spec, e, 0, e.doc.length),
            r = [];
          for (; !i.next().done; ) {
            if (r.length >= t) return null;
            r.push(i.value);
          }
          return r;
        }
        highlight(e, t, i, r) {
          let s = Ut(
            this.spec,
            e,
            Math.max(0, t - 250),
            Math.min(i + 250, e.doc.length)
          );
          for (; !s.next().done; ) r(s.value.from, s.value.to);
        }
      }
      const Ki = R.define(),
        il = R.define(),
        Pt = oe.define({
          create(n) {
            return new Os(wo(n).create(), null);
          },
          update(n, e) {
            for (let t of e.effects)
              t.is(Ki)
                ? (n = new Os(t.value.create(), n.panel))
                : t.is(il) && (n = new Os(n.query, t.value ? nl : null));
            return n;
          },
          provide: (n) => Ni.from(n, (e) => e.panel),
        });
      class Os {
        constructor(e, t) {
          (this.query = e), (this.panel = t);
        }
      }
      const hQ = A.mark({ class: "cm-searchMatch" }),
        cQ = A.mark({ class: "cm-searchMatch cm-searchMatch-selected" }),
        fQ = ne.fromClass(
          class {
            constructor(n) {
              (this.view = n),
                (this.decorations = this.highlight(n.state.field(Pt)));
            }
            update(n) {
              let e = n.state.field(Pt);
              (e != n.startState.field(Pt) ||
                n.docChanged ||
                n.selectionSet ||
                n.viewportChanged) &&
                (this.decorations = this.highlight(e));
            }
            highlight({ query: n, panel: e }) {
              if (!e || !n.spec.valid) return A.none;
              let { view: t } = this,
                i = new pt();
              for (let r = 0, s = t.visibleRanges, o = s.length; r < o; r++) {
                let { from: l, to: a } = s[r];
                for (; r < o - 1 && a > s[r + 1].from - 500; ) a = s[++r].to;
                n.highlight(t.state, l, a, (h, c) => {
                  let f = t.state.selection.ranges.some(
                    (u) => u.from == h && u.to == c
                  );
                  i.add(h, c, f ? cQ : hQ);
                });
              }
              return i.finish();
            }
          },
          { decorations: (n) => n.decorations }
        );
      function un(n) {
        return (e) => {
          let t = e.state.field(Pt, !1);
          return t && t.query.spec.valid ? n(e, t) : ku(e);
        };
      }
      const Qr = un((n, { query: e }) => {
          let { to: t } = n.state.selection.main,
            i = e.nextMatch(n.state, t, t);
          if (!i) return !1;
          let r = S.single(i.from, i.to),
            s = n.state.facet(Si);
          return (
            n.dispatch({
              selection: r,
              effects: [rl(n, i), s.scrollToMatch(r.main, n)],
              userEvent: "select.search",
            }),
            wu(n),
            !0
          );
        }),
        Sr = un((n, { query: e }) => {
          let { state: t } = n,
            { from: i } = t.selection.main,
            r = e.prevMatch(t, i, i);
          if (!r) return !1;
          let s = S.single(r.from, r.to),
            o = n.state.facet(Si);
          return (
            n.dispatch({
              selection: s,
              effects: [rl(n, r), o.scrollToMatch(s.main, n)],
              userEvent: "select.search",
            }),
            wu(n),
            !0
          );
        }),
        uQ = un((n, { query: e }) => {
          let t = e.matchAll(n.state, 1e3);
          return !t || !t.length
            ? !1
            : (n.dispatch({
                selection: S.create(t.map((i) => S.range(i.from, i.to))),
                userEvent: "select.search.matches",
              }),
              !0);
        }),
        dQ = ({ state: n, dispatch: e }) => {
          let t = n.selection;
          if (t.ranges.length > 1 || t.main.empty) return !1;
          let { from: i, to: r } = t.main,
            s = [],
            o = 0;
          for (let l = new ui(n.doc, n.sliceDoc(i, r)); !l.next().done; ) {
            if (s.length > 1e3) return !1;
            l.value.from == i && (o = s.length),
              s.push(S.range(l.value.from, l.value.to));
          }
          return (
            e(
              n.update({
                selection: S.create(s, o),
                userEvent: "select.search.matches",
              })
            ),
            !0
          );
        },
        Fa = un((n, { query: e }) => {
          let { state: t } = n,
            { from: i, to: r } = t.selection.main;
          if (t.readOnly) return !1;
          let s = e.nextMatch(t, i, i);
          if (!s) return !1;
          let o = s,
            l = [],
            a,
            h,
            c = [];
          o.from == i &&
            o.to == r &&
            ((h = t.toText(e.getReplacement(o))),
            l.push({ from: o.from, to: o.to, insert: h }),
            (o = e.nextMatch(t, o.from, o.to)),
            c.push(
              v.announce.of(
                t.phrase("replaced match on line $", t.doc.lineAt(i).number) +
                  "."
              )
            ));
          let f = n.state.changes(l);
          return (
            o &&
              ((a = S.single(o.from, o.to).map(f)),
              c.push(rl(n, o)),
              c.push(t.facet(Si).scrollToMatch(a.main, n))),
            n.dispatch({
              changes: f,
              selection: a,
              effects: c,
              userEvent: "input.replace",
            }),
            !0
          );
        }),
        OQ = un((n, { query: e }) => {
          if (n.state.readOnly) return !1;
          let t = e.matchAll(n.state, 1e9).map((r) => {
            let { from: s, to: o } = r;
            return { from: s, to: o, insert: e.getReplacement(r) };
          });
          if (!t.length) return !1;
          let i = n.state.phrase("replaced $ matches", t.length) + ".";
          return (
            n.dispatch({
              changes: t,
              effects: v.announce.of(i),
              userEvent: "input.replace.all",
            }),
            !0
          );
        });
      function nl(n) {
        return n.state.facet(Si).createPanel(n);
      }
      function wo(n, e) {
        var t, i, r, s, o;
        let l = n.selection.main,
          a = l.empty || l.to > l.from + 100 ? "" : n.sliceDoc(l.from, l.to);
        if (e && !a) return e;
        let h = n.facet(Si);
        return new yu({
          search: ((t = e?.literal) !== null && t !== void 0 ? t : h.literal)
            ? a
            : a.replace(/\n/g, "\\n"),
          caseSensitive:
            (i = e?.caseSensitive) !== null && i !== void 0
              ? i
              : h.caseSensitive,
          literal: (r = e?.literal) !== null && r !== void 0 ? r : h.literal,
          regexp: (s = e?.regexp) !== null && s !== void 0 ? s : h.regexp,
          wholeWord:
            (o = e?.wholeWord) !== null && o !== void 0 ? o : h.wholeWord,
        });
      }
      function xu(n) {
        let e = Gi(n, nl);
        return e && e.dom.querySelector("[main-field]");
      }
      function wu(n) {
        let e = xu(n);
        e && e == n.root.activeElement && e.select();
      }
      const ku = (n) => {
          let e = n.state.field(Pt, !1);
          if (e && e.panel) {
            let t = xu(n);
            if (t && t != n.root.activeElement) {
              let i = wo(n.state, e.query.spec);
              i.valid && n.dispatch({ effects: Ki.of(i) }),
                t.focus(),
                t.select();
            }
          } else
            n.dispatch({
              effects: [
                il.of(!0),
                e ? Ki.of(wo(n.state, e.query.spec)) : R.appendConfig.of(QQ),
              ],
            });
          return !0;
        },
        $u = (n) => {
          let e = n.state.field(Pt, !1);
          if (!e || !e.panel) return !1;
          let t = Gi(n, nl);
          return (
            t && t.dom.contains(n.root.activeElement) && n.focus(),
            n.dispatch({ effects: il.of(!1) }),
            !0
          );
        },
        pQ = [
          { key: "Mod-f", run: ku, scope: "editor search-panel" },
          {
            key: "F3",
            run: Qr,
            shift: Sr,
            scope: "editor search-panel",
            preventDefault: !0,
          },
          {
            key: "Mod-g",
            run: Qr,
            shift: Sr,
            scope: "editor search-panel",
            preventDefault: !0,
          },
          { key: "Escape", run: $u, scope: "editor search-panel" },
          { key: "Mod-Shift-l", run: dQ },
          { key: "Mod-Alt-g", run: I0 },
          { key: "Mod-d", run: rQ, preventDefault: !0 },
        ];
      class mQ {
        constructor(e) {
          this.view = e;
          let t = (this.query = e.state.field(Pt).query.spec);
          (this.commit = this.commit.bind(this)),
            (this.searchField = j("input", {
              value: t.search,
              placeholder: ve(e, "Find"),
              "aria-label": ve(e, "Find"),
              class: "cm-textfield",
              name: "search",
              form: "",
              "main-field": "true",
              onchange: this.commit,
              onkeyup: this.commit,
            })),
            (this.replaceField = j("input", {
              value: t.replace,
              placeholder: ve(e, "Replace"),
              "aria-label": ve(e, "Replace"),
              class: "cm-textfield",
              name: "replace",
              form: "",
              onchange: this.commit,
              onkeyup: this.commit,
            })),
            (this.caseField = j("input", {
              type: "checkbox",
              name: "case",
              form: "",
              checked: t.caseSensitive,
              onchange: this.commit,
            })),
            (this.reField = j("input", {
              type: "checkbox",
              name: "re",
              form: "",
              checked: t.regexp,
              onchange: this.commit,
            })),
            (this.wordField = j("input", {
              type: "checkbox",
              name: "word",
              form: "",
              checked: t.wholeWord,
              onchange: this.commit,
            }));
          function i(r, s, o) {
            return j(
              "button",
              { class: "cm-button", name: r, onclick: s, type: "button" },
              o
            );
          }
          this.dom = j(
            "div",
            { onkeydown: (r) => this.keydown(r), class: "cm-search" },
            [
              this.searchField,
              i("next", () => Qr(e), [ve(e, "next")]),
              i("prev", () => Sr(e), [ve(e, "previous")]),
              i("select", () => uQ(e), [ve(e, "all")]),
              j("label", null, [this.caseField, ve(e, "match case")]),
              j("label", null, [this.reField, ve(e, "regexp")]),
              j("label", null, [this.wordField, ve(e, "by word")]),
              ...(e.state.readOnly
                ? []
                : [
                    j("br"),
                    this.replaceField,
                    i("replace", () => Fa(e), [ve(e, "replace")]),
                    i("replaceAll", () => OQ(e), [ve(e, "replace all")]),
                  ]),
              j(
                "button",
                {
                  name: "close",
                  onclick: () => $u(e),
                  "aria-label": ve(e, "close"),
                  type: "button",
                },
                [""]
              ),
            ]
          );
        }
        commit() {
          let e = new yu({
            search: this.searchField.value,
            caseSensitive: this.caseField.checked,
            regexp: this.reField.checked,
            wholeWord: this.wordField.checked,
            replace: this.replaceField.value,
          });
          e.eq(this.query) ||
            ((this.query = e), this.view.dispatch({ effects: Ki.of(e) }));
        }
        keydown(e) {
          xp(this.view, e, "search-panel")
            ? e.preventDefault()
            : e.keyCode == 13 && e.target == this.searchField
            ? (e.preventDefault(), (e.shiftKey ? Sr : Qr)(this.view))
            : e.keyCode == 13 &&
              e.target == this.replaceField &&
              (e.preventDefault(), Fa(this.view));
        }
        update(e) {
          for (let t of e.transactions)
            for (let i of t.effects)
              i.is(Ki) && !i.value.eq(this.query) && this.setQuery(i.value);
        }
        setQuery(e) {
          (this.query = e),
            (this.searchField.value = e.search),
            (this.replaceField.value = e.replace),
            (this.caseField.checked = e.caseSensitive),
            (this.reField.checked = e.regexp),
            (this.wordField.checked = e.wholeWord);
        }
        mount() {
          this.searchField.select();
        }
        get pos() {
          return 80;
        }
        get top() {
          return this.view.state.facet(Si).top;
        }
      }
      function ve(n, e) {
        return n.state.phrase(e);
      }
      const Mn = 30,
        Yn = /[\s\.,:;?!]/;
      function rl(n, { from: e, to: t }) {
        let i = n.state.doc.lineAt(e),
          r = n.state.doc.lineAt(t).to,
          s = Math.max(i.from, e - Mn),
          o = Math.min(r, t + Mn),
          l = n.state.sliceDoc(s, o);
        if (s != i.from) {
          for (let a = 0; a < Mn; a++)
            if (!Yn.test(l[a + 1]) && Yn.test(l[a])) {
              l = l.slice(a);
              break;
            }
        }
        if (o != r) {
          for (let a = l.length - 1; a > l.length - Mn; a--)
            if (!Yn.test(l[a - 1]) && Yn.test(l[a])) {
              l = l.slice(0, a);
              break;
            }
        }
        return v.announce.of(
          `${n.state.phrase("current match")}. ${l} ${n.state.phrase(
            "on line"
          )} ${i.number}.`
        );
      }
      const gQ = v.baseTheme({
          ".cm-panel.cm-search": {
            padding: "2px 6px 4px",
            position: "relative",
            "& [name=close]": {
              position: "absolute",
              top: "0",
              right: "4px",
              backgroundColor: "inherit",
              border: "none",
              font: "inherit",
              padding: 0,
              margin: 0,
            },
            "& input, & button, & label": { margin: ".2em .6em .2em 0" },
            "& input[type=checkbox]": { marginRight: ".2em" },
            "& label": { fontSize: "80%", whiteSpace: "pre" },
          },
          "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
          "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
          "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
          "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" },
        }),
        QQ = [Pt, Xt.low(fQ), gQ];
      class Pu {
        constructor(e, t, i, r) {
          (this.state = e),
            (this.pos = t),
            (this.explicit = i),
            (this.view = r),
            (this.abortListeners = []),
            (this.abortOnDocChange = !1);
        }
        tokenBefore(e) {
          let t = J(this.state).resolveInner(this.pos, -1);
          for (; t && e.indexOf(t.name) < 0; ) t = t.parent;
          return t
            ? {
                from: t.from,
                to: this.pos,
                text: this.state.sliceDoc(t.from, this.pos),
                type: t.type,
              }
            : null;
        }
        matchBefore(e) {
          let t = this.state.doc.lineAt(this.pos),
            i = Math.max(t.from, this.pos - 250),
            r = t.text.slice(i - t.from, this.pos - t.from),
            s = r.search(Tu(e, !1));
          return s < 0 ? null : { from: i + s, to: this.pos, text: r.slice(s) };
        }
        get aborted() {
          return this.abortListeners == null;
        }
        addEventListener(e, t, i) {
          e == "abort" &&
            this.abortListeners &&
            (this.abortListeners.push(t),
            i && i.onDocChange && (this.abortOnDocChange = !0));
        }
      }
      function Ha(n) {
        let e = Object.keys(n).join(""),
          t = /\w/.test(e);
        return (
          t && (e = e.replace(/\w/g, "")),
          `[${t ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`
        );
      }
      function SQ(n) {
        let e = Object.create(null),
          t = Object.create(null);
        for (let { label: r } of n) {
          e[r[0]] = !0;
          for (let s = 1; s < r.length; s++) t[r[s]] = !0;
        }
        let i = Ha(e) + Ha(t) + "*$";
        return [new RegExp("^" + i), new RegExp(i)];
      }
      function vu(n) {
        let e = n.map((r) => (typeof r == "string" ? { label: r } : r)),
          [t, i] = e.every((r) => /^\w+$/.test(r.label))
            ? [/\w*$/, /\w+$/]
            : SQ(e);
        return (r) => {
          let s = r.matchBefore(i);
          return s || r.explicit
            ? { from: s ? s.from : r.pos, options: e, validFor: t }
            : null;
        };
      }
      function yQ(n, e) {
        return (t) => {
          for (let i = J(t.state).resolveInner(t.pos, -1); i; i = i.parent) {
            if (n.indexOf(i.name) > -1) return null;
            if (i.type.isTop) break;
          }
          return e(t);
        };
      }
      class Ka {
        constructor(e, t, i, r) {
          (this.completion = e),
            (this.source = t),
            (this.match = i),
            (this.score = r);
        }
      }
      function Vt(n) {
        return n.selection.main.from;
      }
      function Tu(n, e) {
        var t;
        let { source: i } = n,
          r = e && i[0] != "^",
          s = i[i.length - 1] != "$";
        return !r && !s
          ? n
          : new RegExp(
              `${r ? "^" : ""}(?:${i})${s ? "$" : ""}`,
              (t = n.flags) !== null && t !== void 0
                ? t
                : n.ignoreCase
                ? "i"
                : ""
            );
      }
      const sl = Qt.define();
      function bQ(n, e, t, i) {
        let { main: r } = n.selection,
          s = t - r.from,
          o = i - r.from;
        return {
          ...n.changeByRange((l) => {
            if (
              l != r &&
              t != i &&
              n.sliceDoc(l.from + s, l.from + o) != n.sliceDoc(t, i)
            )
              return { range: l };
            let a = n.toText(e);
            return {
              changes: {
                from: l.from + s,
                to: i == r.from ? l.to : l.from + o,
                insert: a,
              },
              range: S.cursor(l.from + s + a.length),
            };
          }),
          scrollIntoView: !0,
          userEvent: "input.complete",
        };
      }
      const Ja = new WeakMap();
      function xQ(n) {
        if (!Array.isArray(n)) return n;
        let e = Ja.get(n);
        return e || Ja.set(n, (e = vu(n))), e;
      }
      const yr = R.define(),
        Ji = R.define();
      class wQ {
        constructor(e) {
          (this.pattern = e),
            (this.chars = []),
            (this.folded = []),
            (this.any = []),
            (this.precise = []),
            (this.byWord = []),
            (this.score = 0),
            (this.matched = []);
          for (let t = 0; t < e.length; ) {
            let i = be(e, t),
              r = Je(i);
            this.chars.push(i);
            let s = e.slice(t, t + r),
              o = s.toUpperCase();
            this.folded.push(be(o == s ? s.toLowerCase() : o, 0)), (t += r);
          }
          this.astral = e.length != this.chars.length;
        }
        ret(e, t) {
          return (this.score = e), (this.matched = t), this;
        }
        match(e) {
          if (this.pattern.length == 0) return this.ret(-100, []);
          if (e.length < this.pattern.length) return null;
          let { chars: t, folded: i, any: r, precise: s, byWord: o } = this;
          if (t.length == 1) {
            let y = be(e, 0),
              x = Je(y),
              k = x == e.length ? 0 : -100;
            if (y != t[0])
              if (y == i[0]) k += -200;
              else return null;
            return this.ret(k, [0, x]);
          }
          let l = e.indexOf(this.pattern);
          if (l == 0)
            return this.ret(e.length == this.pattern.length ? 0 : -100, [
              0,
              this.pattern.length,
            ]);
          let a = t.length,
            h = 0;
          if (l < 0) {
            for (let y = 0, x = Math.min(e.length, 200); y < x && h < a; ) {
              let k = be(e, y);
              (k == t[h] || k == i[h]) && (r[h++] = y), (y += Je(k));
            }
            if (h < a) return null;
          }
          let c = 0,
            f = 0,
            u = !1,
            d = 0,
            O = -1,
            m = -1,
            g = /[a-z]/.test(e),
            Q = !0;
          for (
            let y = 0, x = Math.min(e.length, 200), k = 0;
            y < x && f < a;

          ) {
            let b = be(e, y);
            l < 0 &&
              (c < a && b == t[c] && (s[c++] = y),
              d < a &&
                (b == t[d] || b == i[d]
                  ? (d == 0 && (O = y), (m = y + 1), d++)
                  : (d = 0)));
            let w,
              P =
                b < 255
                  ? (b >= 48 && b <= 57) || (b >= 97 && b <= 122)
                    ? 2
                    : b >= 65 && b <= 90
                    ? 1
                    : 0
                  : (w = Co(b)) != w.toLowerCase()
                  ? 1
                  : w != w.toUpperCase()
                  ? 2
                  : 0;
            (!y || (P == 1 && g) || (k == 0 && P != 0)) &&
              (t[f] == b || (i[f] == b && (u = !0))
                ? (o[f++] = y)
                : o.length && (Q = !1)),
              (k = P),
              (y += Je(b));
          }
          return f == a && o[0] == 0 && Q
            ? this.result(-100 + (u ? -200 : 0), o, e)
            : d == a && O == 0
            ? this.ret(-200 - e.length + (m == e.length ? 0 : -100), [0, m])
            : l > -1
            ? this.ret(-700 - e.length, [l, l + this.pattern.length])
            : d == a
            ? this.ret(-900 - e.length, [O, m])
            : f == a
            ? this.result(-100 + (u ? -200 : 0) + -700 + (Q ? 0 : -1100), o, e)
            : t.length == 2
            ? null
            : this.result((r[0] ? -700 : 0) + -200 + -1100, r, e);
        }
        result(e, t, i) {
          let r = [],
            s = 0;
          for (let o of t) {
            let l = o + (this.astral ? Je(be(i, o)) : 1);
            s && r[s - 1] == o ? (r[s - 1] = l) : ((r[s++] = o), (r[s++] = l));
          }
          return this.ret(e - i.length, r);
        }
      }
      class kQ {
        constructor(e) {
          (this.pattern = e),
            (this.matched = []),
            (this.score = 0),
            (this.folded = e.toLowerCase());
        }
        match(e) {
          if (e.length < this.pattern.length) return null;
          let t = e.slice(0, this.pattern.length),
            i =
              t == this.pattern
                ? 0
                : t.toLowerCase() == this.folded
                ? -200
                : null;
          return i == null
            ? null
            : ((this.matched = [0, t.length]),
              (this.score = i + (e.length == this.pattern.length ? 0 : -100)),
              this);
        }
      }
      const se = C.define({
        combine(n) {
          return lt(
            n,
            {
              activateOnTyping: !0,
              activateOnCompletion: () => !1,
              activateOnTypingDelay: 100,
              selectOnOpen: !0,
              override: null,
              closeOnBlur: !0,
              maxRenderedOptions: 100,
              defaultKeymap: !0,
              tooltipClass: () => "",
              optionClass: () => "",
              aboveCursor: !1,
              icons: !0,
              addToOptions: [],
              positionInfo: $Q,
              filterStrict: !1,
              compareCompletions: (e, t) => e.label.localeCompare(t.label),
              interactionDelay: 75,
              updateSyncTime: 100,
            },
            {
              defaultKeymap: (e, t) => e && t,
              closeOnBlur: (e, t) => e && t,
              icons: (e, t) => e && t,
              tooltipClass: (e, t) => (i) => eh(e(i), t(i)),
              optionClass: (e, t) => (i) => eh(e(i), t(i)),
              addToOptions: (e, t) => e.concat(t),
              filterStrict: (e, t) => e || t,
            }
          );
        },
      });
      function eh(n, e) {
        return n ? (e ? n + " " + e : n) : e;
      }
      function $Q(n, e, t, i, r, s) {
        let o = n.textDirection == F.RTL,
          l = o,
          a = !1,
          h = "top",
          c,
          f,
          u = e.left - r.left,
          d = r.right - e.right,
          O = i.right - i.left,
          m = i.bottom - i.top;
        if (
          (l && u < Math.min(O, d)
            ? (l = !1)
            : !l && d < Math.min(O, u) && (l = !0),
          O <= (l ? u : d))
        )
          (c = Math.max(r.top, Math.min(t.top, r.bottom - m)) - e.top),
            (f = Math.min(400, l ? u : d));
        else {
          (a = !0), (f = Math.min(400, (o ? e.right : r.right - e.left) - 30));
          let y = r.bottom - e.bottom;
          y >= m || y > e.top
            ? (c = t.bottom - e.top)
            : ((h = "bottom"), (c = e.bottom - t.top));
        }
        let g = (e.bottom - e.top) / s.offsetHeight,
          Q = (e.right - e.left) / s.offsetWidth;
        return {
          style: `${h}: ${c / g}px; max-width: ${f / Q}px`,
          class:
            "cm-completionInfo-" +
            (a ? (o ? "left-narrow" : "right-narrow") : l ? "left" : "right"),
        };
      }
      function PQ(n) {
        let e = n.addToOptions.slice();
        return (
          n.icons &&
            e.push({
              render(t) {
                let i = document.createElement("div");
                return (
                  i.classList.add("cm-completionIcon"),
                  t.type &&
                    i.classList.add(
                      ...t.type
                        .split(/\s+/g)
                        .map((r) => "cm-completionIcon-" + r)
                    ),
                  i.setAttribute("aria-hidden", "true"),
                  i
                );
              },
              position: 20,
            }),
          e.push(
            {
              render(t, i, r, s) {
                let o = document.createElement("span");
                o.className = "cm-completionLabel";
                let l = t.displayLabel || t.label,
                  a = 0;
                for (let h = 0; h < s.length; ) {
                  let c = s[h++],
                    f = s[h++];
                  c > a &&
                    o.appendChild(document.createTextNode(l.slice(a, c)));
                  let u = o.appendChild(document.createElement("span"));
                  u.appendChild(document.createTextNode(l.slice(c, f))),
                    (u.className = "cm-completionMatchedText"),
                    (a = f);
                }
                return (
                  a < l.length &&
                    o.appendChild(document.createTextNode(l.slice(a))),
                  o
                );
              },
              position: 50,
            },
            {
              render(t) {
                if (!t.detail) return null;
                let i = document.createElement("span");
                return (
                  (i.className = "cm-completionDetail"),
                  (i.textContent = t.detail),
                  i
                );
              },
              position: 80,
            }
          ),
          e.sort((t, i) => t.position - i.position).map((t) => t.render)
        );
      }
      function ps(n, e, t) {
        if (n <= t) return { from: 0, to: n };
        if ((e < 0 && (e = 0), e <= n >> 1)) {
          let r = Math.floor(e / t);
          return { from: r * t, to: (r + 1) * t };
        }
        let i = Math.floor((n - e) / t);
        return { from: n - (i + 1) * t, to: n - i * t };
      }
      class vQ {
        constructor(e, t, i) {
          (this.view = e),
            (this.stateField = t),
            (this.applyCompletion = i),
            (this.info = null),
            (this.infoDestroy = null),
            (this.placeInfoReq = {
              read: () => this.measureInfo(),
              write: (a) => this.placeInfo(a),
              key: this,
            }),
            (this.space = null),
            (this.currentClass = "");
          let r = e.state.field(t),
            { options: s, selected: o } = r.open,
            l = e.state.facet(se);
          (this.optionContent = PQ(l)),
            (this.optionClass = l.optionClass),
            (this.tooltipClass = l.tooltipClass),
            (this.range = ps(s.length, o, l.maxRenderedOptions)),
            (this.dom = document.createElement("div")),
            (this.dom.className = "cm-tooltip-autocomplete"),
            this.updateTooltipClass(e.state),
            this.dom.addEventListener("mousedown", (a) => {
              let { options: h } = e.state.field(t).open;
              for (let c = a.target, f; c && c != this.dom; c = c.parentNode)
                if (
                  c.nodeName == "LI" &&
                  (f = /-(\d+)$/.exec(c.id)) &&
                  +f[1] < h.length
                ) {
                  this.applyCompletion(e, h[+f[1]]), a.preventDefault();
                  return;
                }
            }),
            this.dom.addEventListener("focusout", (a) => {
              let h = e.state.field(this.stateField, !1);
              h &&
                h.tooltip &&
                e.state.facet(se).closeOnBlur &&
                a.relatedTarget != e.contentDOM &&
                e.dispatch({ effects: Ji.of(null) });
            }),
            this.showOptions(s, r.id);
        }
        mount() {
          this.updateSel();
        }
        showOptions(e, t) {
          this.list && this.list.remove(),
            (this.list = this.dom.appendChild(
              this.createListBox(e, t, this.range)
            )),
            this.list.addEventListener("scroll", () => {
              this.info && this.view.requestMeasure(this.placeInfoReq);
            });
        }
        update(e) {
          var t;
          let i = e.state.field(this.stateField),
            r = e.startState.field(this.stateField);
          if ((this.updateTooltipClass(e.state), i != r)) {
            let { options: s, selected: o, disabled: l } = i.open;
            (!r.open || r.open.options != s) &&
              ((this.range = ps(
                s.length,
                o,
                e.state.facet(se).maxRenderedOptions
              )),
              this.showOptions(s, i.id)),
              this.updateSel(),
              l !=
                ((t = r.open) === null || t === void 0 ? void 0 : t.disabled) &&
                this.dom.classList.toggle(
                  "cm-tooltip-autocomplete-disabled",
                  !!l
                );
          }
        }
        updateTooltipClass(e) {
          let t = this.tooltipClass(e);
          if (t != this.currentClass) {
            for (let i of this.currentClass.split(" "))
              i && this.dom.classList.remove(i);
            for (let i of t.split(" ")) i && this.dom.classList.add(i);
            this.currentClass = t;
          }
        }
        positioned(e) {
          (this.space = e),
            this.info && this.view.requestMeasure(this.placeInfoReq);
        }
        updateSel() {
          let e = this.view.state.field(this.stateField),
            t = e.open;
          if (
            (((t.selected > -1 && t.selected < this.range.from) ||
              t.selected >= this.range.to) &&
              ((this.range = ps(
                t.options.length,
                t.selected,
                this.view.state.facet(se).maxRenderedOptions
              )),
              this.showOptions(t.options, e.id)),
            this.updateSelectedOption(t.selected))
          ) {
            this.destroyInfo();
            let { completion: i } = t.options[t.selected],
              { info: r } = i;
            if (!r) return;
            let s = typeof r == "string" ? document.createTextNode(r) : r(i);
            if (!s) return;
            "then" in s
              ? s
                  .then((o) => {
                    o &&
                      this.view.state.field(this.stateField, !1) == e &&
                      this.addInfoPane(o, i);
                  })
                  .catch((o) => ke(this.view.state, o, "completion info"))
              : this.addInfoPane(s, i);
          }
        }
        addInfoPane(e, t) {
          this.destroyInfo();
          let i = (this.info = document.createElement("div"));
          if (
            ((i.className = "cm-tooltip cm-completionInfo"), e.nodeType != null)
          )
            i.appendChild(e), (this.infoDestroy = null);
          else {
            let { dom: r, destroy: s } = e;
            i.appendChild(r), (this.infoDestroy = s || null);
          }
          this.dom.appendChild(i), this.view.requestMeasure(this.placeInfoReq);
        }
        updateSelectedOption(e) {
          let t = null;
          for (
            let i = this.list.firstChild, r = this.range.from;
            i;
            i = i.nextSibling, r++
          )
            i.nodeName != "LI" || !i.id
              ? r--
              : r == e
              ? i.hasAttribute("aria-selected") ||
                (i.setAttribute("aria-selected", "true"), (t = i))
              : i.hasAttribute("aria-selected") &&
                i.removeAttribute("aria-selected");
          return t && CQ(this.list, t), t;
        }
        measureInfo() {
          let e = this.dom.querySelector("[aria-selected]");
          if (!e || !this.info) return null;
          let t = this.dom.getBoundingClientRect(),
            i = this.info.getBoundingClientRect(),
            r = e.getBoundingClientRect(),
            s = this.space;
          if (!s) {
            let o = this.dom.ownerDocument.documentElement;
            s = {
              left: 0,
              top: 0,
              right: o.clientWidth,
              bottom: o.clientHeight,
            };
          }
          return r.top > Math.min(s.bottom, t.bottom) - 10 ||
            r.bottom < Math.max(s.top, t.top) + 10
            ? null
            : this.view.state
                .facet(se)
                .positionInfo(this.view, t, r, i, s, this.dom);
        }
        placeInfo(e) {
          this.info &&
            (e
              ? (e.style && (this.info.style.cssText = e.style),
                (this.info.className =
                  "cm-tooltip cm-completionInfo " + (e.class || "")))
              : (this.info.style.cssText = "top: -1e6px"));
        }
        createListBox(e, t, i) {
          const r = document.createElement("ul");
          (r.id = t),
            r.setAttribute("role", "listbox"),
            r.setAttribute("aria-expanded", "true"),
            r.setAttribute("aria-label", this.view.state.phrase("Completions")),
            r.addEventListener("mousedown", (o) => {
              o.target == r && o.preventDefault();
            });
          let s = null;
          for (let o = i.from; o < i.to; o++) {
            let { completion: l, match: a } = e[o],
              { section: h } = l;
            if (h) {
              let u = typeof h == "string" ? h : h.name;
              if (u != s && (o > i.from || i.from == 0))
                if (((s = u), typeof h != "string" && h.header))
                  r.appendChild(h.header(h));
                else {
                  let d = r.appendChild(
                    document.createElement("completion-section")
                  );
                  d.textContent = u;
                }
            }
            const c = r.appendChild(document.createElement("li"));
            (c.id = t + "-" + o), c.setAttribute("role", "option");
            let f = this.optionClass(l);
            f && (c.className = f);
            for (let u of this.optionContent) {
              let d = u(l, this.view.state, this.view, a);
              d && c.appendChild(d);
            }
          }
          return (
            i.from && r.classList.add("cm-completionListIncompleteTop"),
            i.to < e.length &&
              r.classList.add("cm-completionListIncompleteBottom"),
            r
          );
        }
        destroyInfo() {
          this.info &&
            (this.infoDestroy && this.infoDestroy(),
            this.info.remove(),
            (this.info = null));
        }
        destroy() {
          this.destroyInfo();
        }
      }
      function TQ(n, e) {
        return (t) => new vQ(t, n, e);
      }
      function CQ(n, e) {
        let t = n.getBoundingClientRect(),
          i = e.getBoundingClientRect(),
          r = t.height / n.offsetHeight;
        i.top < t.top
          ? (n.scrollTop -= (t.top - i.top) / r)
          : i.bottom > t.bottom && (n.scrollTop += (i.bottom - t.bottom) / r);
      }
      function th(n) {
        return (
          (n.boost || 0) * 100 +
          (n.apply ? 10 : 0) +
          (n.info ? 5 : 0) +
          (n.type ? 1 : 0)
        );
      }
      function ZQ(n, e) {
        let t = [],
          i = null,
          r = (h) => {
            t.push(h);
            let { section: c } = h.completion;
            if (c) {
              i || (i = []);
              let f = typeof c == "string" ? c : c.name;
              i.some((u) => u.name == f) ||
                i.push(typeof c == "string" ? { name: f } : c);
            }
          },
          s = e.facet(se);
        for (let h of n)
          if (h.hasResult()) {
            let c = h.result.getMatch;
            if (h.result.filter === !1)
              for (let f of h.result.options)
                r(new Ka(f, h.source, c ? c(f) : [], 1e9 - t.length));
            else {
              let f = e.sliceDoc(h.from, h.to),
                u,
                d = s.filterStrict ? new kQ(f) : new wQ(f);
              for (let O of h.result.options)
                if ((u = d.match(O.label))) {
                  let m = O.displayLabel
                    ? c
                      ? c(O, u.matched)
                      : []
                    : u.matched;
                  r(new Ka(O, h.source, m, u.score + (O.boost || 0)));
                }
            }
          }
        if (i) {
          let h = Object.create(null),
            c = 0,
            f = (u, d) => {
              var O, m;
              return (
                ((O = u.rank) !== null && O !== void 0 ? O : 1e9) -
                  ((m = d.rank) !== null && m !== void 0 ? m : 1e9) ||
                (u.name < d.name ? -1 : 1)
              );
            };
          for (let u of i.sort(f)) (c -= 1e5), (h[u.name] = c);
          for (let u of t) {
            let { section: d } = u.completion;
            d && (u.score += h[typeof d == "string" ? d : d.name]);
          }
        }
        let o = [],
          l = null,
          a = s.compareCompletions;
        for (let h of t.sort(
          (c, f) => f.score - c.score || a(c.completion, f.completion)
        )) {
          let c = h.completion;
          !l ||
          l.label != c.label ||
          l.detail != c.detail ||
          (l.type != null && c.type != null && l.type != c.type) ||
          l.apply != c.apply ||
          l.boost != c.boost
            ? o.push(h)
            : th(h.completion) > th(l) && (o[o.length - 1] = h),
            (l = h.completion);
        }
        return o;
      }
      class Jt {
        constructor(e, t, i, r, s, o) {
          (this.options = e),
            (this.attrs = t),
            (this.tooltip = i),
            (this.timestamp = r),
            (this.selected = s),
            (this.disabled = o);
        }
        setSelected(e, t) {
          return e == this.selected || e >= this.options.length
            ? this
            : new Jt(
                this.options,
                ih(t, e),
                this.tooltip,
                this.timestamp,
                e,
                this.disabled
              );
        }
        static build(e, t, i, r, s, o) {
          if (r && !o && e.some((h) => h.isPending)) return r.setDisabled();
          let l = ZQ(e, t);
          if (!l.length)
            return r && e.some((h) => h.isPending) ? r.setDisabled() : null;
          let a = t.facet(se).selectOnOpen ? 0 : -1;
          if (r && r.selected != a && r.selected != -1) {
            let h = r.options[r.selected].completion;
            for (let c = 0; c < l.length; c++)
              if (l[c].completion == h) {
                a = c;
                break;
              }
          }
          return new Jt(
            l,
            ih(i, a),
            {
              pos: e.reduce(
                (h, c) => (c.hasResult() ? Math.min(h, c.from) : h),
                1e8
              ),
              create: zQ,
              above: s.aboveCursor,
            },
            r ? r.timestamp : Date.now(),
            a,
            !1
          );
        }
        map(e) {
          return new Jt(
            this.options,
            this.attrs,
            { ...this.tooltip, pos: e.mapPos(this.tooltip.pos) },
            this.timestamp,
            this.selected,
            this.disabled
          );
        }
        setDisabled() {
          return new Jt(
            this.options,
            this.attrs,
            this.tooltip,
            this.timestamp,
            this.selected,
            !0
          );
        }
      }
      class br {
        constructor(e, t, i) {
          (this.active = e), (this.id = t), (this.open = i);
        }
        static start() {
          return new br(
            MQ,
            "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36),
            null
          );
        }
        update(e) {
          let { state: t } = e,
            i = t.facet(se),
            s = (
              i.override || t.languageDataAt("autocomplete", Vt(t)).map(xQ)
            ).map((a) =>
              (
                this.active.find((c) => c.source == a) ||
                new Ee(a, this.active.some((c) => c.state != 0) ? 1 : 0)
              ).update(e, i)
            );
          s.length == this.active.length &&
            s.every((a, h) => a == this.active[h]) &&
            (s = this.active);
          let o = this.open,
            l = e.effects.some((a) => a.is(ol));
          o && e.docChanged && (o = o.map(e.changes)),
            e.selection ||
            s.some(
              (a) => a.hasResult() && e.changes.touchesRange(a.from, a.to)
            ) ||
            !AQ(s, this.active) ||
            l
              ? (o = Jt.build(s, t, this.id, o, i, l))
              : o && o.disabled && !s.some((a) => a.isPending) && (o = null),
            !o &&
              s.every((a) => !a.isPending) &&
              s.some((a) => a.hasResult()) &&
              (s = s.map((a) => (a.hasResult() ? new Ee(a.source, 0) : a)));
          for (let a of e.effects)
            a.is(Zu) && (o = o && o.setSelected(a.value, this.id));
          return s == this.active && o == this.open
            ? this
            : new br(s, this.id, o);
        }
        get tooltip() {
          return this.open ? this.open.tooltip : null;
        }
        get attrs() {
          return this.open ? this.open.attrs : this.active.length ? XQ : RQ;
        }
      }
      function AQ(n, e) {
        if (n == e) return !0;
        for (let t = 0, i = 0; ; ) {
          for (; t < n.length && !n[t].hasResult(); ) t++;
          for (; i < e.length && !e[i].hasResult(); ) i++;
          let r = t == n.length,
            s = i == e.length;
          if (r || s) return r == s;
          if (n[t++].result != e[i++].result) return !1;
        }
      }
      const XQ = { "aria-autocomplete": "list" },
        RQ = {};
      function ih(n, e) {
        let t = {
          "aria-autocomplete": "list",
          "aria-haspopup": "listbox",
          "aria-controls": n,
        };
        return e > -1 && (t["aria-activedescendant"] = n + "-" + e), t;
      }
      const MQ = [];
      function Cu(n, e) {
        if (n.isUserEvent("input.complete")) {
          let i = n.annotation(sl);
          if (i && e.activateOnCompletion(i)) return 12;
        }
        let t = n.isUserEvent("input.type");
        return t && e.activateOnTyping
          ? 5
          : t
          ? 1
          : n.isUserEvent("delete.backward")
          ? 2
          : n.selection
          ? 8
          : n.docChanged
          ? 16
          : 0;
      }
      class Ee {
        constructor(e, t, i = !1) {
          (this.source = e), (this.state = t), (this.explicit = i);
        }
        hasResult() {
          return !1;
        }
        get isPending() {
          return this.state == 1;
        }
        update(e, t) {
          let i = Cu(e, t),
            r = this;
          (i & 8 || (i & 16 && this.touches(e))) && (r = new Ee(r.source, 0)),
            i & 4 && r.state == 0 && (r = new Ee(this.source, 1)),
            (r = r.updateFor(e, i));
          for (let s of e.effects)
            if (s.is(yr)) r = new Ee(r.source, 1, s.value);
            else if (s.is(Ji)) r = new Ee(r.source, 0);
            else if (s.is(ol))
              for (let o of s.value) o.source == r.source && (r = o);
          return r;
        }
        updateFor(e, t) {
          return this.map(e.changes);
        }
        map(e) {
          return this;
        }
        touches(e) {
          return e.changes.touchesRange(Vt(e.state));
        }
      }
      class ri extends Ee {
        constructor(e, t, i, r, s, o) {
          super(e, 3, t),
            (this.limit = i),
            (this.result = r),
            (this.from = s),
            (this.to = o);
        }
        hasResult() {
          return !0;
        }
        updateFor(e, t) {
          var i;
          if (!(t & 3)) return this.map(e.changes);
          let r = this.result;
          r.map && !e.changes.empty && (r = r.map(r, e.changes));
          let s = e.changes.mapPos(this.from),
            o = e.changes.mapPos(this.to, 1),
            l = Vt(e.state);
          if (
            l > o ||
            !r ||
            (t & 2 && (Vt(e.startState) == this.from || l < this.limit))
          )
            return new Ee(this.source, t & 4 ? 1 : 0);
          let a = e.changes.mapPos(this.limit);
          return YQ(r.validFor, e.state, s, o)
            ? new ri(this.source, this.explicit, a, r, s, o)
            : r.update && (r = r.update(r, s, o, new Pu(e.state, l, !1)))
            ? new ri(
                this.source,
                this.explicit,
                a,
                r,
                r.from,
                (i = r.to) !== null && i !== void 0 ? i : Vt(e.state)
              )
            : new Ee(this.source, 1, this.explicit);
        }
        map(e) {
          return e.empty
            ? this
            : (this.result.map ? this.result.map(this.result, e) : this.result)
            ? new ri(
                this.source,
                this.explicit,
                e.mapPos(this.limit),
                this.result,
                e.mapPos(this.from),
                e.mapPos(this.to, 1)
              )
            : new Ee(this.source, 0);
        }
        touches(e) {
          return e.changes.touchesRange(this.from, this.to);
        }
      }
      function YQ(n, e, t, i) {
        if (!n) return !1;
        let r = e.sliceDoc(t, i);
        return typeof n == "function" ? n(r, t, i, e) : Tu(n, !0).test(r);
      }
      const ol = R.define({
          map(n, e) {
            return n.map((t) => t.map(e));
          },
        }),
        Zu = R.define(),
        we = oe.define({
          create() {
            return br.start();
          },
          update(n, e) {
            return n.update(e);
          },
          provide: (n) => [
            Lo.from(n, (e) => e.tooltip),
            v.contentAttributes.from(n, (e) => e.attrs),
          ],
        });
      function ll(n, e) {
        const t = e.completion.apply || e.completion.label;
        let i = n.state.field(we).active.find((r) => r.source == e.source);
        return i instanceof ri
          ? (typeof t == "string"
              ? n.dispatch({
                  ...bQ(n.state, t, i.from, i.to),
                  annotations: sl.of(e.completion),
                })
              : t(n, e.completion, i.from, i.to),
            !0)
          : !1;
      }
      const zQ = TQ(we, ll);
      function zn(n, e = "option") {
        return (t) => {
          let i = t.state.field(we, !1);
          if (
            !i ||
            !i.open ||
            i.open.disabled ||
            Date.now() - i.open.timestamp < t.state.facet(se).interactionDelay
          )
            return !1;
          let r = 1,
            s;
          e == "page" &&
            (s = ff(t, i.open.tooltip)) &&
            (r = Math.max(
              2,
              Math.floor(
                s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight
              ) - 1
            ));
          let { length: o } = i.open.options,
            l =
              i.open.selected > -1
                ? i.open.selected + r * (n ? 1 : -1)
                : n
                ? 0
                : o - 1;
          return (
            l < 0
              ? (l = e == "page" ? 0 : o - 1)
              : l >= o && (l = e == "page" ? o - 1 : 0),
            t.dispatch({ effects: Zu.of(l) }),
            !0
          );
        };
      }
      const DQ = (n) => {
          let e = n.state.field(we, !1);
          return n.state.readOnly ||
            !e ||
            !e.open ||
            e.open.selected < 0 ||
            e.open.disabled ||
            Date.now() - e.open.timestamp < n.state.facet(se).interactionDelay
            ? !1
            : ll(n, e.open.options[e.open.selected]);
        },
        ms = (n) =>
          n.state.field(we, !1) ? (n.dispatch({ effects: yr.of(!0) }), !0) : !1,
        EQ = (n) => {
          let e = n.state.field(we, !1);
          return !e || !e.active.some((t) => t.state != 0)
            ? !1
            : (n.dispatch({ effects: Ji.of(null) }), !0);
        };
      class _Q {
        constructor(e, t) {
          (this.active = e),
            (this.context = t),
            (this.time = Date.now()),
            (this.updates = []),
            (this.done = void 0);
        }
      }
      const VQ = 50,
        qQ = 1e3,
        WQ = ne.fromClass(
          class {
            constructor(n) {
              (this.view = n),
                (this.debounceUpdate = -1),
                (this.running = []),
                (this.debounceAccept = -1),
                (this.pendingStart = !1),
                (this.composing = 0);
              for (let e of n.state.field(we).active)
                e.isPending && this.startQuery(e);
            }
            update(n) {
              let e = n.state.field(we),
                t = n.state.facet(se);
              if (
                !n.selectionSet &&
                !n.docChanged &&
                n.startState.field(we) == e
              )
                return;
              let i = n.transactions.some((s) => {
                let o = Cu(s, t);
                return o & 8 || ((s.selection || s.docChanged) && !(o & 3));
              });
              for (let s = 0; s < this.running.length; s++) {
                let o = this.running[s];
                if (
                  i ||
                  (o.context.abortOnDocChange && n.docChanged) ||
                  (o.updates.length + n.transactions.length > VQ &&
                    Date.now() - o.time > qQ)
                ) {
                  for (let l of o.context.abortListeners)
                    try {
                      l();
                    } catch (a) {
                      ke(this.view.state, a);
                    }
                  (o.context.abortListeners = null),
                    this.running.splice(s--, 1);
                } else o.updates.push(...n.transactions);
              }
              this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate),
                n.transactions.some((s) => s.effects.some((o) => o.is(yr))) &&
                  (this.pendingStart = !0);
              let r = this.pendingStart ? 50 : t.activateOnTypingDelay;
              if (
                ((this.debounceUpdate = e.active.some(
                  (s) =>
                    s.isPending &&
                    !this.running.some((o) => o.active.source == s.source)
                )
                  ? setTimeout(() => this.startUpdate(), r)
                  : -1),
                this.composing != 0)
              )
                for (let s of n.transactions)
                  s.isUserEvent("input.type")
                    ? (this.composing = 2)
                    : this.composing == 2 &&
                      s.selection &&
                      (this.composing = 3);
            }
            startUpdate() {
              (this.debounceUpdate = -1), (this.pendingStart = !1);
              let { state: n } = this.view,
                e = n.field(we);
              for (let t of e.active)
                t.isPending &&
                  !this.running.some((i) => i.active.source == t.source) &&
                  this.startQuery(t);
              this.running.length &&
                e.open &&
                e.open.disabled &&
                (this.debounceAccept = setTimeout(
                  () => this.accept(),
                  this.view.state.facet(se).updateSyncTime
                ));
            }
            startQuery(n) {
              let { state: e } = this.view,
                t = Vt(e),
                i = new Pu(e, t, n.explicit, this.view),
                r = new _Q(n, i);
              this.running.push(r),
                Promise.resolve(n.source(i)).then(
                  (s) => {
                    r.context.aborted ||
                      ((r.done = s || null), this.scheduleAccept());
                  },
                  (s) => {
                    this.view.dispatch({ effects: Ji.of(null) }),
                      ke(this.view.state, s);
                  }
                );
            }
            scheduleAccept() {
              this.running.every((n) => n.done !== void 0)
                ? this.accept()
                : this.debounceAccept < 0 &&
                  (this.debounceAccept = setTimeout(
                    () => this.accept(),
                    this.view.state.facet(se).updateSyncTime
                  ));
            }
            accept() {
              var n;
              this.debounceAccept > -1 && clearTimeout(this.debounceAccept),
                (this.debounceAccept = -1);
              let e = [],
                t = this.view.state.facet(se),
                i = this.view.state.field(we);
              for (let r = 0; r < this.running.length; r++) {
                let s = this.running[r];
                if (s.done === void 0) continue;
                if ((this.running.splice(r--, 1), s.done)) {
                  let l = Vt(
                      s.updates.length
                        ? s.updates[0].startState
                        : this.view.state
                    ),
                    a = Math.min(l, s.done.from + (s.active.explicit ? 0 : 1)),
                    h = new ri(
                      s.active.source,
                      s.active.explicit,
                      a,
                      s.done,
                      s.done.from,
                      (n = s.done.to) !== null && n !== void 0 ? n : l
                    );
                  for (let c of s.updates) h = h.update(c, t);
                  if (h.hasResult()) {
                    e.push(h);
                    continue;
                  }
                }
                let o = i.active.find((l) => l.source == s.active.source);
                if (o && o.isPending)
                  if (s.done == null) {
                    let l = new Ee(s.active.source, 0);
                    for (let a of s.updates) l = l.update(a, t);
                    l.isPending || e.push(l);
                  } else this.startQuery(o);
              }
              (e.length || (i.open && i.open.disabled)) &&
                this.view.dispatch({ effects: ol.of(e) });
            }
          },
          {
            eventHandlers: {
              blur(n) {
                let e = this.view.state.field(we, !1);
                if (e && e.tooltip && this.view.state.facet(se).closeOnBlur) {
                  let t = e.open && ff(this.view, e.open.tooltip);
                  (!t || !t.dom.contains(n.relatedTarget)) &&
                    setTimeout(
                      () => this.view.dispatch({ effects: Ji.of(null) }),
                      10
                    );
                }
              },
              compositionstart() {
                this.composing = 1;
              },
              compositionend() {
                this.composing == 3 &&
                  setTimeout(
                    () => this.view.dispatch({ effects: yr.of(!1) }),
                    20
                  ),
                  (this.composing = 0);
              },
            },
          }
        ),
        LQ = typeof navigator == "object" && /Win/.test(navigator.platform),
        jQ = Xt.highest(
          v.domEventHandlers({
            keydown(n, e) {
              let t = e.state.field(we, !1);
              if (
                !t ||
                !t.open ||
                t.open.disabled ||
                t.open.selected < 0 ||
                n.key.length > 1 ||
                (n.ctrlKey && !(LQ && n.altKey)) ||
                n.metaKey
              )
                return !1;
              let i = t.open.options[t.open.selected],
                r = t.active.find((o) => o.source == i.source),
                s = i.completion.commitCharacters || r.result.commitCharacters;
              return s && s.indexOf(n.key) > -1 && ll(e, i), !1;
            },
          })
        ),
        Au = v.baseTheme({
          ".cm-tooltip.cm-tooltip-autocomplete": {
            "& > ul": {
              fontFamily: "monospace",
              whiteSpace: "nowrap",
              overflow: "hidden auto",
              maxWidth_fallback: "700px",
              maxWidth: "min(700px, 95vw)",
              minWidth: "250px",
              maxHeight: "10em",
              height: "100%",
              listStyle: "none",
              margin: 0,
              padding: 0,
              "& > li, & > completion-section": {
                padding: "1px 3px",
                lineHeight: 1.2,
              },
              "& > li": {
                overflowX: "hidden",
                textOverflow: "ellipsis",
                cursor: "pointer",
              },
              "& > completion-section": {
                display: "list-item",
                borderBottom: "1px solid silver",
                paddingLeft: "0.5em",
                opacity: 0.7,
              },
            },
          },
          "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
            background: "#17c",
            color: "white",
          },
          "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
            background: "#777",
          },
          "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
            background: "#347",
            color: "white",
          },
          "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
            background: "#444",
          },
          ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after":
            {
              content: '""',
              opacity: 0.5,
              display: "block",
              textAlign: "center",
            },
          ".cm-tooltip.cm-completionInfo": {
            position: "absolute",
            padding: "3px 9px",
            width: "max-content",
            maxWidth: "400px",
            boxSizing: "border-box",
            whiteSpace: "pre-line",
          },
          ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
          ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
          ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
          ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
          "&light .cm-snippetField": { backgroundColor: "#00000022" },
          "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
          ".cm-snippetFieldPosition": {
            verticalAlign: "text-top",
            width: 0,
            height: "1.15em",
            display: "inline-block",
            margin: "0 -0.7px -.7em",
            borderLeft: "1.4px dotted #888",
          },
          ".cm-completionMatchedText": { textDecoration: "underline" },
          ".cm-completionDetail": { marginLeft: "0.5em", fontStyle: "italic" },
          ".cm-completionIcon": {
            fontSize: "90%",
            width: ".8em",
            display: "inline-block",
            textAlign: "center",
            paddingRight: ".6em",
            opacity: "0.6",
            boxSizing: "content-box",
          },
          ".cm-completionIcon-function, .cm-completionIcon-method": {
            "&:after": { content: "''" },
          },
          ".cm-completionIcon-class": { "&:after": { content: "''" } },
          ".cm-completionIcon-interface": { "&:after": { content: "''" } },
          ".cm-completionIcon-variable": { "&:after": { content: "''" } },
          ".cm-completionIcon-constant": { "&:after": { content: "''" } },
          ".cm-completionIcon-type": { "&:after": { content: "''" } },
          ".cm-completionIcon-enum": { "&:after": { content: "''" } },
          ".cm-completionIcon-property": { "&:after": { content: "''" } },
          ".cm-completionIcon-keyword": { "&:after": { content: "''" } },
          ".cm-completionIcon-namespace": { "&:after": { content: "''" } },
          ".cm-completionIcon-text": {
            "&:after": {
              content: "'abc'",
              fontSize: "50%",
              verticalAlign: "middle",
            },
          },
        });
      class BQ {
        constructor(e, t, i, r) {
          (this.field = e), (this.line = t), (this.from = i), (this.to = r);
        }
      }
      class al {
        constructor(e, t, i) {
          (this.field = e), (this.from = t), (this.to = i);
        }
        map(e) {
          let t = e.mapPos(this.from, -1, ce.TrackDel),
            i = e.mapPos(this.to, 1, ce.TrackDel);
          return t == null || i == null ? null : new al(this.field, t, i);
        }
      }
      class hl {
        constructor(e, t) {
          (this.lines = e), (this.fieldPositions = t);
        }
        instantiate(e, t) {
          let i = [],
            r = [t],
            s = e.doc.lineAt(t),
            o = /^\s*/.exec(s.text)[0];
          for (let a of this.lines) {
            if (i.length) {
              let h = o,
                c = /^\t*/.exec(a)[0].length;
              for (let f = 0; f < c; f++) h += e.facet(Dr);
              r.push(t + h.length - c), (a = h + a.slice(c));
            }
            i.push(a), (t += a.length + 1);
          }
          let l = this.fieldPositions.map(
            (a) => new al(a.field, r[a.line] + a.from, r[a.line] + a.to)
          );
          return { text: i, ranges: l };
        }
        static parse(e) {
          let t = [],
            i = [],
            r = [],
            s;
          for (let o of e.split(/\r\n?|\n/)) {
            for (
              ;
              (s = /[#$]\{(?:(\d+)(?::([^{}]*))?|((?:\\[{}]|[^{}])*))\}/.exec(
                o
              ));

            ) {
              let l = s[1] ? +s[1] : null,
                a = s[2] || s[3] || "",
                h = -1,
                c = a.replace(/\\[{}]/g, (f) => f[1]);
              for (let f = 0; f < t.length; f++)
                (l != null ? t[f].seq == l : c && t[f].name == c) && (h = f);
              if (h < 0) {
                let f = 0;
                for (
                  ;
                  f < t.length &&
                  (l == null || (t[f].seq != null && t[f].seq < l));

                )
                  f++;
                t.splice(f, 0, { seq: l, name: c }), (h = f);
                for (let u of r) u.field >= h && u.field++;
              }
              for (let f of r)
                if (f.line == i.length && f.from > s.index) {
                  let u = s[2] ? 3 + (s[1] || "").length : 2;
                  (f.from -= u), (f.to -= u);
                }
              r.push(new BQ(h, i.length, s.index, s.index + c.length)),
                (o = o.slice(0, s.index) + a + o.slice(s.index + s[0].length));
            }
            (o = o.replace(/\\([{}])/g, (l, a, h) => {
              for (let c of r)
                c.line == i.length && c.from > h && (c.from--, c.to--);
              return a;
            })),
              i.push(o);
          }
          return new hl(i, r);
        }
      }
      let IQ = A.widget({
          widget: new (class extends St {
            toDOM() {
              let n = document.createElement("span");
              return (n.className = "cm-snippetFieldPosition"), n;
            }
            ignoreEvent() {
              return !1;
            }
          })(),
        }),
        GQ = A.mark({ class: "cm-snippetField" });
      class yi {
        constructor(e, t) {
          (this.ranges = e),
            (this.active = t),
            (this.deco = A.set(
              e.map((i) => (i.from == i.to ? IQ : GQ).range(i.from, i.to)),
              !0
            ));
        }
        map(e) {
          let t = [];
          for (let i of this.ranges) {
            let r = i.map(e);
            if (!r) return null;
            t.push(r);
          }
          return new yi(t, this.active);
        }
        selectionInsideField(e) {
          return e.ranges.every((t) =>
            this.ranges.some(
              (i) => i.field == this.active && i.from <= t.from && i.to >= t.to
            )
          );
        }
      }
      const dn = R.define({
          map(n, e) {
            return n && n.map(e);
          },
        }),
        NQ = R.define(),
        en = oe.define({
          create() {
            return null;
          },
          update(n, e) {
            for (let t of e.effects) {
              if (t.is(dn)) return t.value;
              if (t.is(NQ) && n) return new yi(n.ranges, t.value);
            }
            return (
              n && e.docChanged && (n = n.map(e.changes)),
              n &&
                e.selection &&
                !n.selectionInsideField(e.selection) &&
                (n = null),
              n
            );
          },
          provide: (n) => v.decorations.from(n, (e) => (e ? e.deco : A.none)),
        });
      function cl(n, e) {
        return S.create(
          n.filter((t) => t.field == e).map((t) => S.range(t.from, t.to))
        );
      }
      function UQ(n) {
        let e = hl.parse(n);
        return (t, i, r, s) => {
          let { text: o, ranges: l } = e.instantiate(t.state, r),
            { main: a } = t.state.selection,
            h = {
              changes: { from: r, to: s == a.from ? a.to : s, insert: E.of(o) },
              scrollIntoView: !0,
              annotations: i
                ? [sl.of(i), ie.userEvent.of("input.complete")]
                : void 0,
            };
          if (
            (l.length && (h.selection = cl(l, 0)), l.some((c) => c.field > 0))
          ) {
            let c = new yi(l, 0),
              f = (h.effects = [dn.of(c)]);
            t.state.field(en, !1) === void 0 &&
              f.push(R.appendConfig.of([en, eS, tS, Au]));
          }
          t.dispatch(t.state.update(h));
        };
      }
      function Xu(n) {
        return ({ state: e, dispatch: t }) => {
          let i = e.field(en, !1);
          if (!i || (n < 0 && i.active == 0)) return !1;
          let r = i.active + n,
            s = n > 0 && !i.ranges.some((o) => o.field == r + n);
          return (
            t(
              e.update({
                selection: cl(i.ranges, r),
                effects: dn.of(s ? null : new yi(i.ranges, r)),
                scrollIntoView: !0,
              })
            ),
            !0
          );
        };
      }
      const FQ = ({ state: n, dispatch: e }) =>
          n.field(en, !1) ? (e(n.update({ effects: dn.of(null) })), !0) : !1,
        HQ = Xu(1),
        KQ = Xu(-1),
        JQ = [
          { key: "Tab", run: HQ, shift: KQ },
          { key: "Escape", run: FQ },
        ],
        nh = C.define({
          combine(n) {
            return n.length ? n[0] : JQ;
          },
        }),
        eS = Xt.highest(Mr.compute([nh], (n) => n.facet(nh)));
      function ye(n, e) {
        return { ...e, apply: UQ(n) };
      }
      const tS = v.domEventHandlers({
          mousedown(n, e) {
            let t = e.state.field(en, !1),
              i;
            if (
              !t ||
              (i = e.posAtCoords({ x: n.clientX, y: n.clientY })) == null
            )
              return !1;
            let r = t.ranges.find((s) => s.from <= i && s.to >= i);
            return !r || r.field == t.active
              ? !1
              : (e.dispatch({
                  selection: cl(t.ranges, r.field),
                  effects: dn.of(
                    t.ranges.some((s) => s.field > r.field)
                      ? new yi(t.ranges, r.field)
                      : null
                  ),
                  scrollIntoView: !0,
                }),
                !0);
          },
        }),
        tn = {
          brackets: ["(", "[", "{", "'", '"'],
          before: ")]}:;>",
          stringPrefixes: [],
        },
        _t = R.define({
          map(n, e) {
            let t = e.mapPos(n, -1, ce.TrackAfter);
            return t ?? void 0;
          },
        }),
        fl = new (class extends qt {})();
      fl.startSide = 1;
      fl.endSide = -1;
      const Ru = oe.define({
        create() {
          return V.empty;
        },
        update(n, e) {
          if (((n = n.map(e.changes)), e.selection)) {
            let t = e.state.doc.lineAt(e.selection.main.head);
            n = n.update({ filter: (i) => i >= t.from && i <= t.to });
          }
          for (let t of e.effects)
            t.is(_t) &&
              (n = n.update({ add: [fl.range(t.value, t.value + 1)] }));
          return n;
        },
      });
      function iS() {
        return [rS, Ru];
      }
      const gs = "()[]{}<>";
      function Mu(n) {
        for (let e = 0; e < gs.length; e += 2)
          if (gs.charCodeAt(e) == n) return gs.charAt(e + 1);
        return Co(n < 128 ? n : n + 1);
      }
      function Yu(n, e) {
        return n.languageDataAt("closeBrackets", e)[0] || tn;
      }
      const nS =
          typeof navigator == "object" && /Android\b/.test(navigator.userAgent),
        rS = v.inputHandler.of((n, e, t, i) => {
          if ((nS ? n.composing : n.compositionStarted) || n.state.readOnly)
            return !1;
          let r = n.state.selection.main;
          if (
            i.length > 2 ||
            (i.length == 2 && Je(be(i, 0)) == 1) ||
            e != r.from ||
            t != r.to
          )
            return !1;
          let s = lS(n.state, i);
          return s ? (n.dispatch(s), !0) : !1;
        }),
        sS = ({ state: n, dispatch: e }) => {
          if (n.readOnly) return !1;
          let i = Yu(n, n.selection.main.head).brackets || tn.brackets,
            r = null,
            s = n.changeByRange((o) => {
              if (o.empty) {
                let l = aS(n.doc, o.head);
                for (let a of i)
                  if (a == l && Ir(n.doc, o.head) == Mu(be(a, 0)))
                    return {
                      changes: {
                        from: o.head - a.length,
                        to: o.head + a.length,
                      },
                      range: S.cursor(o.head - a.length),
                    };
              }
              return { range: (r = o) };
            });
          return (
            r ||
              e(
                n.update(s, {
                  scrollIntoView: !0,
                  userEvent: "delete.backward",
                })
              ),
            !r
          );
        },
        oS = [{ key: "Backspace", run: sS }];
      function lS(n, e) {
        let t = Yu(n, n.selection.main.head),
          i = t.brackets || tn.brackets;
        for (let r of i) {
          let s = Mu(be(r, 0));
          if (e == r)
            return s == r
              ? fS(n, r, i.indexOf(r + r + r) > -1, t)
              : hS(n, r, s, t.before || tn.before);
          if (e == s && zu(n, n.selection.main.from)) return cS(n, r, s);
        }
        return null;
      }
      function zu(n, e) {
        let t = !1;
        return (
          n.field(Ru).between(0, n.doc.length, (i) => {
            i == e && (t = !0);
          }),
          t
        );
      }
      function Ir(n, e) {
        let t = n.sliceString(e, e + 2);
        return t.slice(0, Je(be(t, 0)));
      }
      function aS(n, e) {
        let t = n.sliceString(e - 2, e);
        return Je(be(t, 0)) == t.length ? t : t.slice(1);
      }
      function hS(n, e, t, i) {
        let r = null,
          s = n.changeByRange((o) => {
            if (!o.empty)
              return {
                changes: [
                  { insert: e, from: o.from },
                  { insert: t, from: o.to },
                ],
                effects: _t.of(o.to + e.length),
                range: S.range(o.anchor + e.length, o.head + e.length),
              };
            let l = Ir(n.doc, o.head);
            return !l || /\s/.test(l) || i.indexOf(l) > -1
              ? {
                  changes: { insert: e + t, from: o.head },
                  effects: _t.of(o.head + e.length),
                  range: S.cursor(o.head + e.length),
                }
              : { range: (r = o) };
          });
        return r
          ? null
          : n.update(s, { scrollIntoView: !0, userEvent: "input.type" });
      }
      function cS(n, e, t) {
        let i = null,
          r = n.changeByRange((s) =>
            s.empty && Ir(n.doc, s.head) == t
              ? {
                  changes: { from: s.head, to: s.head + t.length, insert: t },
                  range: S.cursor(s.head + t.length),
                }
              : (i = { range: s })
          );
        return i
          ? null
          : n.update(r, { scrollIntoView: !0, userEvent: "input.type" });
      }
      function fS(n, e, t, i) {
        let r = i.stringPrefixes || tn.stringPrefixes,
          s = null,
          o = n.changeByRange((l) => {
            if (!l.empty)
              return {
                changes: [
                  { insert: e, from: l.from },
                  { insert: e, from: l.to },
                ],
                effects: _t.of(l.to + e.length),
                range: S.range(l.anchor + e.length, l.head + e.length),
              };
            let a = l.head,
              h = Ir(n.doc, a),
              c;
            if (h == e) {
              if (rh(n, a))
                return {
                  changes: { insert: e + e, from: a },
                  effects: _t.of(a + e.length),
                  range: S.cursor(a + e.length),
                };
              if (zu(n, a)) {
                let u =
                  t && n.sliceDoc(a, a + e.length * 3) == e + e + e
                    ? e + e + e
                    : e;
                return {
                  changes: { from: a, to: a + u.length, insert: u },
                  range: S.cursor(a + u.length),
                };
              }
            } else {
              if (
                t &&
                n.sliceDoc(a - 2 * e.length, a) == e + e &&
                (c = sh(n, a - 2 * e.length, r)) > -1 &&
                rh(n, c)
              )
                return {
                  changes: { insert: e + e + e + e, from: a },
                  effects: _t.of(a + e.length),
                  range: S.cursor(a + e.length),
                };
              if (
                n.charCategorizer(a)(h) != H.Word &&
                sh(n, a, r) > -1 &&
                !uS(n, a, e, r)
              )
                return {
                  changes: { insert: e + e, from: a },
                  effects: _t.of(a + e.length),
                  range: S.cursor(a + e.length),
                };
            }
            return { range: (s = l) };
          });
        return s
          ? null
          : n.update(o, { scrollIntoView: !0, userEvent: "input.type" });
      }
      function rh(n, e) {
        let t = J(n).resolveInner(e + 1);
        return t.parent && t.from == e;
      }
      function uS(n, e, t, i) {
        let r = J(n).resolveInner(e, -1),
          s = i.reduce((o, l) => Math.max(o, l.length), 0);
        for (let o = 0; o < 5; o++) {
          let l = n.sliceDoc(r.from, Math.min(r.to, r.from + t.length + s)),
            a = l.indexOf(t);
          if (!a || (a > -1 && i.indexOf(l.slice(0, a)) > -1)) {
            let c = r.firstChild;
            for (; c && c.from == r.from && c.to - c.from > t.length + a; ) {
              if (n.sliceDoc(c.to - t.length, c.to) == t) return !1;
              c = c.firstChild;
            }
            return !0;
          }
          let h = r.to == e && r.parent;
          if (!h) break;
          r = h;
        }
        return !1;
      }
      function sh(n, e, t) {
        let i = n.charCategorizer(e);
        if (i(n.sliceDoc(e - 1, e)) != H.Word) return e;
        for (let r of t) {
          let s = e - r.length;
          if (n.sliceDoc(s, e) == r && i(n.sliceDoc(s - 1, s)) != H.Word)
            return s;
        }
        return -1;
      }
      function dS(n = {}) {
        return [jQ, we, se.of(n), WQ, OS, Au];
      }
      const Du = [
          { key: "Ctrl-Space", run: ms },
          { mac: "Alt-`", run: ms },
          { mac: "Alt-i", run: ms },
          { key: "Escape", run: EQ },
          { key: "ArrowDown", run: zn(!0) },
          { key: "ArrowUp", run: zn(!1) },
          { key: "PageDown", run: zn(!0, "page") },
          { key: "PageUp", run: zn(!1, "page") },
          { key: "Enter", run: DQ },
        ],
        OS = Xt.highest(
          Mr.computeN([se], (n) => (n.facet(se).defaultKeymap ? [Du] : []))
        );
      class oh {
        constructor(e, t, i) {
          (this.from = e), (this.to = t), (this.diagnostic = i);
        }
      }
      class Dt {
        constructor(e, t, i) {
          (this.diagnostics = e), (this.panel = t), (this.selected = i);
        }
        static init(e, t, i) {
          let r = i.facet(nn).markerFilter;
          r && (e = r(e, i));
          let s = e.slice().sort((c, f) => c.from - f.from || c.to - f.to),
            o = new pt(),
            l = [],
            a = 0;
          for (let c = 0; ; ) {
            let f = c == s.length ? null : s[c];
            if (!f && !l.length) break;
            let u, d;
            for (
              l.length
                ? ((u = a),
                  (d = l.reduce(
                    (m, g) => Math.min(m, g.to),
                    f && f.from > u ? f.from : 1e8
                  )))
                : ((u = f.from), (d = f.to), l.push(f), c++);
              c < s.length;

            ) {
              let m = s[c];
              if (m.from == u && (m.to > m.from || m.to == u))
                l.push(m), c++, (d = Math.min(m.to, d));
              else {
                d = Math.min(m.from, d);
                break;
              }
            }
            let O = vS(l);
            if (
              l.some(
                (m) =>
                  m.from == m.to ||
                  (m.from == m.to - 1 && i.doc.lineAt(m.from).to == m.from)
              )
            )
              o.add(
                u,
                u,
                A.widget({ widget: new wS(O), diagnostics: l.slice() })
              );
            else {
              let m = l.reduce(
                (g, Q) => (Q.markClass ? g + " " + Q.markClass : g),
                ""
              );
              o.add(
                u,
                d,
                A.mark({
                  class: "cm-lintRange cm-lintRange-" + O + m,
                  diagnostics: l.slice(),
                  inclusiveEnd: l.some((g) => g.to > d),
                })
              );
            }
            a = d;
            for (let m = 0; m < l.length; m++) l[m].to <= a && l.splice(m--, 1);
          }
          let h = o.finish();
          return new Dt(h, t, di(h));
        }
      }
      function di(n, e = null, t = 0) {
        let i = null;
        return (
          n.between(t, 1e9, (r, s, { spec: o }) => {
            if (!(e && o.diagnostics.indexOf(e) < 0))
              if (!i) i = new oh(r, s, e || o.diagnostics[0]);
              else {
                if (o.diagnostics.indexOf(i.diagnostic) < 0) return !1;
                i = new oh(i.from, s, i.diagnostic);
              }
          }),
          i
        );
      }
      function pS(n, e) {
        let t = e.pos,
          i = e.end || t,
          r = n.state.facet(nn).hideOn(n, t, i);
        if (r != null) return r;
        let s = n.startState.doc.lineAt(e.pos);
        return !!(
          n.effects.some((o) => o.is(Eu)) ||
          n.changes.touchesRange(s.from, Math.max(s.to, i))
        );
      }
      function mS(n, e) {
        return n.field(Ae, !1) ? e : e.concat(R.appendConfig.of(TS));
      }
      const Eu = R.define(),
        ul = R.define(),
        _u = R.define(),
        Ae = oe.define({
          create() {
            return new Dt(A.none, null, null);
          },
          update(n, e) {
            if (e.docChanged && n.diagnostics.size) {
              let t = n.diagnostics.map(e.changes),
                i = null,
                r = n.panel;
              if (n.selected) {
                let s = e.changes.mapPos(n.selected.from, 1);
                i = di(t, n.selected.diagnostic, s) || di(t, null, s);
              }
              !t.size && r && e.state.facet(nn).autoPanel && (r = null),
                (n = new Dt(t, r, i));
            }
            for (let t of e.effects)
              if (t.is(Eu)) {
                let i = e.state.facet(nn).autoPanel
                  ? t.value.length
                    ? rn.open
                    : null
                  : n.panel;
                n = Dt.init(t.value, i, e.state);
              } else
                t.is(ul)
                  ? (n = new Dt(
                      n.diagnostics,
                      t.value ? rn.open : null,
                      n.selected
                    ))
                  : t.is(_u) && (n = new Dt(n.diagnostics, n.panel, t.value));
            return n;
          },
          provide: (n) => [
            Ni.from(n, (e) => e.panel),
            v.decorations.from(n, (e) => e.diagnostics),
          ],
        }),
        gS = A.mark({ class: "cm-lintRange cm-lintRange-active" });
      function QS(n, e, t) {
        let { diagnostics: i } = n.state.field(Ae),
          r,
          s = -1,
          o = -1;
        i.between(
          e - (t < 0 ? 1 : 0),
          e + (t > 0 ? 1 : 0),
          (a, h, { spec: c }) => {
            if (
              e >= a &&
              e <= h &&
              (a == h || ((e > a || t > 0) && (e < h || t < 0)))
            )
              return (r = c.diagnostics), (s = a), (o = h), !1;
          }
        );
        let l = n.state.facet(nn).tooltipFilter;
        return (
          r && l && (r = l(r, n.state)),
          r
            ? {
                pos: s,
                end: o,
                above: n.state.doc.lineAt(s).to < o,
                create() {
                  return { dom: SS(n, r) };
                },
              }
            : null
        );
      }
      function SS(n, e) {
        return j(
          "ul",
          { class: "cm-tooltip-lint" },
          e.map((t) => qu(n, t, !1))
        );
      }
      const yS = (n) => {
          let e = n.state.field(Ae, !1);
          (!e || !e.panel) && n.dispatch({ effects: mS(n.state, [ul.of(!0)]) });
          let t = Gi(n, rn.open);
          return t && t.dom.querySelector(".cm-panel-lint ul").focus(), !0;
        },
        lh = (n) => {
          let e = n.state.field(Ae, !1);
          return !e || !e.panel ? !1 : (n.dispatch({ effects: ul.of(!1) }), !0);
        },
        bS = (n) => {
          let e = n.state.field(Ae, !1);
          if (!e) return !1;
          let t = n.state.selection.main,
            i = e.diagnostics.iter(t.to + 1);
          return !i.value &&
            ((i = e.diagnostics.iter(0)),
            !i.value || (i.from == t.from && i.to == t.to))
            ? !1
            : (n.dispatch({
                selection: { anchor: i.from, head: i.to },
                scrollIntoView: !0,
              }),
              !0);
        },
        xS = [
          { key: "Mod-Shift-m", run: yS, preventDefault: !0 },
          { key: "F8", run: bS },
        ],
        nn = C.define({
          combine(n) {
            return Object.assign(
              { sources: n.map((e) => e.source).filter((e) => e != null) },
              lt(
                n.map((e) => e.config),
                {
                  delay: 750,
                  markerFilter: null,
                  tooltipFilter: null,
                  needsRefresh: null,
                  hideOn: () => null,
                },
                {
                  needsRefresh: (e, t) =>
                    e ? (t ? (i) => e(i) || t(i) : e) : t,
                }
              )
            );
          },
        });
      function Vu(n) {
        let e = [];
        if (n)
          e: for (let { name: t } of n) {
            for (let i = 0; i < t.length; i++) {
              let r = t[i];
              if (
                /[a-zA-Z]/.test(r) &&
                !e.some((s) => s.toLowerCase() == r.toLowerCase())
              ) {
                e.push(r);
                continue e;
              }
            }
            e.push("");
          }
        return e;
      }
      function qu(n, e, t) {
        var i;
        let r = t ? Vu(e.actions) : [];
        return j(
          "li",
          { class: "cm-diagnostic cm-diagnostic-" + e.severity },
          j(
            "span",
            { class: "cm-diagnosticText" },
            e.renderMessage ? e.renderMessage(n) : e.message
          ),
          (i = e.actions) === null || i === void 0
            ? void 0
            : i.map((s, o) => {
                let l = !1,
                  a = (u) => {
                    if ((u.preventDefault(), l)) return;
                    l = !0;
                    let d = di(n.state.field(Ae).diagnostics, e);
                    d && s.apply(n, d.from, d.to);
                  },
                  { name: h } = s,
                  c = r[o] ? h.indexOf(r[o]) : -1,
                  f =
                    c < 0
                      ? h
                      : [
                          h.slice(0, c),
                          j("u", h.slice(c, c + 1)),
                          h.slice(c + 1),
                        ];
                return j(
                  "button",
                  {
                    type: "button",
                    class: "cm-diagnosticAction",
                    onclick: a,
                    onmousedown: a,
                    "aria-label": ` Action: ${h}${
                      c < 0 ? "" : ` (access key "${r[o]})"`
                    }.`,
                  },
                  f
                );
              }),
          e.source && j("div", { class: "cm-diagnosticSource" }, e.source)
        );
      }
      class wS extends St {
        constructor(e) {
          super(), (this.sev = e);
        }
        eq(e) {
          return e.sev == this.sev;
        }
        toDOM() {
          return j("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
        }
      }
      class ah {
        constructor(e, t) {
          (this.diagnostic = t),
            (this.id =
              "item_" + Math.floor(Math.random() * 4294967295).toString(16)),
            (this.dom = qu(e, t, !0)),
            (this.dom.id = this.id),
            this.dom.setAttribute("role", "option");
        }
      }
      class rn {
        constructor(e) {
          (this.view = e), (this.items = []);
          let t = (r) => {
              if (r.keyCode == 27) lh(this.view), this.view.focus();
              else if (r.keyCode == 38 || r.keyCode == 33)
                this.moveSelection(
                  (this.selectedIndex - 1 + this.items.length) %
                    this.items.length
                );
              else if (r.keyCode == 40 || r.keyCode == 34)
                this.moveSelection(
                  (this.selectedIndex + 1) % this.items.length
                );
              else if (r.keyCode == 36) this.moveSelection(0);
              else if (r.keyCode == 35)
                this.moveSelection(this.items.length - 1);
              else if (r.keyCode == 13) this.view.focus();
              else if (
                r.keyCode >= 65 &&
                r.keyCode <= 90 &&
                this.selectedIndex >= 0
              ) {
                let { diagnostic: s } = this.items[this.selectedIndex],
                  o = Vu(s.actions);
                for (let l = 0; l < o.length; l++)
                  if (o[l].toUpperCase().charCodeAt(0) == r.keyCode) {
                    let a = di(this.view.state.field(Ae).diagnostics, s);
                    a && s.actions[l].apply(e, a.from, a.to);
                  }
              } else return;
              r.preventDefault();
            },
            i = (r) => {
              for (let s = 0; s < this.items.length; s++)
                this.items[s].dom.contains(r.target) && this.moveSelection(s);
            };
          (this.list = j("ul", {
            tabIndex: 0,
            role: "listbox",
            "aria-label": this.view.state.phrase("Diagnostics"),
            onkeydown: t,
            onclick: i,
          })),
            (this.dom = j(
              "div",
              { class: "cm-panel-lint" },
              this.list,
              j(
                "button",
                {
                  type: "button",
                  name: "close",
                  "aria-label": this.view.state.phrase("close"),
                  onclick: () => lh(this.view),
                },
                ""
              )
            )),
            this.update();
        }
        get selectedIndex() {
          let e = this.view.state.field(Ae).selected;
          if (!e) return -1;
          for (let t = 0; t < this.items.length; t++)
            if (this.items[t].diagnostic == e.diagnostic) return t;
          return -1;
        }
        update() {
          let { diagnostics: e, selected: t } = this.view.state.field(Ae),
            i = 0,
            r = !1,
            s = null,
            o = new Set();
          for (
            e.between(0, this.view.state.doc.length, (l, a, { spec: h }) => {
              for (let c of h.diagnostics) {
                if (o.has(c)) continue;
                o.add(c);
                let f = -1,
                  u;
                for (let d = i; d < this.items.length; d++)
                  if (this.items[d].diagnostic == c) {
                    f = d;
                    break;
                  }
                f < 0
                  ? ((u = new ah(this.view, c)),
                    this.items.splice(i, 0, u),
                    (r = !0))
                  : ((u = this.items[f]),
                    f > i && (this.items.splice(i, f - i), (r = !0))),
                  t && u.diagnostic == t.diagnostic
                    ? u.dom.hasAttribute("aria-selected") ||
                      (u.dom.setAttribute("aria-selected", "true"), (s = u))
                    : u.dom.hasAttribute("aria-selected") &&
                      u.dom.removeAttribute("aria-selected"),
                  i++;
              }
            });
            i < this.items.length &&
            !(this.items.length == 1 && this.items[0].diagnostic.from < 0);

          )
            (r = !0), this.items.pop();
          this.items.length == 0 &&
            (this.items.push(
              new ah(this.view, {
                from: -1,
                to: -1,
                severity: "info",
                message: this.view.state.phrase("No diagnostics"),
              })
            ),
            (r = !0)),
            s
              ? (this.list.setAttribute("aria-activedescendant", s.id),
                this.view.requestMeasure({
                  key: this,
                  read: () => ({
                    sel: s.dom.getBoundingClientRect(),
                    panel: this.list.getBoundingClientRect(),
                  }),
                  write: ({ sel: l, panel: a }) => {
                    let h = a.height / this.list.offsetHeight;
                    l.top < a.top
                      ? (this.list.scrollTop -= (a.top - l.top) / h)
                      : l.bottom > a.bottom &&
                        (this.list.scrollTop += (l.bottom - a.bottom) / h);
                  },
                }))
              : this.selectedIndex < 0 &&
                this.list.removeAttribute("aria-activedescendant"),
            r && this.sync();
        }
        sync() {
          let e = this.list.firstChild;
          function t() {
            let i = e;
            (e = i.nextSibling), i.remove();
          }
          for (let i of this.items)
            if (i.dom.parentNode == this.list) {
              for (; e != i.dom; ) t();
              e = i.dom.nextSibling;
            } else this.list.insertBefore(i.dom, e);
          for (; e; ) t();
        }
        moveSelection(e) {
          if (this.selectedIndex < 0) return;
          let t = this.view.state.field(Ae),
            i = di(t.diagnostics, this.items[e].diagnostic);
          i &&
            this.view.dispatch({
              selection: { anchor: i.from, head: i.to },
              scrollIntoView: !0,
              effects: _u.of(i),
            });
        }
        static open(e) {
          return new rn(e);
        }
      }
      function kS(n, e = 'viewBox="0 0 40 40"') {
        return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(
          n
        )}</svg>')`;
      }
      function Dn(n) {
        return kS(
          `<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${n}" fill="none" stroke-width=".7"/>`,
          'width="6" height="3"'
        );
      }
      const $S = v.baseTheme({
        ".cm-diagnostic": {
          padding: "3px 6px 3px 8px",
          marginLeft: "-1px",
          display: "block",
          whiteSpace: "pre-wrap",
        },
        ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
        ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
        ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
        ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
        ".cm-diagnosticAction": {
          font: "inherit",
          border: "none",
          padding: "2px 4px",
          backgroundColor: "#444",
          color: "white",
          borderRadius: "3px",
          marginLeft: "8px",
          cursor: "pointer",
        },
        ".cm-diagnosticSource": { fontSize: "70%", opacity: 0.7 },
        ".cm-lintRange": {
          backgroundPosition: "left bottom",
          backgroundRepeat: "repeat-x",
          paddingBottom: "0.7px",
        },
        ".cm-lintRange-error": { backgroundImage: Dn("#d11") },
        ".cm-lintRange-warning": { backgroundImage: Dn("orange") },
        ".cm-lintRange-info": { backgroundImage: Dn("#999") },
        ".cm-lintRange-hint": { backgroundImage: Dn("#66d") },
        ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
        ".cm-tooltip-lint": { padding: 0, margin: 0 },
        ".cm-lintPoint": {
          position: "relative",
          "&:after": {
            content: '""',
            position: "absolute",
            bottom: 0,
            left: "-2px",
            borderLeft: "3px solid transparent",
            borderRight: "3px solid transparent",
            borderBottom: "4px solid #d11",
          },
        },
        ".cm-lintPoint-warning": { "&:after": { borderBottomColor: "orange" } },
        ".cm-lintPoint-info": { "&:after": { borderBottomColor: "#999" } },
        ".cm-lintPoint-hint": { "&:after": { borderBottomColor: "#66d" } },
        ".cm-panel.cm-panel-lint": {
          position: "relative",
          "& ul": {
            maxHeight: "100px",
            overflowY: "auto",
            "& [aria-selected]": {
              backgroundColor: "#ddd",
              "& u": { textDecoration: "underline" },
            },
            "&:focus [aria-selected]": {
              background_fallback: "#bdf",
              backgroundColor: "Highlight",
              color_fallback: "white",
              color: "HighlightText",
            },
            "& u": { textDecoration: "none" },
            padding: 0,
            margin: 0,
          },
          "& [name=close]": {
            position: "absolute",
            top: "0",
            right: "2px",
            background: "inherit",
            border: "none",
            font: "inherit",
            padding: 0,
            margin: 0,
          },
        },
      });
      function PS(n) {
        return n == "error" ? 4 : n == "warning" ? 3 : n == "info" ? 2 : 1;
      }
      function vS(n) {
        let e = "hint",
          t = 1;
        for (let i of n) {
          let r = PS(i.severity);
          r > t && ((t = r), (e = i.severity));
        }
        return e;
      }
      const TS = [
          Ae,
          v.decorations.compute([Ae], (n) => {
            let { selected: e, panel: t } = n.field(Ae);
            return !e || !t || e.from == e.to
              ? A.none
              : A.set([gS.range(e.from, e.to)]);
          }),
          am(QS, { hideOn: pS }),
          $S,
        ],
        CS = [
          Sm(),
          xm(),
          _p(),
          Wg(),
          mg(),
          Tp(),
          Rp(),
          _.allowMultipleSelections.of(!0),
          ng(),
          zf(yg, { fallback: !0 }),
          vg(),
          iS(),
          dS(),
          Hp(),
          em(),
          Bp(),
          F0(),
          Mr.of([...oS, ...j0, ...pQ, ...Hg, ...ug, ...Du, ...xS]),
        ],
        ZS = "#e5c07b",
        hh = "#e06c75",
        AS = "#56b6c2",
        XS = "#ffffff",
        Un = "#abb2bf",
        ko = "#7d8799",
        RS = "#61afef",
        MS = "#98c379",
        ch = "#d19a66",
        YS = "#c678dd",
        zS = "#21252b",
        fh = "#2c313a",
        uh = "#282c34",
        Qs = "#353a42",
        DS = "#3E4451",
        dh = "#528bff",
        ES = v.theme(
          {
            "&": { color: Un, backgroundColor: uh },
            ".cm-content": { caretColor: dh },
            ".cm-cursor, .cm-dropCursor": { borderLeftColor: dh },
            "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection":
              { backgroundColor: DS },
            ".cm-panels": { backgroundColor: zS, color: Un },
            ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
            ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
            ".cm-searchMatch": {
              backgroundColor: "#72a1ff59",
              outline: "1px solid #457dff",
            },
            ".cm-searchMatch.cm-searchMatch-selected": {
              backgroundColor: "#6199ff2f",
            },
            ".cm-activeLine": { backgroundColor: "#6699ff0b" },
            ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
            "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket":
              { backgroundColor: "#bad0f847" },
            ".cm-gutters": { backgroundColor: uh, color: ko, border: "none" },
            ".cm-activeLineGutter": { backgroundColor: fh },
            ".cm-foldPlaceholder": {
              backgroundColor: "transparent",
              border: "none",
              color: "#ddd",
            },
            ".cm-tooltip": { border: "none", backgroundColor: Qs },
            ".cm-tooltip .cm-tooltip-arrow:before": {
              borderTopColor: "transparent",
              borderBottomColor: "transparent",
            },
            ".cm-tooltip .cm-tooltip-arrow:after": {
              borderTopColor: Qs,
              borderBottomColor: Qs,
            },
            ".cm-tooltip-autocomplete": {
              "& > ul > li[aria-selected]": { backgroundColor: fh, color: Un },
            },
          },
          { dark: !0 }
        ),
        _S = cn.define([
          { tag: p.keyword, color: YS },
          {
            tag: [p.name, p.deleted, p.character, p.propertyName, p.macroName],
            color: hh,
          },
          { tag: [p.function(p.variableName), p.labelName], color: RS },
          { tag: [p.color, p.constant(p.name), p.standard(p.name)], color: ch },
          { tag: [p.definition(p.name), p.separator], color: Un },
          {
            tag: [
              p.typeName,
              p.className,
              p.number,
              p.changed,
              p.annotation,
              p.modifier,
              p.self,
              p.namespace,
            ],
            color: ZS,
          },
          {
            tag: [
              p.operator,
              p.operatorKeyword,
              p.url,
              p.escape,
              p.regexp,
              p.link,
              p.special(p.string),
            ],
            color: AS,
          },
          { tag: [p.meta, p.comment], color: ko },
          { tag: p.strong, fontWeight: "bold" },
          { tag: p.emphasis, fontStyle: "italic" },
          { tag: p.strikethrough, textDecoration: "line-through" },
          { tag: p.link, color: ko, textDecoration: "underline" },
          { tag: p.heading, fontWeight: "bold", color: hh },
          { tag: [p.atom, p.bool, p.special(p.variableName)], color: ch },
          { tag: [p.processingInstruction, p.string, p.inserted], color: MS },
          { tag: p.invalid, color: XS },
        ]),
        VS = [ES, zf(_S)];
      var Oh = {};
      class xr {
        constructor(e, t, i, r, s, o, l, a, h, c = 0, f) {
          (this.p = e),
            (this.stack = t),
            (this.state = i),
            (this.reducePos = r),
            (this.pos = s),
            (this.score = o),
            (this.buffer = l),
            (this.bufferBase = a),
            (this.curContext = h),
            (this.lookAhead = c),
            (this.parent = f);
        }
        toString() {
          return `[${this.stack
            .filter((e, t) => t % 3 == 0)
            .concat(this.state)}]@${this.pos}${
            this.score ? "!" + this.score : ""
          }`;
        }
        static start(e, t, i = 0) {
          let r = e.parser.context;
          return new xr(
            e,
            [],
            t,
            i,
            i,
            0,
            [],
            0,
            r ? new ph(r, r.start) : null,
            0,
            null
          );
        }
        get context() {
          return this.curContext ? this.curContext.context : null;
        }
        pushState(e, t) {
          this.stack.push(this.state, t, this.bufferBase + this.buffer.length),
            (this.state = e);
        }
        reduce(e) {
          var t;
          let i = e >> 19,
            r = e & 65535,
            { parser: s } = this.p,
            o = this.reducePos < this.pos - 25;
          o && this.setLookAhead(this.pos);
          let l = s.dynamicPrecedence(r);
          if ((l && (this.score += l), i == 0)) {
            this.pushState(s.getGoto(this.state, r, !0), this.reducePos),
              r < s.minRepeatTerm &&
                this.storeNode(
                  r,
                  this.reducePos,
                  this.reducePos,
                  o ? 8 : 4,
                  !0
                ),
              this.reduceContext(r, this.reducePos);
            return;
          }
          let a = this.stack.length - (i - 1) * 3 - (e & 262144 ? 6 : 0),
            h = a ? this.stack[a - 2] : this.p.ranges[0].from,
            c = this.reducePos - h;
          c >= 2e3 &&
            !(
              !(
                (t = this.p.parser.nodeSet.types[r]) === null || t === void 0
              ) && t.isAnonymous
            ) &&
            (h == this.p.lastBigReductionStart
              ? (this.p.bigReductionCount++, (this.p.lastBigReductionSize = c))
              : this.p.lastBigReductionSize < c &&
                ((this.p.bigReductionCount = 1),
                (this.p.lastBigReductionStart = h),
                (this.p.lastBigReductionSize = c)));
          let f = a ? this.stack[a - 1] : 0,
            u = this.bufferBase + this.buffer.length - f;
          if (r < s.minRepeatTerm || e & 131072) {
            let d = s.stateFlag(this.state, 1) ? this.pos : this.reducePos;
            this.storeNode(r, h, d, u + 4, !0);
          }
          if (e & 262144) this.state = this.stack[a];
          else {
            let d = this.stack[a - 3];
            this.state = s.getGoto(d, r, !0);
          }
          for (; this.stack.length > a; ) this.stack.pop();
          this.reduceContext(r, h);
        }
        storeNode(e, t, i, r = 4, s = !1) {
          if (
            e == 0 &&
            (!this.stack.length ||
              this.stack[this.stack.length - 1] <
                this.buffer.length + this.bufferBase)
          ) {
            let o = this,
              l = this.buffer.length;
            if (
              (l == 0 &&
                o.parent &&
                ((l = o.bufferBase - o.parent.bufferBase), (o = o.parent)),
              l > 0 && o.buffer[l - 4] == 0 && o.buffer[l - 1] > -1)
            ) {
              if (t == i) return;
              if (o.buffer[l - 2] >= t) {
                o.buffer[l - 2] = i;
                return;
              }
            }
          }
          if (!s || this.pos == i) this.buffer.push(e, t, i, r);
          else {
            let o = this.buffer.length;
            if (o > 0 && this.buffer[o - 4] != 0) {
              let l = !1;
              for (let a = o; a > 0 && this.buffer[a - 2] > i; a -= 4)
                if (this.buffer[a - 1] >= 0) {
                  l = !0;
                  break;
                }
              if (l)
                for (; o > 0 && this.buffer[o - 2] > i; )
                  (this.buffer[o] = this.buffer[o - 4]),
                    (this.buffer[o + 1] = this.buffer[o - 3]),
                    (this.buffer[o + 2] = this.buffer[o - 2]),
                    (this.buffer[o + 3] = this.buffer[o - 1]),
                    (o -= 4),
                    r > 4 && (r -= 4);
            }
            (this.buffer[o] = e),
              (this.buffer[o + 1] = t),
              (this.buffer[o + 2] = i),
              (this.buffer[o + 3] = r);
          }
        }
        shift(e, t, i, r) {
          if (e & 131072) this.pushState(e & 65535, this.pos);
          else if ((e & 262144) == 0) {
            let s = e,
              { parser: o } = this.p;
            (r > this.pos || t <= o.maxNode) &&
              ((this.pos = r), o.stateFlag(s, 1) || (this.reducePos = r)),
              this.pushState(s, i),
              this.shiftContext(t, i),
              t <= o.maxNode && this.buffer.push(t, i, r, 4);
          } else
            (this.pos = r),
              this.shiftContext(t, i),
              t <= this.p.parser.maxNode && this.buffer.push(t, i, r, 4);
        }
        apply(e, t, i, r) {
          e & 65536 ? this.reduce(e) : this.shift(e, t, i, r);
        }
        useNode(e, t) {
          let i = this.p.reused.length - 1;
          (i < 0 || this.p.reused[i] != e) && (this.p.reused.push(e), i++);
          let r = this.pos;
          (this.reducePos = this.pos = r + e.length),
            this.pushState(t, r),
            this.buffer.push(i, r, this.reducePos, -1),
            this.curContext &&
              this.updateContext(
                this.curContext.tracker.reuse(
                  this.curContext.context,
                  e,
                  this,
                  this.p.stream.reset(this.pos - e.length)
                )
              );
        }
        split() {
          let e = this,
            t = e.buffer.length;
          for (; t > 0 && e.buffer[t - 2] > e.reducePos; ) t -= 4;
          let i = e.buffer.slice(t),
            r = e.bufferBase + t;
          for (; e && r == e.bufferBase; ) e = e.parent;
          return new xr(
            this.p,
            this.stack.slice(),
            this.state,
            this.reducePos,
            this.pos,
            this.score,
            i,
            r,
            this.curContext,
            this.lookAhead,
            e
          );
        }
        recoverByDelete(e, t) {
          let i = e <= this.p.parser.maxNode;
          i && this.storeNode(e, this.pos, t, 4),
            this.storeNode(0, this.pos, t, i ? 8 : 4),
            (this.pos = this.reducePos = t),
            (this.score -= 190);
        }
        canShift(e) {
          for (let t = new qS(this); ; ) {
            let i =
              this.p.parser.stateSlot(t.state, 4) ||
              this.p.parser.hasAction(t.state, e);
            if (i == 0) return !1;
            if ((i & 65536) == 0) return !0;
            t.reduce(i);
          }
        }
        recoverByInsert(e) {
          if (this.stack.length >= 300) return [];
          let t = this.p.parser.nextStates(this.state);
          if (t.length > 8 || this.stack.length >= 120) {
            let r = [];
            for (let s = 0, o; s < t.length; s += 2)
              (o = t[s + 1]) != this.state &&
                this.p.parser.hasAction(o, e) &&
                r.push(t[s], o);
            if (this.stack.length < 120)
              for (let s = 0; r.length < 8 && s < t.length; s += 2) {
                let o = t[s + 1];
                r.some((l, a) => a & 1 && l == o) || r.push(t[s], o);
              }
            t = r;
          }
          let i = [];
          for (let r = 0; r < t.length && i.length < 4; r += 2) {
            let s = t[r + 1];
            if (s == this.state) continue;
            let o = this.split();
            o.pushState(s, this.pos),
              o.storeNode(0, o.pos, o.pos, 4, !0),
              o.shiftContext(t[r], this.pos),
              (o.reducePos = this.pos),
              (o.score -= 200),
              i.push(o);
          }
          return i;
        }
        forceReduce() {
          let { parser: e } = this.p,
            t = e.stateSlot(this.state, 5);
          if ((t & 65536) == 0) return !1;
          if (!e.validAction(this.state, t)) {
            let i = t >> 19,
              r = t & 65535,
              s = this.stack.length - i * 3;
            if (s < 0 || e.getGoto(this.stack[s], r, !1) < 0) {
              let o = this.findForcedReduction();
              if (o == null) return !1;
              t = o;
            }
            this.storeNode(0, this.pos, this.pos, 4, !0), (this.score -= 100);
          }
          return (this.reducePos = this.pos), this.reduce(t), !0;
        }
        findForcedReduction() {
          let { parser: e } = this.p,
            t = [],
            i = (r, s) => {
              if (!t.includes(r))
                return (
                  t.push(r),
                  e.allActions(r, (o) => {
                    if (!(o & 393216))
                      if (o & 65536) {
                        let l = (o >> 19) - s;
                        if (l > 1) {
                          let a = o & 65535,
                            h = this.stack.length - l * 3;
                          if (h >= 0 && e.getGoto(this.stack[h], a, !1) >= 0)
                            return (l << 19) | 65536 | a;
                        }
                      } else {
                        let l = i(o, s + 1);
                        if (l != null) return l;
                      }
                  })
                );
            };
          return i(this.state, 0);
        }
        forceAll() {
          for (; !this.p.parser.stateFlag(this.state, 2); )
            if (!this.forceReduce()) {
              this.storeNode(0, this.pos, this.pos, 4, !0);
              break;
            }
          return this;
        }
        get deadEnd() {
          if (this.stack.length != 3) return !1;
          let { parser: e } = this.p;
          return (
            e.data[e.stateSlot(this.state, 1)] == 65535 &&
            !e.stateSlot(this.state, 4)
          );
        }
        restart() {
          this.storeNode(0, this.pos, this.pos, 4, !0),
            (this.state = this.stack[0]),
            (this.stack.length = 0);
        }
        sameState(e) {
          if (this.state != e.state || this.stack.length != e.stack.length)
            return !1;
          for (let t = 0; t < this.stack.length; t += 3)
            if (this.stack[t] != e.stack[t]) return !1;
          return !0;
        }
        get parser() {
          return this.p.parser;
        }
        dialectEnabled(e) {
          return this.p.parser.dialect.flags[e];
        }
        shiftContext(e, t) {
          this.curContext &&
            this.updateContext(
              this.curContext.tracker.shift(
                this.curContext.context,
                e,
                this,
                this.p.stream.reset(t)
              )
            );
        }
        reduceContext(e, t) {
          this.curContext &&
            this.updateContext(
              this.curContext.tracker.reduce(
                this.curContext.context,
                e,
                this,
                this.p.stream.reset(t)
              )
            );
        }
        emitContext() {
          let e = this.buffer.length - 1;
          (e < 0 || this.buffer[e] != -3) &&
            this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
        }
        emitLookAhead() {
          let e = this.buffer.length - 1;
          (e < 0 || this.buffer[e] != -4) &&
            this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
        }
        updateContext(e) {
          if (e != this.curContext.context) {
            let t = new ph(this.curContext.tracker, e);
            t.hash != this.curContext.hash && this.emitContext(),
              (this.curContext = t);
          }
        }
        setLookAhead(e) {
          e > this.lookAhead && (this.emitLookAhead(), (this.lookAhead = e));
        }
        close() {
          this.curContext &&
            this.curContext.tracker.strict &&
            this.emitContext(),
            this.lookAhead > 0 && this.emitLookAhead();
        }
      }
      class ph {
        constructor(e, t) {
          (this.tracker = e),
            (this.context = t),
            (this.hash = e.strict ? e.hash(t) : 0);
        }
      }
      class qS {
        constructor(e) {
          (this.start = e),
            (this.state = e.state),
            (this.stack = e.stack),
            (this.base = this.stack.length);
        }
        reduce(e) {
          let t = e & 65535,
            i = e >> 19;
          i == 0
            ? (this.stack == this.start.stack &&
                (this.stack = this.stack.slice()),
              this.stack.push(this.state, 0, 0),
              (this.base += 3))
            : (this.base -= (i - 1) * 3);
          let r = this.start.p.parser.getGoto(this.stack[this.base - 3], t, !0);
          this.state = r;
        }
      }
      class wr {
        constructor(e, t, i) {
          (this.stack = e),
            (this.pos = t),
            (this.index = i),
            (this.buffer = e.buffer),
            this.index == 0 && this.maybeNext();
        }
        static create(e, t = e.bufferBase + e.buffer.length) {
          return new wr(e, t, t - e.bufferBase);
        }
        maybeNext() {
          let e = this.stack.parent;
          e != null &&
            ((this.index = this.stack.bufferBase - e.bufferBase),
            (this.stack = e),
            (this.buffer = e.buffer));
        }
        get id() {
          return this.buffer[this.index - 4];
        }
        get start() {
          return this.buffer[this.index - 3];
        }
        get end() {
          return this.buffer[this.index - 2];
        }
        get size() {
          return this.buffer[this.index - 1];
        }
        next() {
          (this.index -= 4),
            (this.pos -= 4),
            this.index == 0 && this.maybeNext();
        }
        fork() {
          return new wr(this.stack, this.pos, this.index);
        }
      }
      function Ri(n, e = Uint16Array) {
        if (typeof n != "string") return n;
        let t = null;
        for (let i = 0, r = 0; i < n.length; ) {
          let s = 0;
          for (;;) {
            let o = n.charCodeAt(i++),
              l = !1;
            if (o == 126) {
              s = 65535;
              break;
            }
            o >= 92 && o--, o >= 34 && o--;
            let a = o - 32;
            if ((a >= 46 && ((a -= 46), (l = !0)), (s += a), l)) break;
            s *= 46;
          }
          t ? (t[r++] = s) : (t = new e(s));
        }
        return t;
      }
      class Fn {
        constructor() {
          (this.start = -1),
            (this.value = -1),
            (this.end = -1),
            (this.extended = -1),
            (this.lookAhead = 0),
            (this.mask = 0),
            (this.context = 0);
        }
      }
      const mh = new Fn();
      class WS {
        constructor(e, t) {
          (this.input = e),
            (this.ranges = t),
            (this.chunk = ""),
            (this.chunkOff = 0),
            (this.chunk2 = ""),
            (this.chunk2Pos = 0),
            (this.next = -1),
            (this.token = mh),
            (this.rangeIndex = 0),
            (this.pos = this.chunkPos = t[0].from),
            (this.range = t[0]),
            (this.end = t[t.length - 1].to),
            this.readNext();
        }
        resolveOffset(e, t) {
          let i = this.range,
            r = this.rangeIndex,
            s = this.pos + e;
          for (; s < i.from; ) {
            if (!r) return null;
            let o = this.ranges[--r];
            (s -= i.from - o.to), (i = o);
          }
          for (; t < 0 ? s > i.to : s >= i.to; ) {
            if (r == this.ranges.length - 1) return null;
            let o = this.ranges[++r];
            (s += o.from - i.to), (i = o);
          }
          return s;
        }
        clipPos(e) {
          if (e >= this.range.from && e < this.range.to) return e;
          for (let t of this.ranges) if (t.to > e) return Math.max(e, t.from);
          return this.end;
        }
        peek(e) {
          let t = this.chunkOff + e,
            i,
            r;
          if (t >= 0 && t < this.chunk.length)
            (i = this.pos + e), (r = this.chunk.charCodeAt(t));
          else {
            let s = this.resolveOffset(e, 1);
            if (s == null) return -1;
            if (
              ((i = s),
              i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
            )
              r = this.chunk2.charCodeAt(i - this.chunk2Pos);
            else {
              let o = this.rangeIndex,
                l = this.range;
              for (; l.to <= i; ) l = this.ranges[++o];
              (this.chunk2 = this.input.chunk((this.chunk2Pos = i))),
                i + this.chunk2.length > l.to &&
                  (this.chunk2 = this.chunk2.slice(0, l.to - i)),
                (r = this.chunk2.charCodeAt(0));
            }
          }
          return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), r;
        }
        acceptToken(e, t = 0) {
          let i = t ? this.resolveOffset(t, -1) : this.pos;
          if (i == null || i < this.token.start)
            throw new RangeError("Token end out of bounds");
          (this.token.value = e), (this.token.end = i);
        }
        acceptTokenTo(e, t) {
          (this.token.value = e), (this.token.end = t);
        }
        getChunk() {
          if (
            this.pos >= this.chunk2Pos &&
            this.pos < this.chunk2Pos + this.chunk2.length
          ) {
            let { chunk: e, chunkPos: t } = this;
            (this.chunk = this.chunk2),
              (this.chunkPos = this.chunk2Pos),
              (this.chunk2 = e),
              (this.chunk2Pos = t),
              (this.chunkOff = this.pos - this.chunkPos);
          } else {
            (this.chunk2 = this.chunk), (this.chunk2Pos = this.chunkPos);
            let e = this.input.chunk(this.pos),
              t = this.pos + e.length;
            (this.chunk =
              t > this.range.to ? e.slice(0, this.range.to - this.pos) : e),
              (this.chunkPos = this.pos),
              (this.chunkOff = 0);
          }
        }
        readNext() {
          return this.chunkOff >= this.chunk.length &&
            (this.getChunk(), this.chunkOff == this.chunk.length)
            ? (this.next = -1)
            : (this.next = this.chunk.charCodeAt(this.chunkOff));
        }
        advance(e = 1) {
          for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
            if (this.rangeIndex == this.ranges.length - 1)
              return this.setDone();
            (e -= this.range.to - this.pos),
              (this.range = this.ranges[++this.rangeIndex]),
              (this.pos = this.range.from);
          }
          return (
            (this.pos += e),
            this.pos >= this.token.lookAhead &&
              (this.token.lookAhead = this.pos + 1),
            this.readNext()
          );
        }
        setDone() {
          return (
            (this.pos = this.chunkPos = this.end),
            (this.range =
              this.ranges[(this.rangeIndex = this.ranges.length - 1)]),
            (this.chunk = ""),
            (this.next = -1)
          );
        }
        reset(e, t) {
          if (
            (t
              ? ((this.token = t),
                (t.start = e),
                (t.lookAhead = e + 1),
                (t.value = t.extended = -1))
              : (this.token = mh),
            this.pos != e)
          ) {
            if (((this.pos = e), e == this.end)) return this.setDone(), this;
            for (; e < this.range.from; )
              this.range = this.ranges[--this.rangeIndex];
            for (; e >= this.range.to; )
              this.range = this.ranges[++this.rangeIndex];
            e >= this.chunkPos && e < this.chunkPos + this.chunk.length
              ? (this.chunkOff = e - this.chunkPos)
              : ((this.chunk = ""), (this.chunkOff = 0)),
              this.readNext();
          }
          return this;
        }
        read(e, t) {
          if (e >= this.chunkPos && t <= this.chunkPos + this.chunk.length)
            return this.chunk.slice(e - this.chunkPos, t - this.chunkPos);
          if (e >= this.chunk2Pos && t <= this.chunk2Pos + this.chunk2.length)
            return this.chunk2.slice(e - this.chunk2Pos, t - this.chunk2Pos);
          if (e >= this.range.from && t <= this.range.to)
            return this.input.read(e, t);
          let i = "";
          for (let r of this.ranges) {
            if (r.from >= t) break;
            r.to > e &&
              (i += this.input.read(Math.max(r.from, e), Math.min(r.to, t)));
          }
          return i;
        }
      }
      class si {
        constructor(e, t) {
          (this.data = e), (this.id = t);
        }
        token(e, t) {
          let { parser: i } = t.p;
          Wu(this.data, e, t, this.id, i.data, i.tokenPrecTable);
        }
      }
      si.prototype.contextual =
        si.prototype.fallback =
        si.prototype.extend =
          !1;
      class kr {
        constructor(e, t, i) {
          (this.precTable = t),
            (this.elseToken = i),
            (this.data = typeof e == "string" ? Ri(e) : e);
        }
        token(e, t) {
          let i = e.pos,
            r = 0;
          for (;;) {
            let s = e.next < 0,
              o = e.resolveOffset(1, 1);
            if (
              (Wu(this.data, e, t, 0, this.data, this.precTable),
              e.token.value > -1)
            )
              break;
            if (this.elseToken == null) return;
            if ((s || r++, o == null)) break;
            e.reset(o, e.token);
          }
          r && (e.reset(i, e.token), e.acceptToken(this.elseToken, r));
        }
      }
      kr.prototype.contextual =
        si.prototype.fallback =
        si.prototype.extend =
          !1;
      class Xe {
        constructor(e, t = {}) {
          (this.token = e),
            (this.contextual = !!t.contextual),
            (this.fallback = !!t.fallback),
            (this.extend = !!t.extend);
        }
      }
      function Wu(n, e, t, i, r, s) {
        let o = 0,
          l = 1 << i,
          { dialect: a } = t.p.parser;
        e: for (; (l & n[o]) != 0; ) {
          let h = n[o + 1];
          for (let d = o + 3; d < h; d += 2)
            if ((n[d + 1] & l) > 0) {
              let O = n[d];
              if (
                a.allows(O) &&
                (e.token.value == -1 ||
                  e.token.value == O ||
                  LS(O, e.token.value, r, s))
              ) {
                e.acceptToken(O);
                break;
              }
            }
          let c = e.next,
            f = 0,
            u = n[o + 2];
          if (e.next < 0 && u > f && n[h + u * 3 - 3] == 65535) {
            o = n[h + u * 3 - 1];
            continue e;
          }
          for (; f < u; ) {
            let d = (f + u) >> 1,
              O = h + d + (d << 1),
              m = n[O],
              g = n[O + 1] || 65536;
            if (c < m) u = d;
            else if (c >= g) f = d + 1;
            else {
              (o = n[O + 2]), e.advance();
              continue e;
            }
          }
          break;
        }
      }
      function gh(n, e, t) {
        for (let i = e, r; (r = n[i]) != 65535; i++) if (r == t) return i - e;
        return -1;
      }
      function LS(n, e, t, i) {
        let r = gh(t, i, e);
        return r < 0 || gh(t, i, n) < r;
      }
      const Te = typeof process < "u" && Oh && /\bparse\b/.test(Oh.LOG);
      let Ss = null;
      function Qh(n, e, t) {
        let i = n.cursor(N.IncludeAnonymous);
        for (i.moveTo(e); ; )
          if (!(t < 0 ? i.childBefore(e) : i.childAfter(e)))
            for (;;) {
              if ((t < 0 ? i.to < e : i.from > e) && !i.type.isError)
                return t < 0
                  ? Math.max(0, Math.min(i.to - 1, e - 25))
                  : Math.min(n.length, Math.max(i.from + 1, e + 25));
              if (t < 0 ? i.prevSibling() : i.nextSibling()) break;
              if (!i.parent()) return t < 0 ? 0 : n.length;
            }
      }
      class jS {
        constructor(e, t) {
          (this.fragments = e),
            (this.nodeSet = t),
            (this.i = 0),
            (this.fragment = null),
            (this.safeFrom = -1),
            (this.safeTo = -1),
            (this.trees = []),
            (this.start = []),
            (this.index = []),
            this.nextFragment();
        }
        nextFragment() {
          let e = (this.fragment =
            this.i == this.fragments.length ? null : this.fragments[this.i++]);
          if (e) {
            for (
              this.safeFrom = e.openStart
                ? Qh(e.tree, e.from + e.offset, 1) - e.offset
                : e.from,
                this.safeTo = e.openEnd
                  ? Qh(e.tree, e.to + e.offset, -1) - e.offset
                  : e.to;
              this.trees.length;

            )
              this.trees.pop(), this.start.pop(), this.index.pop();
            this.trees.push(e.tree),
              this.start.push(-e.offset),
              this.index.push(0),
              (this.nextStart = this.safeFrom);
          } else this.nextStart = 1e9;
        }
        nodeAt(e) {
          if (e < this.nextStart) return null;
          for (; this.fragment && this.safeTo <= e; ) this.nextFragment();
          if (!this.fragment) return null;
          for (;;) {
            let t = this.trees.length - 1;
            if (t < 0) return this.nextFragment(), null;
            let i = this.trees[t],
              r = this.index[t];
            if (r == i.children.length) {
              this.trees.pop(), this.start.pop(), this.index.pop();
              continue;
            }
            let s = i.children[r],
              o = this.start[t] + i.positions[r];
            if (o > e) return (this.nextStart = o), null;
            if (s instanceof K) {
              if (o == e) {
                if (o < this.safeFrom) return null;
                let l = o + s.length;
                if (l <= this.safeTo) {
                  let a = s.prop(Y.lookAhead);
                  if (!a || l + a < this.fragment.to) return s;
                }
              }
              this.index[t]++,
                o + s.length >= Math.max(this.safeFrom, e) &&
                  (this.trees.push(s), this.start.push(o), this.index.push(0));
            } else this.index[t]++, (this.nextStart = o + s.length);
          }
        }
      }
      class BS {
        constructor(e, t) {
          (this.stream = t),
            (this.tokens = []),
            (this.mainToken = null),
            (this.actions = []),
            (this.tokens = e.tokenizers.map((i) => new Fn()));
        }
        getActions(e) {
          let t = 0,
            i = null,
            { parser: r } = e.p,
            { tokenizers: s } = r,
            o = r.stateSlot(e.state, 3),
            l = e.curContext ? e.curContext.hash : 0,
            a = 0;
          for (let h = 0; h < s.length; h++) {
            if (((1 << h) & o) == 0) continue;
            let c = s[h],
              f = this.tokens[h];
            if (
              !(i && !c.fallback) &&
              ((c.contextual ||
                f.start != e.pos ||
                f.mask != o ||
                f.context != l) &&
                (this.updateCachedToken(f, c, e),
                (f.mask = o),
                (f.context = l)),
              f.lookAhead > f.end + 25 && (a = Math.max(f.lookAhead, a)),
              f.value != 0)
            ) {
              let u = t;
              if (
                (f.extended > -1 &&
                  (t = this.addActions(e, f.extended, f.end, t)),
                (t = this.addActions(e, f.value, f.end, t)),
                !c.extend && ((i = f), t > u))
              )
                break;
            }
          }
          for (; this.actions.length > t; ) this.actions.pop();
          return (
            a && e.setLookAhead(a),
            !i &&
              e.pos == this.stream.end &&
              ((i = new Fn()),
              (i.value = e.p.parser.eofTerm),
              (i.start = i.end = e.pos),
              (t = this.addActions(e, i.value, i.end, t))),
            (this.mainToken = i),
            this.actions
          );
        }
        getMainToken(e) {
          if (this.mainToken) return this.mainToken;
          let t = new Fn(),
            { pos: i, p: r } = e;
          return (
            (t.start = i),
            (t.end = Math.min(i + 1, r.stream.end)),
            (t.value = i == r.stream.end ? r.parser.eofTerm : 0),
            t
          );
        }
        updateCachedToken(e, t, i) {
          let r = this.stream.clipPos(i.pos);
          if ((t.token(this.stream.reset(r, e), i), e.value > -1)) {
            let { parser: s } = i.p;
            for (let o = 0; o < s.specialized.length; o++)
              if (s.specialized[o] == e.value) {
                let l = s.specializers[o](this.stream.read(e.start, e.end), i);
                if (l >= 0 && i.p.parser.dialect.allows(l >> 1)) {
                  (l & 1) == 0 ? (e.value = l >> 1) : (e.extended = l >> 1);
                  break;
                }
              }
          } else (e.value = 0), (e.end = this.stream.clipPos(r + 1));
        }
        putAction(e, t, i, r) {
          for (let s = 0; s < r; s += 3) if (this.actions[s] == e) return r;
          return (
            (this.actions[r++] = e),
            (this.actions[r++] = t),
            (this.actions[r++] = i),
            r
          );
        }
        addActions(e, t, i, r) {
          let { state: s } = e,
            { parser: o } = e.p,
            { data: l } = o;
          for (let a = 0; a < 2; a++)
            for (let h = o.stateSlot(s, a ? 2 : 1); ; h += 3) {
              if (l[h] == 65535)
                if (l[h + 1] == 1) h = ft(l, h + 2);
                else {
                  r == 0 &&
                    l[h + 1] == 2 &&
                    (r = this.putAction(ft(l, h + 2), t, i, r));
                  break;
                }
              l[h] == t && (r = this.putAction(ft(l, h + 1), t, i, r));
            }
          return r;
        }
      }
      class IS {
        constructor(e, t, i, r) {
          (this.parser = e),
            (this.input = t),
            (this.ranges = r),
            (this.recovering = 0),
            (this.nextStackID = 9812),
            (this.minStackPos = 0),
            (this.reused = []),
            (this.stoppedAt = null),
            (this.lastBigReductionStart = -1),
            (this.lastBigReductionSize = 0),
            (this.bigReductionCount = 0),
            (this.stream = new WS(t, r)),
            (this.tokens = new BS(e, this.stream)),
            (this.topTerm = e.top[1]);
          let { from: s } = r[0];
          (this.stacks = [xr.start(this, e.top[0], s)]),
            (this.fragments =
              i.length && this.stream.end - s > e.bufferLength * 4
                ? new jS(i, e.nodeSet)
                : null);
        }
        get parsedPos() {
          return this.minStackPos;
        }
        advance() {
          let e = this.stacks,
            t = this.minStackPos,
            i = (this.stacks = []),
            r,
            s;
          if (this.bigReductionCount > 300 && e.length == 1) {
            let [o] = e;
            for (
              ;
              o.forceReduce() &&
              o.stack.length &&
              o.stack[o.stack.length - 2] >= this.lastBigReductionStart;

            );
            this.bigReductionCount = this.lastBigReductionSize = 0;
          }
          for (let o = 0; o < e.length; o++) {
            let l = e[o];
            for (;;) {
              if (((this.tokens.mainToken = null), l.pos > t)) i.push(l);
              else {
                if (this.advanceStack(l, i, e)) continue;
                {
                  r || ((r = []), (s = [])), r.push(l);
                  let a = this.tokens.getMainToken(l);
                  s.push(a.value, a.end);
                }
              }
              break;
            }
          }
          if (!i.length) {
            let o = r && NS(r);
            if (o)
              return (
                Te && console.log("Finish with " + this.stackID(o)),
                this.stackToTree(o)
              );
            if (this.parser.strict)
              throw (
                (Te &&
                  r &&
                  console.log(
                    "Stuck with token " +
                      (this.tokens.mainToken
                        ? this.parser.getName(this.tokens.mainToken.value)
                        : "none")
                  ),
                new SyntaxError("No parse at " + t))
              );
            this.recovering || (this.recovering = 5);
          }
          if (this.recovering && r) {
            let o =
              this.stoppedAt != null && r[0].pos > this.stoppedAt
                ? r[0]
                : this.runRecovery(r, s, i);
            if (o)
              return (
                Te && console.log("Force-finish " + this.stackID(o)),
                this.stackToTree(o.forceAll())
              );
          }
          if (this.recovering) {
            let o = this.recovering == 1 ? 1 : this.recovering * 3;
            if (i.length > o)
              for (i.sort((l, a) => a.score - l.score); i.length > o; ) i.pop();
            i.some((l) => l.reducePos > t) && this.recovering--;
          } else if (i.length > 1) {
            e: for (let o = 0; o < i.length - 1; o++) {
              let l = i[o];
              for (let a = o + 1; a < i.length; a++) {
                let h = i[a];
                if (
                  l.sameState(h) ||
                  (l.buffer.length > 500 && h.buffer.length > 500)
                )
                  if (
                    (l.score - h.score || l.buffer.length - h.buffer.length) > 0
                  )
                    i.splice(a--, 1);
                  else {
                    i.splice(o--, 1);
                    continue e;
                  }
              }
            }
            i.length > 12 && i.splice(12, i.length - 12);
          }
          this.minStackPos = i[0].pos;
          for (let o = 1; o < i.length; o++)
            i[o].pos < this.minStackPos && (this.minStackPos = i[o].pos);
          return null;
        }
        stopAt(e) {
          if (this.stoppedAt != null && this.stoppedAt < e)
            throw new RangeError("Can't move stoppedAt forward");
          this.stoppedAt = e;
        }
        advanceStack(e, t, i) {
          let r = e.pos,
            { parser: s } = this,
            o = Te ? this.stackID(e) + " -> " : "";
          if (this.stoppedAt != null && r > this.stoppedAt)
            return e.forceReduce() ? e : null;
          if (this.fragments) {
            let h = e.curContext && e.curContext.tracker.strict,
              c = h ? e.curContext.hash : 0;
            for (let f = this.fragments.nodeAt(r); f; ) {
              let u =
                this.parser.nodeSet.types[f.type.id] == f.type
                  ? s.getGoto(e.state, f.type.id)
                  : -1;
              if (
                u > -1 &&
                f.length &&
                (!h || (f.prop(Y.contextHash) || 0) == c)
              )
                return (
                  e.useNode(f, u),
                  Te &&
                    console.log(
                      o +
                        this.stackID(e) +
                        ` (via reuse of ${s.getName(f.type.id)})`
                    ),
                  !0
                );
              if (
                !(f instanceof K) ||
                f.children.length == 0 ||
                f.positions[0] > 0
              )
                break;
              let d = f.children[0];
              if (d instanceof K && f.positions[0] == 0) f = d;
              else break;
            }
          }
          let l = s.stateSlot(e.state, 4);
          if (l > 0)
            return (
              e.reduce(l),
              Te &&
                console.log(
                  o +
                    this.stackID(e) +
                    ` (via always-reduce ${s.getName(l & 65535)})`
                ),
              !0
            );
          if (e.stack.length >= 8400)
            for (; e.stack.length > 6e3 && e.forceReduce(); );
          let a = this.tokens.getActions(e);
          for (let h = 0; h < a.length; ) {
            let c = a[h++],
              f = a[h++],
              u = a[h++],
              d = h == a.length || !i,
              O = d ? e : e.split(),
              m = this.tokens.mainToken;
            if (
              (O.apply(c, f, m ? m.start : O.pos, u),
              Te &&
                console.log(
                  o +
                    this.stackID(O) +
                    ` (via ${
                      (c & 65536) == 0
                        ? "shift"
                        : `reduce of ${s.getName(c & 65535)}`
                    } for ${s.getName(f)} @ ${r}${O == e ? "" : ", split"})`
                ),
              d)
            )
              return !0;
            O.pos > r ? t.push(O) : i.push(O);
          }
          return !1;
        }
        advanceFully(e, t) {
          let i = e.pos;
          for (;;) {
            if (!this.advanceStack(e, null, null)) return !1;
            if (e.pos > i) return Sh(e, t), !0;
          }
        }
        runRecovery(e, t, i) {
          let r = null,
            s = !1;
          for (let o = 0; o < e.length; o++) {
            let l = e[o],
              a = t[o << 1],
              h = t[(o << 1) + 1],
              c = Te ? this.stackID(l) + " -> " : "";
            if (
              l.deadEnd &&
              (s ||
                ((s = !0),
                l.restart(),
                Te && console.log(c + this.stackID(l) + " (restarted)"),
                this.advanceFully(l, i)))
            )
              continue;
            let f = l.split(),
              u = c;
            for (
              let d = 0;
              f.forceReduce() &&
              d < 10 &&
              (Te && console.log(u + this.stackID(f) + " (via force-reduce)"),
              !this.advanceFully(f, i));
              d++
            )
              Te && (u = this.stackID(f) + " -> ");
            for (let d of l.recoverByInsert(a))
              Te && console.log(c + this.stackID(d) + " (via recover-insert)"),
                this.advanceFully(d, i);
            this.stream.end > l.pos
              ? (h == l.pos && (h++, (a = 0)),
                l.recoverByDelete(a, h),
                Te &&
                  console.log(
                    c +
                      this.stackID(l) +
                      ` (via recover-delete ${this.parser.getName(a)})`
                  ),
                Sh(l, i))
              : (!r || r.score < l.score) && (r = l);
          }
          return r;
        }
        stackToTree(e) {
          return (
            e.close(),
            K.build({
              buffer: wr.create(e),
              nodeSet: this.parser.nodeSet,
              topID: this.topTerm,
              maxBufferLength: this.parser.bufferLength,
              reused: this.reused,
              start: this.ranges[0].from,
              length: e.pos - this.ranges[0].from,
              minRepeatType: this.parser.minRepeatTerm,
            })
          );
        }
        stackID(e) {
          let t = (Ss || (Ss = new WeakMap())).get(e);
          return (
            t || Ss.set(e, (t = String.fromCodePoint(this.nextStackID++))),
            t + e
          );
        }
      }
      function Sh(n, e) {
        for (let t = 0; t < e.length; t++) {
          let i = e[t];
          if (i.pos == n.pos && i.sameState(n)) {
            e[t].score < n.score && (e[t] = n);
            return;
          }
        }
        e.push(n);
      }
      class GS {
        constructor(e, t, i) {
          (this.source = e), (this.flags = t), (this.disabled = i);
        }
        allows(e) {
          return !this.disabled || this.disabled[e] == 0;
        }
      }
      const ys = (n) => n;
      class Lu {
        constructor(e) {
          (this.start = e.start),
            (this.shift = e.shift || ys),
            (this.reduce = e.reduce || ys),
            (this.reuse = e.reuse || ys),
            (this.hash = e.hash || (() => 0)),
            (this.strict = e.strict !== !1);
        }
      }
      class Oi extends yf {
        constructor(e) {
          if ((super(), (this.wrappers = []), e.version != 14))
            throw new RangeError(
              `Parser version (${e.version}) doesn't match runtime version (14)`
            );
          let t = e.nodeNames.split(" ");
          this.minRepeatTerm = t.length;
          for (let l = 0; l < e.repeatNodeCount; l++) t.push("");
          let i = Object.keys(e.topRules).map((l) => e.topRules[l][1]),
            r = [];
          for (let l = 0; l < t.length; l++) r.push([]);
          function s(l, a, h) {
            r[l].push([a, a.deserialize(String(h))]);
          }
          if (e.nodeProps)
            for (let l of e.nodeProps) {
              let a = l[0];
              typeof a == "string" && (a = Y[a]);
              for (let h = 1; h < l.length; ) {
                let c = l[h++];
                if (c >= 0) s(c, a, l[h++]);
                else {
                  let f = l[h + -c];
                  for (let u = -c; u > 0; u--) s(l[h++], a, f);
                  h++;
                }
              }
            }
          (this.nodeSet = new jo(
            t.map((l, a) =>
              Se.define({
                name: a >= this.minRepeatTerm ? void 0 : l,
                id: a,
                props: r[a],
                top: i.indexOf(a) > -1,
                error: a == 0,
                skipped: e.skippedNodes && e.skippedNodes.indexOf(a) > -1,
              })
            )
          )),
            e.propSources &&
              (this.nodeSet = this.nodeSet.extend(...e.propSources)),
            (this.strict = !1),
            (this.bufferLength = pf);
          let o = Ri(e.tokenData);
          (this.context = e.context),
            (this.specializerSpecs = e.specialized || []),
            (this.specialized = new Uint16Array(this.specializerSpecs.length));
          for (let l = 0; l < this.specializerSpecs.length; l++)
            this.specialized[l] = this.specializerSpecs[l].term;
          (this.specializers = this.specializerSpecs.map(yh)),
            (this.states = Ri(e.states, Uint32Array)),
            (this.data = Ri(e.stateData)),
            (this.goto = Ri(e.goto)),
            (this.maxTerm = e.maxTerm),
            (this.tokenizers = e.tokenizers.map((l) =>
              typeof l == "number" ? new si(o, l) : l
            )),
            (this.topRules = e.topRules),
            (this.dialects = e.dialects || {}),
            (this.dynamicPrecedences = e.dynamicPrecedences || null),
            (this.tokenPrecTable = e.tokenPrec),
            (this.termNames = e.termNames || null),
            (this.maxNode = this.nodeSet.types.length - 1),
            (this.dialect = this.parseDialect()),
            (this.top = this.topRules[Object.keys(this.topRules)[0]]);
        }
        createParse(e, t, i) {
          let r = new IS(this, e, t, i);
          for (let s of this.wrappers) r = s(r, e, t, i);
          return r;
        }
        getGoto(e, t, i = !1) {
          let r = this.goto;
          if (t >= r[0]) return -1;
          for (let s = r[t + 1]; ; ) {
            let o = r[s++],
              l = o & 1,
              a = r[s++];
            if (l && i) return a;
            for (let h = s + (o >> 1); s < h; s++) if (r[s] == e) return a;
            if (l) return -1;
          }
        }
        hasAction(e, t) {
          let i = this.data;
          for (let r = 0; r < 2; r++)
            for (let s = this.stateSlot(e, r ? 2 : 1), o; ; s += 3) {
              if ((o = i[s]) == 65535)
                if (i[s + 1] == 1) o = i[(s = ft(i, s + 2))];
                else {
                  if (i[s + 1] == 2) return ft(i, s + 2);
                  break;
                }
              if (o == t || o == 0) return ft(i, s + 1);
            }
          return 0;
        }
        stateSlot(e, t) {
          return this.states[e * 6 + t];
        }
        stateFlag(e, t) {
          return (this.stateSlot(e, 0) & t) > 0;
        }
        validAction(e, t) {
          return !!this.allActions(e, (i) => (i == t ? !0 : null));
        }
        allActions(e, t) {
          let i = this.stateSlot(e, 4),
            r = i ? t(i) : void 0;
          for (let s = this.stateSlot(e, 1); r == null; s += 3) {
            if (this.data[s] == 65535)
              if (this.data[s + 1] == 1) s = ft(this.data, s + 2);
              else break;
            r = t(ft(this.data, s + 1));
          }
          return r;
        }
        nextStates(e) {
          let t = [];
          for (let i = this.stateSlot(e, 1); ; i += 3) {
            if (this.data[i] == 65535)
              if (this.data[i + 1] == 1) i = ft(this.data, i + 2);
              else break;
            if ((this.data[i + 2] & 1) == 0) {
              let r = this.data[i + 1];
              t.some((s, o) => o & 1 && s == r) || t.push(this.data[i], r);
            }
          }
          return t;
        }
        configure(e) {
          let t = Object.assign(Object.create(Oi.prototype), this);
          if (
            (e.props && (t.nodeSet = this.nodeSet.extend(...e.props)), e.top)
          ) {
            let i = this.topRules[e.top];
            if (!i) throw new RangeError(`Invalid top rule name ${e.top}`);
            t.top = i;
          }
          return (
            e.tokenizers &&
              (t.tokenizers = this.tokenizers.map((i) => {
                let r = e.tokenizers.find((s) => s.from == i);
                return r ? r.to : i;
              })),
            e.specializers &&
              ((t.specializers = this.specializers.slice()),
              (t.specializerSpecs = this.specializerSpecs.map((i, r) => {
                let s = e.specializers.find((l) => l.from == i.external);
                if (!s) return i;
                let o = Object.assign(Object.assign({}, i), { external: s.to });
                return (t.specializers[r] = yh(o)), o;
              }))),
            e.contextTracker && (t.context = e.contextTracker),
            e.dialect && (t.dialect = this.parseDialect(e.dialect)),
            e.strict != null && (t.strict = e.strict),
            e.wrap && (t.wrappers = t.wrappers.concat(e.wrap)),
            e.bufferLength != null && (t.bufferLength = e.bufferLength),
            t
          );
        }
        hasWrappers() {
          return this.wrappers.length > 0;
        }
        getName(e) {
          return this.termNames
            ? this.termNames[e]
            : String((e <= this.maxNode && this.nodeSet.types[e].name) || e);
        }
        get eofTerm() {
          return this.maxNode + 1;
        }
        get topNode() {
          return this.nodeSet.types[this.top[1]];
        }
        dynamicPrecedence(e) {
          let t = this.dynamicPrecedences;
          return t == null ? 0 : t[e] || 0;
        }
        parseDialect(e) {
          let t = Object.keys(this.dialects),
            i = t.map(() => !1);
          if (e)
            for (let s of e.split(" ")) {
              let o = t.indexOf(s);
              o >= 0 && (i[o] = !0);
            }
          let r = null;
          for (let s = 0; s < t.length; s++)
            if (!i[s])
              for (
                let o = this.dialects[t[s]], l;
                (l = this.data[o++]) != 65535;

              )
                (r || (r = new Uint8Array(this.maxTerm + 1)))[l] = 1;
          return new GS(e, i, r);
        }
        static deserialize(e) {
          return new Oi(e);
        }
      }
      function ft(n, e) {
        return n[e] | (n[e + 1] << 16);
      }
      function NS(n) {
        let e = null;
        for (let t of n) {
          let i = t.p.stoppedAt;
          (t.pos == t.p.stream.end || (i != null && t.pos > i)) &&
            t.p.parser.stateFlag(t.state, 2) &&
            (!e || e.score < t.score) &&
            (e = t);
        }
        return e;
      }
      function yh(n) {
        if (n.external) {
          let e = n.extend ? 1 : 0;
          return (t, i) => (n.external(t, i) << 1) | e;
        }
        return n.get;
      }
      const US = 54,
        FS = 1,
        HS = 55,
        KS = 2,
        JS = 56,
        e1 = 3,
        bh = 4,
        t1 = 5,
        $r = 6,
        ju = 7,
        Bu = 8,
        Iu = 9,
        Gu = 10,
        i1 = 11,
        n1 = 12,
        r1 = 13,
        bs = 57,
        s1 = 14,
        xh = 58,
        Nu = 20,
        o1 = 22,
        Uu = 23,
        l1 = 24,
        $o = 26,
        Fu = 27,
        a1 = 28,
        h1 = 31,
        c1 = 34,
        f1 = 36,
        u1 = 37,
        d1 = 0,
        O1 = 1,
        p1 = {
          area: !0,
          base: !0,
          br: !0,
          col: !0,
          command: !0,
          embed: !0,
          frame: !0,
          hr: !0,
          img: !0,
          input: !0,
          keygen: !0,
          link: !0,
          meta: !0,
          param: !0,
          source: !0,
          track: !0,
          wbr: !0,
          menuitem: !0,
        },
        m1 = {
          dd: !0,
          li: !0,
          optgroup: !0,
          option: !0,
          p: !0,
          rp: !0,
          rt: !0,
          tbody: !0,
          td: !0,
          tfoot: !0,
          th: !0,
          tr: !0,
        },
        wh = {
          dd: { dd: !0, dt: !0 },
          dt: { dd: !0, dt: !0 },
          li: { li: !0 },
          option: { option: !0, optgroup: !0 },
          optgroup: { optgroup: !0 },
          p: {
            address: !0,
            article: !0,
            aside: !0,
            blockquote: !0,
            dir: !0,
            div: !0,
            dl: !0,
            fieldset: !0,
            footer: !0,
            form: !0,
            h1: !0,
            h2: !0,
            h3: !0,
            h4: !0,
            h5: !0,
            h6: !0,
            header: !0,
            hgroup: !0,
            hr: !0,
            menu: !0,
            nav: !0,
            ol: !0,
            p: !0,
            pre: !0,
            section: !0,
            table: !0,
            ul: !0,
          },
          rp: { rp: !0, rt: !0 },
          rt: { rp: !0, rt: !0 },
          tbody: { tbody: !0, tfoot: !0 },
          td: { td: !0, th: !0 },
          tfoot: { tbody: !0 },
          th: { td: !0, th: !0 },
          thead: { tbody: !0, tfoot: !0 },
          tr: { tr: !0 },
        };
      function g1(n) {
        return (
          n == 45 ||
          n == 46 ||
          n == 58 ||
          (n >= 65 && n <= 90) ||
          n == 95 ||
          (n >= 97 && n <= 122) ||
          n >= 161
        );
      }
      function Hu(n) {
        return n == 9 || n == 10 || n == 13 || n == 32;
      }
      let kh = null,
        $h = null,
        Ph = 0;
      function Po(n, e) {
        let t = n.pos + e;
        if (Ph == t && $h == n) return kh;
        let i = n.peek(e);
        for (; Hu(i); ) i = n.peek(++e);
        let r = "";
        for (; g1(i); ) (r += String.fromCharCode(i)), (i = n.peek(++e));
        return (
          ($h = n),
          (Ph = t),
          (kh = r ? r.toLowerCase() : i == Q1 || i == S1 ? void 0 : null)
        );
      }
      const Ku = 60,
        Pr = 62,
        dl = 47,
        Q1 = 63,
        S1 = 33,
        y1 = 45;
      function vh(n, e) {
        (this.name = n), (this.parent = e);
      }
      const b1 = [$r, Gu, ju, Bu, Iu],
        x1 = new Lu({
          start: null,
          shift(n, e, t, i) {
            return b1.indexOf(e) > -1 ? new vh(Po(i, 1) || "", n) : n;
          },
          reduce(n, e) {
            return e == Nu && n ? n.parent : n;
          },
          reuse(n, e, t, i) {
            let r = e.type.id;
            return r == $r || r == f1 ? new vh(Po(i, 1) || "", n) : n;
          },
          strict: !1,
        }),
        w1 = new Xe(
          (n, e) => {
            if (n.next != Ku) {
              n.next < 0 && e.context && n.acceptToken(bs);
              return;
            }
            n.advance();
            let t = n.next == dl;
            t && n.advance();
            let i = Po(n, 0);
            if (i === void 0) return;
            if (!i) return n.acceptToken(t ? s1 : $r);
            let r = e.context ? e.context.name : null;
            if (t) {
              if (i == r) return n.acceptToken(i1);
              if (r && m1[r]) return n.acceptToken(bs, -2);
              if (e.dialectEnabled(d1)) return n.acceptToken(n1);
              for (let s = e.context; s; s = s.parent) if (s.name == i) return;
              n.acceptToken(r1);
            } else {
              if (i == "script") return n.acceptToken(ju);
              if (i == "style") return n.acceptToken(Bu);
              if (i == "textarea") return n.acceptToken(Iu);
              if (p1.hasOwnProperty(i)) return n.acceptToken(Gu);
              r && wh[r] && wh[r][i]
                ? n.acceptToken(bs, -1)
                : n.acceptToken($r);
            }
          },
          { contextual: !0 }
        ),
        k1 = new Xe((n) => {
          for (let e = 0, t = 0; ; t++) {
            if (n.next < 0) {
              t && n.acceptToken(xh);
              break;
            }
            if (n.next == y1) e++;
            else if (n.next == Pr && e >= 2) {
              t >= 3 && n.acceptToken(xh, -2);
              break;
            } else e = 0;
            n.advance();
          }
        });
      function $1(n) {
        for (; n; n = n.parent)
          if (n.name == "svg" || n.name == "math") return !0;
        return !1;
      }
      const P1 = new Xe((n, e) => {
        if (n.next == dl && n.peek(1) == Pr) {
          let t = e.dialectEnabled(O1) || $1(e.context);
          n.acceptToken(t ? t1 : bh, 2);
        } else n.next == Pr && n.acceptToken(bh, 1);
      });
      function Ol(n, e, t) {
        let i = 2 + n.length;
        return new Xe((r) => {
          for (let s = 0, o = 0, l = 0; ; l++) {
            if (r.next < 0) {
              l && r.acceptToken(e);
              break;
            }
            if (
              (s == 0 && r.next == Ku) ||
              (s == 1 && r.next == dl) ||
              (s >= 2 && s < i && r.next == n.charCodeAt(s - 2))
            )
              s++, o++;
            else if ((s == 2 || s == i) && Hu(r.next)) o++;
            else if (s == i && r.next == Pr) {
              l > o ? r.acceptToken(e, -o) : r.acceptToken(t, -(o - 2));
              break;
            } else if ((r.next == 10 || r.next == 13) && l) {
              r.acceptToken(e, 1);
              break;
            } else s = o = 0;
            r.advance();
          }
        });
      }
      const v1 = Ol("script", US, FS),
        T1 = Ol("style", HS, KS),
        C1 = Ol("textarea", JS, e1),
        Z1 = zr({
          "Text RawText": p.content,
          "StartTag StartCloseTag SelfClosingEndTag EndTag": p.angleBracket,
          TagName: p.tagName,
          "MismatchedCloseTag/TagName": [p.tagName, p.invalid],
          AttributeName: p.attributeName,
          "AttributeValue UnquotedAttributeValue": p.attributeValue,
          Is: p.definitionOperator,
          "EntityReference CharacterReference": p.character,
          Comment: p.blockComment,
          ProcessingInst: p.processingInstruction,
          DoctypeDecl: p.documentMeta,
        }),
        A1 = Oi.deserialize({
          version: 14,
          states:
            ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%ZQ&rO,59fO%fQ&rO,59iO%qQ&rO,59lO%|Q&rO,59nOOOa'#D^'#D^O&XOaO'#CxO&dOaO,59[OOOb'#D_'#D_O&lObO'#C{O&wObO,59[OOOd'#D`'#D`O'POdO'#DOO'[OdO,59[OOO`'#Da'#DaO'dO!rO,59[O'kQ#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'pO$fO,59oOOO`,59o,59oO'xQ#|O,59qO'}Q#|O,59rOOO`-E7W-E7WO(SQ&rO'#CsOOQW'#DZ'#DZO(bQ&rO1G.wOOOa1G.w1G.wOOO`1G/Y1G/YO(mQ&rO1G/QOOOb1G/Q1G/QO(xQ&rO1G/TOOOd1G/T1G/TO)TQ&rO1G/WOOO`1G/W1G/WO)`Q&rO1G/YOOOa-E7[-E7[O)kQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)pQ#tO'#C|OOOd-E7^-E7^O)uQ#tO'#DPOOO`-E7_-E7_O)zQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O*PQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOO`7+$t7+$tOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rO*[Q#|O,59eO*aQ#|O,59hO*fQ#|O,59kOOO`1G/X1G/XO*kO7[O'#CvO*|OMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O+_O7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+pOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
          stateData:
            ",]~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OT}OhyO~OS!POT}OhyO~OS!ROT}OhyO~OS!TOT}OhyO~OS}OT}OhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXTgXhgX~OS!fOT!gOhyO~OS!hOT!gOhyO~OS!iOT!gOhyO~OS!jOT!gOhyO~OS!gOT!gOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
          goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
          nodeNames:
            " StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
          maxTerm: 67,
          context: x1,
          nodeProps: [
            [
              "closedBy",
              -10,
              1,
              2,
              3,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              "EndTag",
              6,
              "EndTag SelfClosingEndTag",
              -4,
              21,
              30,
              33,
              36,
              "CloseTag",
            ],
            [
              "openedBy",
              4,
              "StartTag StartCloseTag",
              5,
              "StartTag",
              -4,
              29,
              32,
              35,
              37,
              "OpenTag",
            ],
            [
              "group",
              -9,
              14,
              17,
              18,
              19,
              20,
              39,
              40,
              41,
              42,
              "Entity",
              16,
              "Entity TextContent",
              -3,
              28,
              31,
              34,
              "TextContent Entity",
            ],
            [
              "isolate",
              -11,
              21,
              29,
              30,
              32,
              33,
              35,
              36,
              37,
              38,
              41,
              42,
              "ltr",
              -3,
              26,
              27,
              39,
              "",
            ],
          ],
          propSources: [Z1],
          skippedNodes: [0],
          repeatNodeCount: 9,
          tokenData:
            "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
          tokenizers: [v1, T1, C1, P1, w1, k1, 0, 1, 2, 3, 4, 5],
          topRules: { Document: [0, 15] },
          dialects: { noMatch: 0, selfClosing: 509 },
          tokenPrec: 511,
        });
      function Ju(n, e) {
        let t = Object.create(null);
        for (let i of n.getChildren(Uu)) {
          let r = i.getChild(l1),
            s = i.getChild($o) || i.getChild(Fu);
          r &&
            (t[e.read(r.from, r.to)] = s
              ? s.type.id == $o
                ? e.read(s.from + 1, s.to - 1)
                : e.read(s.from, s.to)
              : "");
        }
        return t;
      }
      function Th(n, e) {
        let t = n.getChild(o1);
        return t ? e.read(t.from, t.to) : " ";
      }
      function xs(n, e, t) {
        let i;
        for (let r of t)
          if (!r.attrs || r.attrs(i || (i = Ju(n.node.parent.firstChild, e))))
            return { parser: r.parser };
        return null;
      }
      function ed(n = [], e = []) {
        let t = [],
          i = [],
          r = [],
          s = [];
        for (let l of n)
          (l.tag == "script"
            ? t
            : l.tag == "style"
            ? i
            : l.tag == "textarea"
            ? r
            : s
          ).push(l);
        let o = e.length ? Object.create(null) : null;
        for (let l of e) (o[l.name] || (o[l.name] = [])).push(l);
        return Zm((l, a) => {
          let h = l.type.id;
          if (h == a1) return xs(l, a, t);
          if (h == h1) return xs(l, a, i);
          if (h == c1) return xs(l, a, r);
          if (h == Nu && s.length) {
            let c = l.node,
              f = c.firstChild,
              u = f && Th(f, a),
              d;
            if (u) {
              for (let O of s)
                if (O.tag == u && (!O.attrs || O.attrs(d || (d = Ju(f, a))))) {
                  let m = c.lastChild,
                    g = m.type.id == u1 ? m.from : c.to;
                  if (g > f.to)
                    return {
                      parser: O.parser,
                      overlay: [{ from: f.to, to: g }],
                    };
                }
            }
          }
          if (o && h == Uu) {
            let c = l.node,
              f;
            if ((f = c.firstChild)) {
              let u = o[a.read(f.from, f.to)];
              if (u)
                for (let d of u) {
                  if (d.tagName && d.tagName != Th(c.parent, a)) continue;
                  let O = c.lastChild;
                  if (O.type.id == $o) {
                    let m = O.from + 1,
                      g = O.lastChild,
                      Q = O.to - (g && g.isError ? 0 : 1);
                    if (Q > m)
                      return {
                        parser: d.parser,
                        overlay: [{ from: m, to: Q }],
                      };
                  } else if (O.type.id == Fu)
                    return {
                      parser: d.parser,
                      overlay: [{ from: O.from, to: O.to }],
                    };
                }
            }
          }
          return null;
        });
      }
      const X1 = 122,
        Ch = 1,
        R1 = 123,
        M1 = 124,
        td = 2,
        Y1 = 125,
        z1 = 3,
        D1 = 4,
        id = [
          9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196,
          8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288,
        ],
        E1 = 58,
        _1 = 40,
        nd = 95,
        V1 = 91,
        Hn = 45,
        q1 = 46,
        W1 = 35,
        L1 = 37,
        j1 = 38,
        B1 = 92,
        I1 = 10,
        G1 = 42;
      function sn(n) {
        return (n >= 65 && n <= 90) || (n >= 97 && n <= 122) || n >= 161;
      }
      function pl(n) {
        return n >= 48 && n <= 57;
      }
      function Zh(n) {
        return pl(n) || (n >= 97 && n <= 102) || (n >= 65 && n <= 70);
      }
      const rd = (n, e, t) => (i, r) => {
          for (let s = !1, o = 0, l = 0; ; l++) {
            let { next: a } = i;
            if (sn(a) || a == Hn || a == nd || (s && pl(a)))
              !s && (a != Hn || l > 0) && (s = !0),
                o === l && a == Hn && o++,
                i.advance();
            else if (a == B1 && i.peek(1) != I1) {
              if ((i.advance(), Zh(i.next))) {
                do i.advance();
                while (Zh(i.next));
                i.next == 32 && i.advance();
              } else i.next > -1 && i.advance();
              s = !0;
            } else {
              s &&
                i.acceptToken(o == 2 && r.canShift(td) ? e : a == _1 ? t : n);
              break;
            }
          }
        },
        N1 = new Xe(rd(R1, td, M1)),
        U1 = new Xe(rd(Y1, z1, D1)),
        F1 = new Xe((n) => {
          if (id.includes(n.peek(-1))) {
            let { next: e } = n;
            (sn(e) ||
              e == nd ||
              e == W1 ||
              e == q1 ||
              e == G1 ||
              e == V1 ||
              (e == E1 && sn(n.peek(1))) ||
              e == Hn ||
              e == j1) &&
              n.acceptToken(X1);
          }
        }),
        H1 = new Xe((n) => {
          if (!id.includes(n.peek(-1))) {
            let { next: e } = n;
            if ((e == L1 && (n.advance(), n.acceptToken(Ch)), sn(e))) {
              do n.advance();
              while (sn(n.next) || pl(n.next));
              n.acceptToken(Ch);
            }
          }
        }),
        K1 = zr({
          "AtKeyword import charset namespace keyframes media supports":
            p.definitionKeyword,
          "from to selector": p.keyword,
          NamespaceName: p.namespace,
          KeyframeName: p.labelName,
          KeyframeRangeName: p.operatorKeyword,
          TagName: p.tagName,
          ClassName: p.className,
          PseudoClassName: p.constant(p.className),
          IdName: p.labelName,
          "FeatureName PropertyName": p.propertyName,
          AttributeName: p.attributeName,
          NumberLiteral: p.number,
          KeywordQuery: p.keyword,
          UnaryQueryOp: p.operatorKeyword,
          "CallTag ValueName": p.atom,
          VariableName: p.variableName,
          Callee: p.operatorKeyword,
          Unit: p.unit,
          "UniversalSelector NestingSelector": p.definitionOperator,
          "MatchOp CompareOp": p.compareOperator,
          "ChildOp SiblingOp, LogicOp": p.logicOperator,
          BinOp: p.arithmeticOperator,
          Important: p.modifier,
          Comment: p.blockComment,
          ColorLiteral: p.color,
          "ParenthesizedContent StringLiteral": p.string,
          ":": p.punctuation,
          "PseudoOp #": p.derefOperator,
          "; ,": p.separator,
          "( )": p.paren,
          "[ ]": p.squareBracket,
          "{ }": p.brace,
        }),
        J1 = {
          __proto__: null,
          lang: 38,
          "nth-child": 38,
          "nth-last-child": 38,
          "nth-of-type": 38,
          "nth-last-of-type": 38,
          dir: 38,
          "host-context": 38,
          if: 84,
          url: 124,
          "url-prefix": 124,
          domain: 124,
          regexp: 124,
        },
        ey = {
          __proto__: null,
          or: 98,
          and: 98,
          not: 106,
          only: 106,
          layer: 170,
        },
        ty = { __proto__: null, selector: 112, layer: 166 },
        iy = {
          __proto__: null,
          "@import": 162,
          "@media": 174,
          "@charset": 178,
          "@namespace": 182,
          "@keyframes": 188,
          "@supports": 200,
          "@scope": 204,
        },
        ny = { __proto__: null, to: 207 },
        ry = Oi.deserialize({
          version: 14,
          states:
            "EbQYQdOOO#qQdOOP#xO`OOOOQP'#Cf'#CfOOQP'#Ce'#CeO#}QdO'#ChO$nQaO'#CcO$xQdO'#CkO%TQdO'#DpO%YQdO'#DrO%_QdO'#DuO%_QdO'#DxOOQP'#FV'#FVO&eQhO'#EhOOQS'#FU'#FUOOQS'#Ek'#EkQYQdOOO&lQdO'#EOO&PQhO'#EUO&lQdO'#EWO'aQdO'#EYO'lQdO'#E]O'tQhO'#EcO(VQdO'#EeO(bQaO'#CfO)VQ`O'#D{O)[Q`O'#F`O)gQdO'#F`QOQ`OOP)qO&jO'#CaPOOO)C@t)C@tOOQP'#Cj'#CjOOQP,59S,59SO#}QdO,59SO)|QdO,59VO%TQdO,5:[O%YQdO,5:^O%_QdO,5:aO%_QdO,5:cO%_QdO,5:dO%_QdO'#ErO*XQ`O,58}O*aQdO'#DzOOQS,58},58}OOQP'#Cn'#CnOOQO'#Dn'#DnOOQP,59V,59VO*hQ`O,59VO*mQ`O,59VOOQP'#Dq'#DqOOQP,5:[,5:[OOQO'#Ds'#DsO*rQpO,5:^O+]QaO,5:aO+sQaO,5:dOOQW'#DZ'#DZO,ZQhO'#DdO,xQhO'#FaO'tQhO'#DbO-WQ`O'#DhOOQW'#F['#F[O-]Q`O,5;SO-eQ`O'#DeOOQS-E8i-E8iOOQ['#Cs'#CsO-jQdO'#CtO.QQdO'#CzO.hQdO'#C}O/OQ!pO'#DPO1RQ!jO,5:jOOQO'#DU'#DUO*mQ`O'#DTO1cQ!nO'#FXO3`Q`O'#DVO3eQ`O'#DkOOQ['#FX'#FXO-`Q`O,5:pO3jQ!bO,5:rOOQS'#E['#E[O3rQ`O,5:tO3wQdO,5:tOOQO'#E_'#E_O4PQ`O,5:wO4UQhO,5:}O%_QdO'#DgOOQS,5;P,5;PO-eQ`O,5;PO4^QdO,5;PO4fQdO,5:gO4vQdO'#EtO5TQ`O,5;zO5TQ`O,5;zPOOO'#Ej'#EjP5`O&jO,58{POOO,58{,58{OOQP1G.n1G.nOOQP1G.q1G.qO*hQ`O1G.qO*mQ`O1G.qOOQP1G/v1G/vO5kQpO1G/xO5sQaO1G/{O6ZQaO1G/}O6qQaO1G0OO7XQaO,5;^OOQO-E8p-E8pOOQS1G.i1G.iO7cQ`O,5:fO7hQdO'#DoO7oQdO'#CrOOQP1G/x1G/xO&lQdO1G/xO7vQ!jO'#DZO8UQ!bO,59vO8^QhO,5:OOOQO'#F]'#F]O8XQ!bO,59zO'tQhO,59xO8fQhO'#EvO8sQ`O,5;{O9OQhO,59|O9uQhO'#DiOOQW,5:S,5:SOOQS1G0n1G0nOOQW,5:P,5:PO9|Q!fO'#FYOOQS'#FY'#FYOOQS'#Em'#EmO;^QdO,59`OOQ[,59`,59`O;tQdO,59fOOQ[,59f,59fO<[QdO,59iOOQ[,59i,59iOOQ[,59k,59kO&lQdO,59mO<rQhO'#EQOOQW'#EQ'#EQO=WQ`O1G0UO1[QhO1G0UOOQ[,59o,59oO'tQhO'#DXOOQ[,59q,59qO=]Q#tO,5:VOOQS1G0[1G0[OOQS1G0^1G0^OOQS1G0`1G0`O=hQ`O1G0`O=mQdO'#E`OOQS1G0c1G0cOOQS1G0i1G0iO=xQaO,5:RO-`Q`O1G0kOOQS1G0k1G0kO-eQ`O1G0kO>PQ!fO1G0ROOQO1G0R1G0ROOQO,5;`,5;`O>gQdO,5;`OOQO-E8r-E8rO>tQ`O1G1fPOOO-E8h-E8hPOOO1G.g1G.gOOQP7+$]7+$]OOQP7+%d7+%dO&lQdO7+%dOOQS1G0Q1G0QO?PQaO'#F_O?ZQ`O,5:ZO?`Q!fO'#ElO@^QdO'#FWO@hQ`O,59^O@mQ!bO7+%dO&lQdO1G/bO@uQhO1G/fOOQW1G/j1G/jOOQW1G/d1G/dOAWQhO,5;bOOQO-E8t-E8tOAfQhO'#DZOAtQhO'#F^OBPQ`O'#F^OBUQ`O,5:TOOQS-E8k-E8kOOQ[1G.z1G.zOOQ[1G/Q1G/QOOQ[1G/T1G/TOOQ[1G/X1G/XOBZQdO,5:lOOQS7+%p7+%pOB`Q`O7+%pOBeQhO'#DYOBmQ`O,59sO'tQhO,59sOOQ[1G/q1G/qOBuQ`O1G/qOOQS7+%z7+%zOBzQbO'#DPOOQO'#Eb'#EbOCYQ`O'#EaOOQO'#Ea'#EaOCeQ`O'#EwOCmQdO,5:zOOQS,5:z,5:zOOQ[1G/m1G/mOOQS7+&V7+&VO-`Q`O7+&VOCxQ!fO'#EsO&lQdO'#EsOEPQdO7+%mOOQO7+%m7+%mOOQO1G0z1G0zOEdQ!bO<<IOOElQdO'#EqOEvQ`O,5;yOOQP1G/u1G/uOOQS-E8j-E8jOFOQdO'#EpOFYQ`O,5;rOOQ]1G.x1G.xOOQP<<IO<<IOOFbQdO7+$|OOQO'#D]'#D]OFiQ!bO7+%QOFqQhO'#EoOF{Q`O,5;xO&lQdO,5;xOOQW1G/o1G/oOOQO'#ES'#ESOGTQ`O1G0WOOQS<<I[<<I[O&lQdO,59tOGnQhO1G/_OOQ[1G/_1G/_OGuQ`O1G/_OOQW-E8l-E8lOOQ[7+%]7+%]OOQO,5:{,5:{O=pQdO'#ExOCeQ`O,5;cOOQS,5;c,5;cOOQS-E8u-E8uOOQS1G0f1G0fOOQS<<Iq<<IqOG}Q!fO,5;_OOQS-E8q-E8qOOQO<<IX<<IXOOQPAN>jAN>jOIUQaO,5;]OOQO-E8o-E8oOI`QdO,5;[OOQO-E8n-E8nOOQW<<Hh<<HhOOQW<<Hl<<HlOIjQhO<<HlOI{QhO,5;ZOJWQ`O,5;ZOOQO-E8m-E8mOJ]QdO1G1dOBZQdO'#EuOJgQ`O7+%rOOQW7+%r7+%rOJoQ!bO1G/`OOQ[7+$y7+$yOJzQhO7+$yPKRQ`O'#EnOOQO,5;d,5;dOOQO-E8v-E8vOOQS1G0}1G0}OKWQ`OAN>WO&lQdO1G0uOK]Q`O7+'OOOQO,5;a,5;aOOQO-E8s-E8sOOQW<<I^<<I^OOQ[<<He<<HePOQW,5;Y,5;YOOQWG23rG23rOKeQdO7+&a",
          stateData:
            "Kx~O#sOS#tQQ~OW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#oRO~OQiOW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#ohO~O#m$SP~P!dO#tmO~O#ooO~O]qO`rOarOjsOmtO!juO!mwO#nvO~OpzO!^xO~P$SOc!QO#o|O#p}O~O#o!RO~O#o!TO~OW[OZ[O]TO`VOaVOjWOmXO!jYO!mZO#oRO~OS!]Oe!YO!V![O!Y!`O#q!XOp$TP~Ok$TP~P&POQ!jOe!cOm!dOp!eOr!mOt!mOz!kO!`!lO#o!bO#p!hO#}!fO~Ot!qO!`!lO#o!pO~Ot!sO#o!sO~OS!]Oe!YO!V![O!Y!`O#q!XO~Oe!vOpzO#Z!xO~O]YX`YX`!pXaYXjYXmYXpYX!^YX!jYX!mYX#nYX~O`!zO~Ok!{O#m$SXo$SX~O#m$SXo$SX~P!dO#u#OO#v#OO#w#QO~Oc#UO#o|O#p}O~OpzO!^xO~Oo$SP~P!dOe#`O~Oe#aO~Ol#bO!h#cO~O]qO`rOarOjsOmtO~Op!ia!^!ia!j!ia!m!ia#n!iad!ia~P*zOp!la!^!la!j!la!m!la#n!lad!la~P*zOR#gOS!]Oe!YOr#gOt#gO!V![O!Y!`O#q#dO#}!fO~O!R#iO!^#jOk$TXp$TX~Oe#mO~Ok#oOpzO~Oe!vO~O]#rO`#rOd#uOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl#wO~P&lO]#rO`#rOi#rOj#rOk#rOo#yO~P&lOP#zOSsXesXksXvsX!VsX!YsX!usX!wsX#qsX!TsXQsX]sX`sXdsXisXjsXmsXpsXrsXtsXzsX!`sX#osX#psX#}sXlsXosX!^sX!qsX#msX~Ov#{O!u#|O!w#}Ok$TP~P'tOe#aOS#{Xk#{Xv#{X!V#{X!Y#{X!u#{X!w#{X#q#{XQ#{X]#{X`#{Xd#{Xi#{Xj#{Xm#{Xp#{Xr#{Xt#{Xz#{X!`#{X#o#{X#p#{X#}#{Xl#{Xo#{X!^#{X!q#{X#m#{X~Oe$RO~Oe$TO~Ok$VOv#{O~Ok$WO~Ot$XO!`!lO~Op$YO~OpzO!R#iO~OpzO#Z$`O~O!q$bOk!oa#m!oao!oa~P&lOk#hX#m#hXo#hX~P!dOk!{O#m$Sao$Sa~O#u#OO#v#OO#w$hO~Ol$jO!h$kO~Op!ii!^!ii!j!ii!m!ii#n!iid!ii~P*zOp!ki!^!ki!j!ki!m!ki#n!kid!ki~P*zOp!li!^!li!j!li!m!li#n!lid!li~P*zOp#fa!^#fa~P$SOo$lO~Od$RP~P%_Od#zP~P&lO`!PXd}X!R}X!T!PX~O`$sO!T$tO~Od$uO!R#iO~Ok#jXp#jX!^#jX~P'tO!^#jOk$Tap$Ta~O!R#iOk!Uap!Ua!^!Uad!Ua`!Ua~OS!]Oe!YO!V![O!Y!`O#q$yO~Od$QP~P9dOv#{OQ#|X]#|X`#|Xd#|Xe#|Xi#|Xj#|Xk#|Xm#|Xp#|Xr#|Xt#|Xz#|X!`#|X#o#|X#p#|X#}#|Xl#|Xo#|X~O]#rO`#rOd%OOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl%PO~P&lO]#rO`#rOi#rOj#rOk#rOo%QO~P&lOe%SOS!tXk!tX!V!tX!Y!tX#q!tX~Ok%TO~Od%YOt%ZO!a%ZO~Ok%[O~Oo%cO#o%^O#}%]O~Od%dO~P$SOv#{O!^%hO!q%jOk!oi#m!oio!oi~P&lOk#ha#m#hao#ha~P!dOk!{O#m$Sio$Si~O!^%mOd$RX~P$SOd%oO~Ov#{OQ#`Xd#`Xe#`Xm#`Xp#`Xr#`Xt#`Xz#`X!^#`X!`#`X#o#`X#p#`X#}#`X~O!^%qOd#zX~P&lOd%sO~Ol%tOv#{O~OR#gOr#gOt#gO#q%vO#}!fO~O!R#iOk#jap#ja!^#ja~O`!PXd}X!R}X!^}X~O!R#iO!^%xOd$QX~O`%zO~Od%{O~O#o%|O~Ok&OO~O`&PO!R#iO~Od&ROk&QO~Od&UO~OP#zOpsX!^sXdsX~O#}%]Op#TX!^#TX~OpzO!^&WO~Oo&[O#o%^O#}%]O~Ov#{OQ#gXe#gXk#gXm#gXp#gXr#gXt#gXz#gX!^#gX!`#gX!q#gX#m#gX#o#gX#p#gX#}#gXo#gX~O!^%hO!q&`Ok!oq#m!oqo!oq~P&lOl&aOv#{O~Od#eX!^#eX~P%_O!^%mOd$Ra~Od#dX!^#dX~P&lO!^%qOd#za~Od&fO~P&lOd&gO!T&hO~Od#cX!^#cX~P9dO!^%xOd$Qa~O]&mOd&oO~OS#bae#ba!V#ba!Y#ba#q#ba~Od&qO~PG]Od&qOk&rO~Ov#{OQ#gae#gak#gam#gap#gar#gat#gaz#ga!^#ga!`#ga!q#ga#m#ga#o#ga#p#ga#}#gao#ga~Od#ea!^#ea~P$SOd#da!^#da~P&lOR#gOr#gOt#gO#q%vO#}%]O~O!R#iOd#ca!^#ca~O`&xO~O!^%xOd$Qi~P&lO]&mOd&|O~Ov#{Od|ik|i~Od&}O~PG]Ok'OO~Od'PO~O!^%xOd$Qq~Od#cq!^#cq~P&lO#s!a#t#}]#}v!m~",
          goto: "2h$UPPPPP$VP$YP$c$uP$cP%X$cPP%_PPP%e%o%oPPPPP%oPP%oP&]P%oP%o'W%oP't'w'}'}(^'}P'}P'}P'}'}P(m'}(yP(|PP)p)v$c)|$c*SP$cP$c$cP*Y*{+YP$YP+aP+dP$YP$YP$YP+j$YP+m+p+s+z$YP$YPP$YP,P,V,f,|-[-b-l-r-x.O.U.`.f.l.rPPPPPPPPPPP.x/R/w/z0|P1U1u2O2R2U2[RnQ_^OP`kz!{$dq[OPYZ`kuvwxz!v!{#`$d%mqSOPYZ`kuvwxz!v!{#`$d%mQpTR#RqQ!OVR#SrQ#S!QS$Q!i!jR$i#U!V!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'Q!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QU#g!Y$t&hU%`$Y%b&WR&V%_!V!iac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QR$S!kQ%W$RR&S%Xk!^]bf!Y![!g#i#j#m$P$R%X%xQ#e!YQ${#mQ%w$tQ&j%xR&w&hQ!ygQ#p!`Q$^!xR%f$`R#n!]!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QQ!qdR$X!rQ!PVR#TrQ#S!PR$i#TQ!SWR#VsQ!UXR#WtQ{UQ!wgQ#^yQ#o!_Q$U!nQ$[!uQ$_!yQ%e$^Q&Y%aQ&]%fR&v&XSjPzQ!}kQ$c!{R%k$dZiPkz!{$dR$P!gQ%}%SR&z&mR!rdR!teR$Z!tS%a$Y%bR&t&WV%_$Y%b&WQ#PmR$g#PQ`OSkPzU!a`k$dR$d!{Q$p#aY%p$p%u&d&l'QQ%u$sQ&d%qQ&l%zR'Q&xQ#t!cQ#v!dQ#x!eV$}#t#v#xQ%X$RR&T%XQ%y$zS&k%y&yR&y&lQ%r$pR&e%rQ%n$mR&c%nQyUR#]yQ%i$aR&_%iQ!|jS$e!|$fR$f!}Q&n%}R&{&nQ#k!ZR$x#kQ%b$YR&Z%bQ&X%aR&u&X__OP`kz!{$d^UOP`kz!{$dQ!VYQ!WZQ#XuQ#YvQ#ZwQ#[xQ$]!vQ$m#`R&b%mR$q#aQ!gaQ!oc[#q!c!d!e#t#v#xQ$a!zd$o#a$p$s%q%u%z&d&l&x'QQ$r#cQ%R#{S%g$a%iQ%l$kQ&^%hR&p&P]#s!c!d!e#t#v#xW!Z]b!g$PQ!ufQ#f!YQ#l![Q$v#iQ$w#jQ$z#mS%V$R%XR&i%xQ#h!YQ%w$tR&w&hR$|#mR$n#`QlPR#_zQ!_]Q!nbQ$O!gR%U$P",
          nodeNames:
            " Unit VariableName VariableName QueryCallee Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector . ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue AtKeyword # ; ] [ BracketedValue } { BracedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee IfExpression if ArgList IfBranch KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp ComparisonQuery CompareOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector ParenthesizedSelector CallQuery ArgList , CallLiteral CallTag ParenthesizedContent PseudoClassName ArgList IdSelector IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp Block Declaration PropertyName Important ImportStatement import Layer layer LayerName layer MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports ScopeStatement scope to AtRule Styles",
          maxTerm: 143,
          nodeProps: [
            ["isolate", -2, 5, 36, ""],
            ["openedBy", 20, "(", 28, "[", 31, "{"],
            ["closedBy", 21, ")", 29, "]", 32, "}"],
          ],
          propSources: [K1],
          skippedNodes: [0, 5, 106],
          repeatNodeCount: 15,
          tokenData:
            "JQ~R!YOX$qX^%i^p$qpq%iqr({rs-ust/itu6Wuv$qvw7Qwx7cxy9Qyz9cz{9h{|:R|}>t}!O?V!O!P?t!P!Q@]!Q![AU![!]BP!]!^B{!^!_C^!_!`DY!`!aDm!a!b$q!b!cEn!c!}$q!}#OG{#O#P$q#P#QH^#Q#R6W#R#o$q#o#pHo#p#q6W#q#rIQ#r#sIc#s#y$q#y#z%i#z$f$q$f$g%i$g#BY$q#BY#BZ%i#BZ$IS$q$IS$I_%i$I_$I|$q$I|$JO%i$JO$JT$q$JT$JU%i$JU$KV$q$KV$KW%i$KW&FU$q&FU&FV%i&FV;'S$q;'S;=`Iz<%lO$q`$tSOy%Qz;'S%Q;'S;=`%c<%lO%Q`%VS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q`%fP;=`<%l%Q~%nh#s~OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Q~'ah#s~!a`OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Qj)OUOy%Qz#]%Q#]#^)b#^;'S%Q;'S;=`%c<%lO%Qj)gU!a`Oy%Qz#a%Q#a#b)y#b;'S%Q;'S;=`%c<%lO%Qj*OU!a`Oy%Qz#d%Q#d#e*b#e;'S%Q;'S;=`%c<%lO%Qj*gU!a`Oy%Qz#c%Q#c#d*y#d;'S%Q;'S;=`%c<%lO%Qj+OU!a`Oy%Qz#f%Q#f#g+b#g;'S%Q;'S;=`%c<%lO%Qj+gU!a`Oy%Qz#h%Q#h#i+y#i;'S%Q;'S;=`%c<%lO%Qj,OU!a`Oy%Qz#T%Q#T#U,b#U;'S%Q;'S;=`%c<%lO%Qj,gU!a`Oy%Qz#b%Q#b#c,y#c;'S%Q;'S;=`%c<%lO%Qj-OU!a`Oy%Qz#h%Q#h#i-b#i;'S%Q;'S;=`%c<%lO%Qj-iS!qY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q~-xWOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c<%lO-u~.gOt~~.jRO;'S-u;'S;=`.s;=`O-u~.vXOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c;=`<%l-u<%lO-u~/fP;=`<%l-uj/nYjYOy%Qz!Q%Q!Q![0^![!c%Q!c!i0^!i#T%Q#T#Z0^#Z;'S%Q;'S;=`%c<%lO%Qj0cY!a`Oy%Qz!Q%Q!Q![1R![!c%Q!c!i1R!i#T%Q#T#Z1R#Z;'S%Q;'S;=`%c<%lO%Qj1WY!a`Oy%Qz!Q%Q!Q![1v![!c%Q!c!i1v!i#T%Q#T#Z1v#Z;'S%Q;'S;=`%c<%lO%Qj1}YrY!a`Oy%Qz!Q%Q!Q![2m![!c%Q!c!i2m!i#T%Q#T#Z2m#Z;'S%Q;'S;=`%c<%lO%Qj2tYrY!a`Oy%Qz!Q%Q!Q![3d![!c%Q!c!i3d!i#T%Q#T#Z3d#Z;'S%Q;'S;=`%c<%lO%Qj3iY!a`Oy%Qz!Q%Q!Q![4X![!c%Q!c!i4X!i#T%Q#T#Z4X#Z;'S%Q;'S;=`%c<%lO%Qj4`YrY!a`Oy%Qz!Q%Q!Q![5O![!c%Q!c!i5O!i#T%Q#T#Z5O#Z;'S%Q;'S;=`%c<%lO%Qj5TY!a`Oy%Qz!Q%Q!Q![5s![!c%Q!c!i5s!i#T%Q#T#Z5s#Z;'S%Q;'S;=`%c<%lO%Qj5zSrY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qd6ZUOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qd6tS!hS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qb7VSZQOy%Qz;'S%Q;'S;=`%c<%lO%Q~7fWOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z<%lO7c~8RRO;'S7c;'S;=`8[;=`O7c~8_XOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z;=`<%l7c<%lO7c~8}P;=`<%l7cj9VSeYOy%Qz;'S%Q;'S;=`%c<%lO%Q~9hOd~n9oUWQvWOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qj:YWvW!mQOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj:wU!a`Oy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Qj;bY!a`#}YOy%Qz!Q%Q!Q![;Z![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj<VY!a`Oy%Qz{%Q{|<u|}%Q}!O<u!O!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj<zU!a`Oy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj=eU!a`#}YOy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj>O[!a`#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj>yS!^YOy%Qz;'S%Q;'S;=`%c<%lO%Qj?[WvWOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj?yU]YOy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Q~@bTvWOy%Qz{@q{;'S%Q;'S;=`%c<%lO%Q~@xS!a`#t~Oy%Qz;'S%Q;'S;=`%c<%lO%QjAZ[#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%QjBUU`YOy%Qz![%Q![!]Bh!];'S%Q;'S;=`%c<%lO%QbBoSaQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjCQSkYOy%Qz;'S%Q;'S;=`%c<%lO%QhCcU!TWOy%Qz!_%Q!_!`Cu!`;'S%Q;'S;=`%c<%lO%QhC|S!TW!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QlDaS!TW!hSOy%Qz;'S%Q;'S;=`%c<%lO%QjDtV!jQ!TWOy%Qz!_%Q!_!`Cu!`!aEZ!a;'S%Q;'S;=`%c<%lO%QbEbS!jQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjEqYOy%Qz}%Q}!OFa!O!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjFfW!a`Oy%Qz!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjGV[iY!a`Oy%Qz}%Q}!OGO!O!Q%Q!Q![GO![!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjHQSmYOy%Qz;'S%Q;'S;=`%c<%lO%QnHcSl^Oy%Qz;'S%Q;'S;=`%c<%lO%QjHtSpYOy%Qz;'S%Q;'S;=`%c<%lO%QjIVSoYOy%Qz;'S%Q;'S;=`%c<%lO%QfIhU!mQOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Q`I}P;=`<%l$q",
          tokenizers: [
            F1,
            H1,
            N1,
            U1,
            1,
            2,
            3,
            4,
            new kr("m~RRYZ[z{a~~g~aO#v~~dP!P!Qg~lO#w~~", 28, 129),
          ],
          topRules: { StyleSheet: [0, 6], Styles: [1, 105] },
          specialized: [
            { term: 124, get: (n) => J1[n] || -1 },
            { term: 125, get: (n) => ey[n] || -1 },
            { term: 4, get: (n) => ty[n] || -1 },
            { term: 25, get: (n) => iy[n] || -1 },
            { term: 123, get: (n) => ny[n] || -1 },
          ],
          tokenPrec: 1963,
        });
      let ws = null;
      function ks() {
        if (!ws && typeof document == "object" && document.body) {
          let { style: n } = document.body,
            e = [],
            t = new Set();
          for (let i in n)
            i != "cssText" &&
              i != "cssFloat" &&
              typeof n[i] == "string" &&
              (/[A-Z]/.test(i) &&
                (i = i.replace(/[A-Z]/g, (r) => "-" + r.toLowerCase())),
              t.has(i) || (e.push(i), t.add(i)));
          ws = e
            .sort()
            .map((i) => ({ type: "property", label: i, apply: i + ": " }));
        }
        return ws || [];
      }
      const Ah = [
          "active",
          "after",
          "any-link",
          "autofill",
          "backdrop",
          "before",
          "checked",
          "cue",
          "default",
          "defined",
          "disabled",
          "empty",
          "enabled",
          "file-selector-button",
          "first",
          "first-child",
          "first-letter",
          "first-line",
          "first-of-type",
          "focus",
          "focus-visible",
          "focus-within",
          "fullscreen",
          "has",
          "host",
          "host-context",
          "hover",
          "in-range",
          "indeterminate",
          "invalid",
          "is",
          "lang",
          "last-child",
          "last-of-type",
          "left",
          "link",
          "marker",
          "modal",
          "not",
          "nth-child",
          "nth-last-child",
          "nth-last-of-type",
          "nth-of-type",
          "only-child",
          "only-of-type",
          "optional",
          "out-of-range",
          "part",
          "placeholder",
          "placeholder-shown",
          "read-only",
          "read-write",
          "required",
          "right",
          "root",
          "scope",
          "selection",
          "slotted",
          "target",
          "target-text",
          "valid",
          "visited",
          "where",
        ].map((n) => ({ type: "class", label: n })),
        Xh = [
          "above",
          "absolute",
          "activeborder",
          "additive",
          "activecaption",
          "after-white-space",
          "ahead",
          "alias",
          "all",
          "all-scroll",
          "alphabetic",
          "alternate",
          "always",
          "antialiased",
          "appworkspace",
          "asterisks",
          "attr",
          "auto",
          "auto-flow",
          "avoid",
          "avoid-column",
          "avoid-page",
          "avoid-region",
          "axis-pan",
          "background",
          "backwards",
          "baseline",
          "below",
          "bidi-override",
          "blink",
          "block",
          "block-axis",
          "bold",
          "bolder",
          "border",
          "border-box",
          "both",
          "bottom",
          "break",
          "break-all",
          "break-word",
          "bullets",
          "button",
          "button-bevel",
          "buttonface",
          "buttonhighlight",
          "buttonshadow",
          "buttontext",
          "calc",
          "capitalize",
          "caps-lock-indicator",
          "caption",
          "captiontext",
          "caret",
          "cell",
          "center",
          "checkbox",
          "circle",
          "cjk-decimal",
          "clear",
          "clip",
          "close-quote",
          "col-resize",
          "collapse",
          "color",
          "color-burn",
          "color-dodge",
          "column",
          "column-reverse",
          "compact",
          "condensed",
          "contain",
          "content",
          "contents",
          "content-box",
          "context-menu",
          "continuous",
          "copy",
          "counter",
          "counters",
          "cover",
          "crop",
          "cross",
          "crosshair",
          "currentcolor",
          "cursive",
          "cyclic",
          "darken",
          "dashed",
          "decimal",
          "decimal-leading-zero",
          "default",
          "default-button",
          "dense",
          "destination-atop",
          "destination-in",
          "destination-out",
          "destination-over",
          "difference",
          "disc",
          "discard",
          "disclosure-closed",
          "disclosure-open",
          "document",
          "dot-dash",
          "dot-dot-dash",
          "dotted",
          "double",
          "down",
          "e-resize",
          "ease",
          "ease-in",
          "ease-in-out",
          "ease-out",
          "element",
          "ellipse",
          "ellipsis",
          "embed",
          "end",
          "ethiopic-abegede-gez",
          "ethiopic-halehame-aa-er",
          "ethiopic-halehame-gez",
          "ew-resize",
          "exclusion",
          "expanded",
          "extends",
          "extra-condensed",
          "extra-expanded",
          "fantasy",
          "fast",
          "fill",
          "fill-box",
          "fixed",
          "flat",
          "flex",
          "flex-end",
          "flex-start",
          "footnotes",
          "forwards",
          "from",
          "geometricPrecision",
          "graytext",
          "grid",
          "groove",
          "hand",
          "hard-light",
          "help",
          "hidden",
          "hide",
          "higher",
          "highlight",
          "highlighttext",
          "horizontal",
          "hsl",
          "hsla",
          "hue",
          "icon",
          "ignore",
          "inactiveborder",
          "inactivecaption",
          "inactivecaptiontext",
          "infinite",
          "infobackground",
          "infotext",
          "inherit",
          "initial",
          "inline",
          "inline-axis",
          "inline-block",
          "inline-flex",
          "inline-grid",
          "inline-table",
          "inset",
          "inside",
          "intrinsic",
          "invert",
          "italic",
          "justify",
          "keep-all",
          "landscape",
          "large",
          "larger",
          "left",
          "level",
          "lighter",
          "lighten",
          "line-through",
          "linear",
          "linear-gradient",
          "lines",
          "list-item",
          "listbox",
          "listitem",
          "local",
          "logical",
          "loud",
          "lower",
          "lower-hexadecimal",
          "lower-latin",
          "lower-norwegian",
          "lowercase",
          "ltr",
          "luminosity",
          "manipulation",
          "match",
          "matrix",
          "matrix3d",
          "medium",
          "menu",
          "menutext",
          "message-box",
          "middle",
          "min-intrinsic",
          "mix",
          "monospace",
          "move",
          "multiple",
          "multiple_mask_images",
          "multiply",
          "n-resize",
          "narrower",
          "ne-resize",
          "nesw-resize",
          "no-close-quote",
          "no-drop",
          "no-open-quote",
          "no-repeat",
          "none",
          "normal",
          "not-allowed",
          "nowrap",
          "ns-resize",
          "numbers",
          "numeric",
          "nw-resize",
          "nwse-resize",
          "oblique",
          "opacity",
          "open-quote",
          "optimizeLegibility",
          "optimizeSpeed",
          "outset",
          "outside",
          "outside-shape",
          "overlay",
          "overline",
          "padding",
          "padding-box",
          "painted",
          "page",
          "paused",
          "perspective",
          "pinch-zoom",
          "plus-darker",
          "plus-lighter",
          "pointer",
          "polygon",
          "portrait",
          "pre",
          "pre-line",
          "pre-wrap",
          "preserve-3d",
          "progress",
          "push-button",
          "radial-gradient",
          "radio",
          "read-only",
          "read-write",
          "read-write-plaintext-only",
          "rectangle",
          "region",
          "relative",
          "repeat",
          "repeating-linear-gradient",
          "repeating-radial-gradient",
          "repeat-x",
          "repeat-y",
          "reset",
          "reverse",
          "rgb",
          "rgba",
          "ridge",
          "right",
          "rotate",
          "rotate3d",
          "rotateX",
          "rotateY",
          "rotateZ",
          "round",
          "row",
          "row-resize",
          "row-reverse",
          "rtl",
          "run-in",
          "running",
          "s-resize",
          "sans-serif",
          "saturation",
          "scale",
          "scale3d",
          "scaleX",
          "scaleY",
          "scaleZ",
          "screen",
          "scroll",
          "scrollbar",
          "scroll-position",
          "se-resize",
          "self-start",
          "self-end",
          "semi-condensed",
          "semi-expanded",
          "separate",
          "serif",
          "show",
          "single",
          "skew",
          "skewX",
          "skewY",
          "skip-white-space",
          "slide",
          "slider-horizontal",
          "slider-vertical",
          "sliderthumb-horizontal",
          "sliderthumb-vertical",
          "slow",
          "small",
          "small-caps",
          "small-caption",
          "smaller",
          "soft-light",
          "solid",
          "source-atop",
          "source-in",
          "source-out",
          "source-over",
          "space",
          "space-around",
          "space-between",
          "space-evenly",
          "spell-out",
          "square",
          "start",
          "static",
          "status-bar",
          "stretch",
          "stroke",
          "stroke-box",
          "sub",
          "subpixel-antialiased",
          "svg_masks",
          "super",
          "sw-resize",
          "symbolic",
          "symbols",
          "system-ui",
          "table",
          "table-caption",
          "table-cell",
          "table-column",
          "table-column-group",
          "table-footer-group",
          "table-header-group",
          "table-row",
          "table-row-group",
          "text",
          "text-bottom",
          "text-top",
          "textarea",
          "textfield",
          "thick",
          "thin",
          "threeddarkshadow",
          "threedface",
          "threedhighlight",
          "threedlightshadow",
          "threedshadow",
          "to",
          "top",
          "transform",
          "translate",
          "translate3d",
          "translateX",
          "translateY",
          "translateZ",
          "transparent",
          "ultra-condensed",
          "ultra-expanded",
          "underline",
          "unidirectional-pan",
          "unset",
          "up",
          "upper-latin",
          "uppercase",
          "url",
          "var",
          "vertical",
          "vertical-text",
          "view-box",
          "visible",
          "visibleFill",
          "visiblePainted",
          "visibleStroke",
          "visual",
          "w-resize",
          "wait",
          "wave",
          "wider",
          "window",
          "windowframe",
          "windowtext",
          "words",
          "wrap",
          "wrap-reverse",
          "x-large",
          "x-small",
          "xor",
          "xx-large",
          "xx-small",
        ]
          .map((n) => ({ type: "keyword", label: n }))
          .concat(
            [
              "aliceblue",
              "antiquewhite",
              "aqua",
              "aquamarine",
              "azure",
              "beige",
              "bisque",
              "black",
              "blanchedalmond",
              "blue",
              "blueviolet",
              "brown",
              "burlywood",
              "cadetblue",
              "chartreuse",
              "chocolate",
              "coral",
              "cornflowerblue",
              "cornsilk",
              "crimson",
              "cyan",
              "darkblue",
              "darkcyan",
              "darkgoldenrod",
              "darkgray",
              "darkgreen",
              "darkkhaki",
              "darkmagenta",
              "darkolivegreen",
              "darkorange",
              "darkorchid",
              "darkred",
              "darksalmon",
              "darkseagreen",
              "darkslateblue",
              "darkslategray",
              "darkturquoise",
              "darkviolet",
              "deeppink",
              "deepskyblue",
              "dimgray",
              "dodgerblue",
              "firebrick",
              "floralwhite",
              "forestgreen",
              "fuchsia",
              "gainsboro",
              "ghostwhite",
              "gold",
              "goldenrod",
              "gray",
              "grey",
              "green",
              "greenyellow",
              "honeydew",
              "hotpink",
              "indianred",
              "indigo",
              "ivory",
              "khaki",
              "lavender",
              "lavenderblush",
              "lawngreen",
              "lemonchiffon",
              "lightblue",
              "lightcoral",
              "lightcyan",
              "lightgoldenrodyellow",
              "lightgray",
              "lightgreen",
              "lightpink",
              "lightsalmon",
              "lightseagreen",
              "lightskyblue",
              "lightslategray",
              "lightsteelblue",
              "lightyellow",
              "lime",
              "limegreen",
              "linen",
              "magenta",
              "maroon",
              "mediumaquamarine",
              "mediumblue",
              "mediumorchid",
              "mediumpurple",
              "mediumseagreen",
              "mediumslateblue",
              "mediumspringgreen",
              "mediumturquoise",
              "mediumvioletred",
              "midnightblue",
              "mintcream",
              "mistyrose",
              "moccasin",
              "navajowhite",
              "navy",
              "oldlace",
              "olive",
              "olivedrab",
              "orange",
              "orangered",
              "orchid",
              "palegoldenrod",
              "palegreen",
              "paleturquoise",
              "palevioletred",
              "papayawhip",
              "peachpuff",
              "peru",
              "pink",
              "plum",
              "powderblue",
              "purple",
              "rebeccapurple",
              "red",
              "rosybrown",
              "royalblue",
              "saddlebrown",
              "salmon",
              "sandybrown",
              "seagreen",
              "seashell",
              "sienna",
              "silver",
              "skyblue",
              "slateblue",
              "slategray",
              "snow",
              "springgreen",
              "steelblue",
              "tan",
              "teal",
              "thistle",
              "tomato",
              "turquoise",
              "violet",
              "wheat",
              "white",
              "whitesmoke",
              "yellow",
              "yellowgreen",
            ].map((n) => ({ type: "constant", label: n }))
          ),
        sy = [
          "a",
          "abbr",
          "address",
          "article",
          "aside",
          "b",
          "bdi",
          "bdo",
          "blockquote",
          "body",
          "br",
          "button",
          "canvas",
          "caption",
          "cite",
          "code",
          "col",
          "colgroup",
          "dd",
          "del",
          "details",
          "dfn",
          "dialog",
          "div",
          "dl",
          "dt",
          "em",
          "figcaption",
          "figure",
          "footer",
          "form",
          "header",
          "hgroup",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "hr",
          "html",
          "i",
          "iframe",
          "img",
          "input",
          "ins",
          "kbd",
          "label",
          "legend",
          "li",
          "main",
          "meter",
          "nav",
          "ol",
          "output",
          "p",
          "pre",
          "ruby",
          "section",
          "select",
          "small",
          "source",
          "span",
          "strong",
          "sub",
          "summary",
          "sup",
          "table",
          "tbody",
          "td",
          "template",
          "textarea",
          "tfoot",
          "th",
          "thead",
          "tr",
          "u",
          "ul",
        ].map((n) => ({ type: "type", label: n })),
        oy = [
          "@charset",
          "@color-profile",
          "@container",
          "@counter-style",
          "@font-face",
          "@font-feature-values",
          "@font-palette-values",
          "@import",
          "@keyframes",
          "@layer",
          "@media",
          "@namespace",
          "@page",
          "@position-try",
          "@property",
          "@scope",
          "@starting-style",
          "@supports",
          "@view-transition",
        ].map((n) => ({ type: "keyword", label: n })),
        ct = /^(\w[\w-]*|-\w[\w-]*|)$/,
        ly = /^-(-[\w-]*)?$/;
      function ay(n, e) {
        var t;
        if (
          ((n.name == "(" || n.type.isError) && (n = n.parent || n),
          n.name != "ArgList")
        )
          return !1;
        let i = (t = n.parent) === null || t === void 0 ? void 0 : t.firstChild;
        return i?.name != "Callee" ? !1 : e.sliceString(i.from, i.to) == "var";
      }
      const Rh = new Sf(),
        hy = ["Declaration"];
      function cy(n) {
        for (let e = n; ; ) {
          if (e.type.isTop) return e;
          if (!(e = e.parent)) return n;
        }
      }
      function sd(n, e, t) {
        if (e.to - e.from > 4096) {
          let i = Rh.get(e);
          if (i) return i;
          let r = [],
            s = new Set(),
            o = e.cursor(N.IncludeAnonymous);
          if (o.firstChild())
            do
              for (let l of sd(n, o.node, t))
                s.has(l.label) || (s.add(l.label), r.push(l));
            while (o.nextSibling());
          return Rh.set(e, r), r;
        } else {
          let i = [],
            r = new Set();
          return (
            e.cursor().iterate((s) => {
              var o;
              if (
                t(s) &&
                s.matchContext(hy) &&
                ((o = s.node.nextSibling) === null || o === void 0
                  ? void 0
                  : o.name) == ":"
              ) {
                let l = n.sliceString(s.from, s.to);
                r.has(l) || (r.add(l), i.push({ label: l, type: "variable" }));
              }
            }),
            i
          );
        }
      }
      const fy = (n) => (e) => {
          let { state: t, pos: i } = e,
            r = J(t).resolveInner(i, -1),
            s =
              r.type.isError &&
              r.from == r.to - 1 &&
              t.doc.sliceString(r.from, r.to) == "-";
          if (
            r.name == "PropertyName" ||
            ((s || r.name == "TagName") &&
              /^(Block|Styles)$/.test(r.resolve(r.to).name))
          )
            return { from: r.from, options: ks(), validFor: ct };
          if (r.name == "ValueName")
            return { from: r.from, options: Xh, validFor: ct };
          if (r.name == "PseudoClassName")
            return { from: r.from, options: Ah, validFor: ct };
          if (n(r) || ((e.explicit || s) && ay(r, t.doc)))
            return {
              from: n(r) || s ? r.from : i,
              options: sd(t.doc, cy(r), n),
              validFor: ly,
            };
          if (r.name == "TagName") {
            for (let { parent: a } = r; a; a = a.parent)
              if (a.name == "Block")
                return { from: r.from, options: ks(), validFor: ct };
            return { from: r.from, options: sy, validFor: ct };
          }
          if (r.name == "AtKeyword")
            return { from: r.from, options: oy, validFor: ct };
          if (!e.explicit) return null;
          let o = r.resolve(i),
            l = o.childBefore(i);
          return l && l.name == ":" && o.name == "PseudoClassSelector"
            ? { from: i, options: Ah, validFor: ct }
            : (l && l.name == ":" && o.name == "Declaration") ||
              o.name == "ArgList"
            ? { from: i, options: Xh, validFor: ct }
            : o.name == "Block" || o.name == "Styles"
            ? { from: i, options: ks(), validFor: ct }
            : null;
        },
        uy = fy((n) => n.name == "VariableName"),
        vr = ci.define({
          name: "css",
          parser: ry.configure({
            props: [
              _r.add({ Declaration: Nn() }),
              Vr.add({ "Block KeyframeList": vf }),
            ],
          }),
          languageData: {
            commentTokens: { block: { open: "/*", close: "*/" } },
            indentOnInput: /^\s*\}$/,
            wordChars: "-",
          },
        });
      function dy() {
        return new Uo(vr, vr.data.of({ autocomplete: uy }));
      }
      const Oy = 316,
        py = 317,
        Mh = 1,
        my = 2,
        gy = 3,
        Qy = 4,
        Sy = 318,
        yy = 320,
        by = 321,
        xy = 5,
        wy = 6,
        ky = 0,
        vo = [
          9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196,
          8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288,
        ],
        od = 125,
        $y = 59,
        To = 47,
        Py = 42,
        vy = 43,
        Ty = 45,
        Cy = 60,
        Zy = 44,
        Ay = 63,
        Xy = 46,
        Ry = 91,
        My = new Lu({
          start: !1,
          shift(n, e) {
            return e == xy || e == wy || e == yy ? n : e == by;
          },
          strict: !1,
        }),
        Yy = new Xe(
          (n, e) => {
            let { next: t } = n;
            (t == od || t == -1 || e.context) && n.acceptToken(Sy);
          },
          { contextual: !0, fallback: !0 }
        ),
        zy = new Xe(
          (n, e) => {
            let { next: t } = n,
              i;
            vo.indexOf(t) > -1 ||
              (t == To && ((i = n.peek(1)) == To || i == Py)) ||
              (t != od &&
                t != $y &&
                t != -1 &&
                !e.context &&
                n.acceptToken(Oy));
          },
          { contextual: !0 }
        ),
        Dy = new Xe(
          (n, e) => {
            n.next == Ry && !e.context && n.acceptToken(py);
          },
          { contextual: !0 }
        ),
        Ey = new Xe(
          (n, e) => {
            let { next: t } = n;
            if (t == vy || t == Ty) {
              if ((n.advance(), t == n.next)) {
                n.advance();
                let i = !e.context && e.canShift(Mh);
                n.acceptToken(i ? Mh : my);
              }
            } else
              t == Ay &&
                n.peek(1) == Xy &&
                (n.advance(),
                n.advance(),
                (n.next < 48 || n.next > 57) && n.acceptToken(gy));
          },
          { contextual: !0 }
        );
      function $s(n, e) {
        return (
          (n >= 65 && n <= 90) ||
          (n >= 97 && n <= 122) ||
          n == 95 ||
          n >= 192 ||
          (!e && n >= 48 && n <= 57)
        );
      }
      const _y = new Xe((n, e) => {
          if (
            n.next != Cy ||
            !e.dialectEnabled(ky) ||
            (n.advance(), n.next == To)
          )
            return;
          let t = 0;
          for (; vo.indexOf(n.next) > -1; ) n.advance(), t++;
          if ($s(n.next, !0)) {
            for (n.advance(), t++; $s(n.next, !1); ) n.advance(), t++;
            for (; vo.indexOf(n.next) > -1; ) n.advance(), t++;
            if (n.next == Zy) return;
            for (let i = 0; ; i++) {
              if (i == 7) {
                if (!$s(n.next, !0)) return;
                break;
              }
              if (n.next != "extends".charCodeAt(i)) break;
              n.advance(), t++;
            }
          }
          n.acceptToken(Qy, -t);
        }),
        Vy = zr({
          "get set async static": p.modifier,
          "for while do if else switch try catch finally return throw break continue default case defer":
            p.controlKeyword,
          "in of await yield void typeof delete instanceof as satisfies":
            p.operatorKeyword,
          "let var const using function class extends": p.definitionKeyword,
          "import export from": p.moduleKeyword,
          "with debugger new": p.keyword,
          TemplateString: p.special(p.string),
          super: p.atom,
          BooleanLiteral: p.bool,
          this: p.self,
          null: p.null,
          Star: p.modifier,
          VariableName: p.variableName,
          "CallExpression/VariableName TaggedTemplateExpression/VariableName":
            p.function(p.variableName),
          VariableDefinition: p.definition(p.variableName),
          Label: p.labelName,
          PropertyName: p.propertyName,
          PrivatePropertyName: p.special(p.propertyName),
          "CallExpression/MemberExpression/PropertyName": p.function(
            p.propertyName
          ),
          "FunctionDeclaration/VariableDefinition": p.function(
            p.definition(p.variableName)
          ),
          "ClassDeclaration/VariableDefinition": p.definition(p.className),
          "NewExpression/VariableName": p.className,
          PropertyDefinition: p.definition(p.propertyName),
          PrivatePropertyDefinition: p.definition(p.special(p.propertyName)),
          UpdateOp: p.updateOperator,
          "LineComment Hashbang": p.lineComment,
          BlockComment: p.blockComment,
          Number: p.number,
          String: p.string,
          Escape: p.escape,
          ArithOp: p.arithmeticOperator,
          LogicOp: p.logicOperator,
          BitOp: p.bitwiseOperator,
          CompareOp: p.compareOperator,
          RegExp: p.regexp,
          Equals: p.definitionOperator,
          Arrow: p.function(p.punctuation),
          ": Spread": p.punctuation,
          "( )": p.paren,
          "[ ]": p.squareBracket,
          "{ }": p.brace,
          "InterpolationStart InterpolationEnd": p.special(p.brace),
          ".": p.derefOperator,
          ", ;": p.separator,
          "@": p.meta,
          TypeName: p.typeName,
          TypeDefinition: p.definition(p.typeName),
          "type enum interface implements namespace module declare":
            p.definitionKeyword,
          "abstract global Privacy readonly override": p.modifier,
          "is keyof unique infer asserts": p.operatorKeyword,
          JSXAttributeValue: p.attributeValue,
          JSXText: p.content,
          "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag":
            p.angleBracket,
          "JSXIdentifier JSXNameSpacedName": p.tagName,
          "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName":
            p.attributeName,
          "JSXBuiltin/JSXIdentifier": p.standard(p.tagName),
        }),
        qy = {
          __proto__: null,
          export: 20,
          as: 25,
          from: 33,
          default: 36,
          async: 41,
          function: 42,
          in: 52,
          out: 55,
          const: 56,
          extends: 60,
          this: 64,
          true: 72,
          false: 72,
          null: 84,
          void: 88,
          typeof: 92,
          super: 108,
          new: 142,
          delete: 154,
          yield: 163,
          await: 167,
          class: 172,
          public: 235,
          private: 235,
          protected: 235,
          readonly: 237,
          instanceof: 256,
          satisfies: 259,
          import: 292,
          keyof: 349,
          unique: 353,
          infer: 359,
          asserts: 395,
          is: 397,
          abstract: 417,
          implements: 419,
          type: 421,
          let: 424,
          var: 426,
          using: 429,
          interface: 435,
          enum: 439,
          namespace: 445,
          module: 447,
          declare: 451,
          global: 455,
          defer: 471,
          for: 476,
          of: 485,
          while: 488,
          with: 492,
          do: 496,
          if: 500,
          else: 502,
          switch: 506,
          case: 512,
          try: 518,
          catch: 522,
          finally: 526,
          return: 530,
          throw: 534,
          break: 538,
          continue: 542,
          debugger: 546,
        },
        Wy = {
          __proto__: null,
          async: 129,
          get: 131,
          set: 133,
          declare: 195,
          public: 197,
          private: 197,
          protected: 197,
          static: 199,
          abstract: 201,
          override: 203,
          readonly: 209,
          accessor: 211,
          new: 401,
        },
        Ly = { __proto__: null, "<": 193 },
        jy = Oi.deserialize({
          version: 14,
          states:
            "$FjQ%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#DaO.QQlO'#DgO.bQlO'#DrO%[QlO'#DzO0fQlO'#ESOOQ!0Lf'#E['#E[O1PQ`O'#EXOOQO'#Ep'#EpOOQO'#Il'#IlO1XQ`O'#GsO1dQ`O'#EoO1iQ`O'#EoO3hQ!0MxO'#JrO6[Q!0MxO'#JsO6uQ`O'#F]O6zQ,UO'#FtOOQ!0Lf'#Ff'#FfO7VO7dO'#FfO9XQMhO'#F|O9`Q`O'#F{OOQ!0Lf'#Js'#JsOOQ!0Lb'#Jr'#JrO9eQ`O'#GwOOQ['#K_'#K_O9pQ`O'#IYO9uQ!0LrO'#IZOOQ['#J`'#J`OOQ['#I_'#I_Q`QlOOQ`QlOOO9}Q!L^O'#DvO:UQlO'#EOO:]QlO'#EQO9kQ`O'#GsO:dQMhO'#CoO:rQ`O'#EnO:}Q`O'#EyO;hQMhO'#FeO;xQ`O'#GsOOQO'#K`'#K`O;}Q`O'#K`O<]Q`O'#G{O<]Q`O'#G|O<]Q`O'#HOO9kQ`O'#HRO=SQ`O'#HUO>kQ`O'#CeO>{Q`O'#HcO?TQ`O'#HiO?TQ`O'#HkO`QlO'#HmO?TQ`O'#HoO?TQ`O'#HrO?YQ`O'#HxO?_Q!0LsO'#IOO%[QlO'#IQO?jQ!0LsO'#ISO?uQ!0LsO'#IUO9uQ!0LrO'#IWO@QQ!0MxO'#CiOASQpO'#DlQOQ`OOO%[QlO'#EQOAjQ`O'#ETO:dQMhO'#EnOAuQ`O'#EnOBQQ!bO'#FeOOQ['#Cg'#CgOOQ!0Lb'#Dq'#DqOOQ!0Lb'#Jv'#JvO%[QlO'#JvOOQO'#Jy'#JyOOQO'#Ih'#IhOCQQpO'#EgOOQ!0Lb'#Ef'#EfOOQ!0Lb'#J}'#J}OC|Q!0MSO'#EgODWQpO'#EWOOQO'#Jx'#JxODlQpO'#JyOEyQpO'#EWODWQpO'#EgPFWO&2DjO'#CbPOOO)CD})CD}OOOO'#I`'#I`OFcO#tO,59UOOQ!0Lh,59U,59UOOOO'#Ia'#IaOFqO&jO,59UOGPQ!L^O'#DcOOOO'#Ic'#IcOGWO#@ItO,59{OOQ!0Lf,59{,59{OGfQlO'#IdOGyQ`O'#JtOIxQ!fO'#JtO+}QlO'#JtOJPQ`O,5:ROJgQ`O'#EpOJtQ`O'#KTOKPQ`O'#KSOKPQ`O'#KSOKXQ`O,5;^OK^Q`O'#KROOQ!0Ln,5:^,5:^OKeQlO,5:^OMcQ!0MxO,5:fONSQ`O,5:nONmQ!0LrO'#KQONtQ`O'#KPO9eQ`O'#KPO! YQ`O'#KPO! bQ`O,5;]O! gQ`O'#KPO!#lQ!fO'#JsOOQ!0Lh'#Ci'#CiO%[QlO'#ESO!$[Q!fO,5:sOOQS'#Jz'#JzOOQO-E<j-E<jO9kQ`O,5=_O!$rQ`O,5=_O!$wQlO,5;ZO!&zQMhO'#EkO!(eQ`O,5;ZO!(jQlO'#DyO!(tQpO,5;dO!(|QpO,5;dO%[QlO,5;dOOQ['#FT'#FTOOQ['#FV'#FVO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eOOQ['#FZ'#FZO!)[QlO,5;tOOQ!0Lf,5;y,5;yOOQ!0Lf,5;z,5;zOOQ!0Lf,5;|,5;|O%[QlO'#IpO!+_Q!0LrO,5<iO%[QlO,5;eO!&zQMhO,5;eO!+|QMhO,5;eO!-nQMhO'#E^O%[QlO,5;wOOQ!0Lf,5;{,5;{O!-uQ,UO'#FjO!.rQ,UO'#KXO!.^Q,UO'#KXO!.yQ,UO'#KXOOQO'#KX'#KXO!/_Q,UO,5<SOOOW,5<`,5<`O!/pQlO'#FvOOOW'#Io'#IoO7VO7dO,5<QO!/wQ,UO'#FxOOQ!0Lf,5<Q,5<QO!0hQ$IUO'#CyOOQ!0Lh'#C}'#C}O!0{O#@ItO'#DRO!1iQMjO,5<eO!1pQ`O,5<hO!3]Q(CWO'#GXO!3jQ`O'#GYO!3oQ`O'#GYO!5_Q(CWO'#G^O!6dQpO'#GbOOQO'#Gn'#GnO!,TQMhO'#GmOOQO'#Gp'#GpO!,TQMhO'#GoO!7VQ$IUO'#JlOOQ!0Lh'#Jl'#JlO!7aQ`O'#JkO!7oQ`O'#JjO!7wQ`O'#CuOOQ!0Lh'#C{'#C{O!8YQ`O'#C}OOQ!0Lh'#DV'#DVOOQ!0Lh'#DX'#DXO!8_Q`O,5<eO1SQ`O'#DZO!,TQMhO'#GPO!,TQMhO'#GRO!8gQ`O'#GTO!8lQ`O'#GUO!3oQ`O'#G[O!,TQMhO'#GaO<]Q`O'#JkO!8qQ`O'#EqO!9`Q`O,5<gOOQ!0Lb'#Cr'#CrO!9hQ`O'#ErO!:bQpO'#EsOOQ!0Lb'#KR'#KRO!:iQ!0LrO'#KaO9uQ!0LrO,5=cO`QlO,5>tOOQ['#Jh'#JhOOQ[,5>u,5>uOOQ[-E<]-E<]O!<hQ!0MxO,5:bO!:]QpO,5:`O!?RQ!0MxO,5:jO%[QlO,5:jO!AiQ!0MxO,5:lOOQO,5@z,5@zO!BYQMhO,5=_O!BhQ!0LrO'#JiO9`Q`O'#JiO!ByQ!0LrO,59ZO!CUQpO,59ZO!C^QMhO,59ZO:dQMhO,59ZO!CiQ`O,5;ZO!CqQ`O'#HbO!DVQ`O'#KdO%[QlO,5;}O!:]QpO,5<PO!D_Q`O,5=zO!DdQ`O,5=zO!DiQ`O,5=zO!DwQ`O,5=zO9uQ!0LrO,5=zO<]Q`O,5=jOOQO'#Cy'#CyO!EOQpO,5=gO!EWQMhO,5=hO!EcQ`O,5=jO!EhQ!bO,5=mO!EpQ`O'#K`O?YQ`O'#HWO9kQ`O'#HYO!EuQ`O'#HYO:dQMhO'#H[O!EzQ`O'#H[OOQ[,5=p,5=pO!FPQ`O'#H]O!FbQ`O'#CoO!FgQ`O,59PO!FqQ`O,59PO!HvQlO,59POOQ[,59P,59PO!IWQ!0LrO,59PO%[QlO,59PO!KcQlO'#HeOOQ['#Hf'#HfOOQ['#Hg'#HgO`QlO,5=}O!KyQ`O,5=}O`QlO,5>TO`QlO,5>VO!LOQ`O,5>XO`QlO,5>ZO!LTQ`O,5>^O!LYQlO,5>dOOQ[,5>j,5>jO%[QlO,5>jO9uQ!0LrO,5>lOOQ[,5>n,5>nO#!dQ`O,5>nOOQ[,5>p,5>pO#!dQ`O,5>pOOQ[,5>r,5>rO##QQpO'#D_O%[QlO'#JvO##sQpO'#JvO##}QpO'#DmO#$`QpO'#DmO#&qQlO'#DmO#&xQ`O'#JuO#'QQ`O,5:WO#'VQ`O'#EtO#'eQ`O'#KUO#'mQ`O,5;_O#'rQpO'#DmO#(PQpO'#EVOOQ!0Lf,5:o,5:oO%[QlO,5:oO#(WQ`O,5:oO?YQ`O,5;YO!CUQpO,5;YO!C^QMhO,5;YO:dQMhO,5;YO#(`Q`O,5@bO#(eQ07dO,5:sOOQO-E<f-E<fO#)kQ!0MSO,5;RODWQpO,5:rO#)uQpO,5:rODWQpO,5;RO!ByQ!0LrO,5:rOOQ!0Lb'#Ej'#EjOOQO,5;R,5;RO%[QlO,5;RO#*SQ!0LrO,5;RO#*_Q!0LrO,5;RO!CUQpO,5:rOOQO,5;X,5;XO#*mQ!0LrO,5;RPOOO'#I^'#I^P#+RO&2DjO,58|POOO,58|,58|OOOO-E<^-E<^OOQ!0Lh1G.p1G.pOOOO-E<_-E<_OOOO,59},59}O#+^Q!bO,59}OOOO-E<a-E<aOOQ!0Lf1G/g1G/gO#+cQ!fO,5?OO+}QlO,5?OOOQO,5?U,5?UO#+mQlO'#IdOOQO-E<b-E<bO#+zQ`O,5@`O#,SQ!fO,5@`O#,ZQ`O,5@nOOQ!0Lf1G/m1G/mO%[QlO,5@oO#,cQ`O'#IjOOQO-E<h-E<hO#,ZQ`O,5@nOOQ!0Lb1G0x1G0xOOQ!0Ln1G/x1G/xOOQ!0Ln1G0Y1G0YO%[QlO,5@lO#,wQ!0LrO,5@lO#-YQ!0LrO,5@lO#-aQ`O,5@kO9eQ`O,5@kO#-iQ`O,5@kO#-wQ`O'#ImO#-aQ`O,5@kOOQ!0Lb1G0w1G0wO!(tQpO,5:uO!)PQpO,5:uOOQS,5:w,5:wO#.iQdO,5:wO#.qQMhO1G2yO9kQ`O1G2yOOQ!0Lf1G0u1G0uO#/PQ!0MxO1G0uO#0UQ!0MvO,5;VOOQ!0Lh'#GW'#GWO#0rQ!0MzO'#JlO!$wQlO1G0uO#2}Q!fO'#JwO%[QlO'#JwO#3XQ`O,5:eOOQ!0Lh'#D_'#D_OOQ!0Lf1G1O1G1OO%[QlO1G1OOOQ!0Lf1G1f1G1fO#3^Q`O1G1OO#5rQ!0MxO1G1PO#5yQ!0MxO1G1PO#8aQ!0MxO1G1PO#8hQ!0MxO1G1PO#;OQ!0MxO1G1PO#=fQ!0MxO1G1PO#=mQ!0MxO1G1PO#=tQ!0MxO1G1PO#@[Q!0MxO1G1PO#@cQ!0MxO1G1PO#BpQ?MtO'#CiO#DkQ?MtO1G1`O#DrQ?MtO'#JsO#EVQ!0MxO,5?[OOQ!0Lb-E<n-E<nO#GdQ!0MxO1G1PO#HaQ!0MzO1G1POOQ!0Lf1G1P1G1PO#IdQMjO'#J|O#InQ`O,5:xO#IsQ!0MxO1G1cO#JgQ,UO,5<WO#JoQ,UO,5<XO#JwQ,UO'#FoO#K`Q`O'#FnOOQO'#KY'#KYOOQO'#In'#InO#KeQ,UO1G1nOOQ!0Lf1G1n1G1nOOOW1G1y1G1yO#KvQ?MtO'#JrO#LQQ`O,5<bO!)[QlO,5<bOOOW-E<m-E<mOOQ!0Lf1G1l1G1lO#LVQpO'#KXOOQ!0Lf,5<d,5<dO#L_QpO,5<dO#LdQMhO'#DTOOOO'#Ib'#IbO#LkO#@ItO,59mOOQ!0Lh,59m,59mO%[QlO1G2PO!8lQ`O'#IrO#LvQ`O,5<zOOQ!0Lh,5<w,5<wO!,TQMhO'#IuO#MdQMjO,5=XO!,TQMhO'#IwO#NVQMjO,5=ZO!&zQMhO,5=]OOQO1G2S1G2SO#NaQ!dO'#CrO#NtQ(CWO'#ErO$ yQpO'#GbO$!aQ!dO,5<sO$!hQ`O'#K[O9eQ`O'#K[O$!vQ`O,5<uO!,TQMhO,5<tO$!{Q`O'#GZO$#^Q`O,5<tO$#cQ!dO'#GWO$#pQ!dO'#K]O$#zQ`O'#K]O!&zQMhO'#K]O$$PQ`O,5<xO$$UQlO'#JvO$$`QpO'#GcO#$`QpO'#GcO$$qQ`O'#GgO!3oQ`O'#GkO$$vQ!0LrO'#ItO$%RQpO,5<|OOQ!0Lp,5<|,5<|O$%YQpO'#GcO$%gQpO'#GdO$%xQpO'#GdO$%}QMjO,5=XO$&_QMjO,5=ZOOQ!0Lh,5=^,5=^O!,TQMhO,5@VO!,TQMhO,5@VO$&oQ`O'#IyO$'TQ`O,5@UO$']Q`O,59aOOQ!0Lh,59i,59iO$'bQ`O,5@VO$(bQ$IYO,59uOOQ!0Lh'#Jp'#JpO$)TQMjO,5<kO$)vQMjO,5<mO@zQ`O,5<oOOQ!0Lh,5<p,5<pO$*QQ`O,5<vO$*VQMjO,5<{O$*gQ`O'#KPO!$wQlO1G2RO$*lQ`O1G2RO9eQ`O'#KSO9eQ`O'#EtO%[QlO'#EtO9eQ`O'#I{O$*qQ!0LrO,5@{OOQ[1G2}1G2}OOQ[1G4`1G4`OOQ!0Lf1G/|1G/|OOQ!0Lf1G/z1G/zO$,sQ!0MxO1G0UOOQ[1G2y1G2yO!&zQMhO1G2yO%[QlO1G2yO#.tQ`O1G2yO$.wQMhO'#EkOOQ!0Lb,5@T,5@TO$/UQ!0LrO,5@TOOQ[1G.u1G.uO!ByQ!0LrO1G.uO!CUQpO1G.uO!C^QMhO1G.uO$/gQ`O1G0uO$/lQ`O'#CiO$/wQ`O'#KeO$0PQ`O,5=|O$0UQ`O'#KeO$0ZQ`O'#KeO$0iQ`O'#JRO$0wQ`O,5AOO$1PQ!fO1G1iOOQ!0Lf1G1k1G1kO9kQ`O1G3fO@zQ`O1G3fO$1WQ`O1G3fO$1]Q`O1G3fO!DiQ`O1G3fO9uQ!0LrO1G3fOOQ[1G3f1G3fO!EcQ`O1G3UO!&zQMhO1G3RO$1bQ`O1G3ROOQ[1G3S1G3SO!&zQMhO1G3SO$1gQ`O1G3SO$1oQpO'#HQOOQ[1G3U1G3UO!6_QpO'#I}O!EhQ!bO1G3XOOQ[1G3X1G3XOOQ[,5=r,5=rO$1wQMhO,5=tO9kQ`O,5=tO$$qQ`O,5=vO9`Q`O,5=vO!CUQpO,5=vO!C^QMhO,5=vO:dQMhO,5=vO$2VQ`O'#KcO$2bQ`O,5=wOOQ[1G.k1G.kO$2gQ!0LrO1G.kO@zQ`O1G.kO$2rQ`O1G.kO9uQ!0LrO1G.kO$4zQ!fO,5AQO$5XQ`O,5AQO9eQ`O,5AQO$5dQlO,5>PO$5kQ`O,5>POOQ[1G3i1G3iO`QlO1G3iOOQ[1G3o1G3oOOQ[1G3q1G3qO?TQ`O1G3sO$5pQlO1G3uO$9tQlO'#HtOOQ[1G3x1G3xO$:RQ`O'#HzO?YQ`O'#H|OOQ[1G4O1G4OO$:ZQlO1G4OO9uQ!0LrO1G4UOOQ[1G4W1G4WOOQ!0Lb'#G_'#G_O9uQ!0LrO1G4YO9uQ!0LrO1G4[O$>bQ`O,5@bO!)[QlO,5;`O9eQ`O,5;`O?YQ`O,5:XO!)[QlO,5:XO!CUQpO,5:XO$>gQ?MtO,5:XOOQO,5;`,5;`O$>qQpO'#IeO$?XQ`O,5@aOOQ!0Lf1G/r1G/rO$?aQpO'#IkO$?kQ`O,5@pOOQ!0Lb1G0y1G0yO#$`QpO,5:XOOQO'#Ig'#IgO$?sQpO,5:qOOQ!0Ln,5:q,5:qO#(ZQ`O1G0ZOOQ!0Lf1G0Z1G0ZO%[QlO1G0ZOOQ!0Lf1G0t1G0tO?YQ`O1G0tO!CUQpO1G0tO!C^QMhO1G0tOOQ!0Lb1G5|1G5|O!ByQ!0LrO1G0^OOQO1G0m1G0mO%[QlO1G0mO$?zQ!0LrO1G0mO$@VQ!0LrO1G0mO!CUQpO1G0^ODWQpO1G0^O$@eQ!0LrO1G0mOOQO1G0^1G0^O$@yQ!0MxO1G0mPOOO-E<[-E<[POOO1G.h1G.hOOOO1G/i1G/iO$ATQ!bO,5<iO$A]Q!fO1G4jOOQO1G4p1G4pO%[QlO,5?OO$AgQ`O1G5zO$AoQ`O1G6YO$AwQ!fO1G6ZO9eQ`O,5?UO$BRQ!0MxO1G6WO%[QlO1G6WO$BcQ!0LrO1G6WO$BtQ`O1G6VO$BtQ`O1G6VO9eQ`O1G6VO$B|Q`O,5?XO9eQ`O,5?XOOQO,5?X,5?XO$CbQ`O,5?XO$*gQ`O,5?XOOQO-E<k-E<kOOQS1G0a1G0aOOQS1G0c1G0cO#.lQ`O1G0cOOQ[7+(e7+(eO!&zQMhO7+(eO%[QlO7+(eO$CpQ`O7+(eO$C{QMhO7+(eO$DZQ!0MzO,5=XO$FfQ!0MzO,5=ZO$HqQ!0MzO,5=XO$KSQ!0MzO,5=ZO$MeQ!0MzO,59uO% jQ!0MzO,5<kO%#uQ!0MzO,5<mO%&QQ!0MzO,5<{OOQ!0Lf7+&a7+&aO%(cQ!0MxO7+&aO%)VQlO'#IfO%)dQ`O,5@cO%)lQ!fO,5@cOOQ!0Lf1G0P1G0PO%)vQ`O7+&jOOQ!0Lf7+&j7+&jO%){Q?MtO,5:fO%[QlO7+&zO%*VQ?MtO,5:bO%*dQ?MtO,5:jO%*nQ?MtO,5:lO%*xQMhO'#IiO%+SQ`O,5@hOOQ!0Lh1G0d1G0dOOQO1G1r1G1rOOQO1G1s1G1sO%+[Q!jO,5<ZO!)[QlO,5<YOOQO-E<l-E<lOOQ!0Lf7+'Y7+'YOOOW7+'e7+'eOOOW1G1|1G1|O%+gQ`O1G1|OOQ!0Lf1G2O1G2OOOOO,59o,59oO%+lQ!dO,59oOOOO-E<`-E<`OOQ!0Lh1G/X1G/XO%+sQ!0MxO7+'kOOQ!0Lh,5?^,5?^O%,gQMhO1G2fP%,nQ`O'#IrPOQ!0Lh-E<p-E<pO%-[QMjO,5?aOOQ!0Lh-E<s-E<sO%-}QMjO,5?cOOQ!0Lh-E<u-E<uO%.XQ!dO1G2wO%.`Q!dO'#CrO%.vQMhO'#KSO$$UQlO'#JvOOQ!0Lh1G2_1G2_O%.}Q`O'#IqO%/cQ`O,5@vO%/cQ`O,5@vO%/kQ`O,5@vO%/vQ`O,5@vOOQO1G2a1G2aO%0UQMjO1G2`O!,TQMhO1G2`O%0fQ(CWO'#IsO%0sQ`O,5@wO!&zQMhO,5@wO%0{Q!dO,5@wOOQ!0Lh1G2d1G2dO%3]Q!fO'#CiO%3gQ`O,5=POOQ!0Lb,5<},5<}O%3oQpO,5<}OOQ!0Lb,5=O,5=OOCwQ`O,5<}O%3zQpO,5<}OOQ!0Lb,5=R,5=RO$*gQ`O,5=VOOQO,5?`,5?`OOQO-E<r-E<rOOQ!0Lp1G2h1G2hO#$`QpO,5<}O$$UQlO,5=PO%4YQ`O,5=OO%4eQpO,5=OO!,TQMhO'#IuO%5_QMjO1G2sO!,TQMhO'#IwO%6QQMjO1G2uO%6[QMjO1G5qO%6fQMjO1G5qOOQO,5?e,5?eOOQO-E<w-E<wOOQO1G.{1G.{O!,TQMhO1G5qO!,TQMhO1G5qO!:]QpO,59wO%[QlO,59wOOQ!0Lh,5<j,5<jO%6sQ`O1G2ZO!,TQMhO1G2bO%6xQ!0MxO7+'mOOQ!0Lf7+'m7+'mO!$wQlO7+'mO%7lQ`O,5;`OOQ!0Lb,5?g,5?gOOQ!0Lb-E<y-E<yO%7qQ!dO'#K^O#(ZQ`O7+(eO4UQ!fO7+(eO$CsQ`O7+(eO%7{Q!0MvO'#CiO%8`Q!0MvO,5=SO%9QQ`O,5=SO%9YQ`O,5=SOOQ!0Lb1G5o1G5oOOQ[7+$a7+$aO!ByQ!0LrO7+$aO!CUQpO7+$aO!$wQlO7+&aO%9_Q`O'#JQO%9vQ`O,5APOOQO1G3h1G3hO9kQ`O,5APO%9vQ`O,5APO%:OQ`O,5APOOQO,5?m,5?mOOQO-E=P-E=POOQ!0Lf7+'T7+'TO%:TQ`O7+)QO9uQ!0LrO7+)QO9kQ`O7+)QO@zQ`O7+)QO%:YQ`O7+)QOOQ[7+)Q7+)QOOQ[7+(p7+(pO%:_Q!0MvO7+(mO!&zQMhO7+(mO!E^Q`O7+(nOOQ[7+(n7+(nO!&zQMhO7+(nO%:iQ`O'#KbO%:tQ`O,5=lOOQO,5?i,5?iOOQO-E<{-E<{OOQ[7+(s7+(sO%<WQpO'#HZOOQ[1G3`1G3`O!&zQMhO1G3`O%[QlO1G3`O%<_Q`O1G3`O%<jQMhO1G3`O9uQ!0LrO1G3bO$$qQ`O1G3bO9`Q`O1G3bO!CUQpO1G3bO!C^QMhO1G3bO%<xQ`O'#JPO%=^Q`O,5@}O%=fQpO,5@}OOQ!0Lb1G3c1G3cOOQ[7+$V7+$VO@zQ`O7+$VO9uQ!0LrO7+$VO%=qQ`O7+$VO%[QlO1G6lO%[QlO1G6mO%=vQ!0LrO1G6lO%>QQlO1G3kO%>XQ`O1G3kO%>^QlO1G3kOOQ[7+)T7+)TO9uQ!0LrO7+)_O`QlO7+)aOOQ['#Kh'#KhOOQ['#JS'#JSO%>eQlO,5>`OOQ[,5>`,5>`O%[QlO'#HuO%>rQ`O'#HwOOQ[,5>f,5>fO9eQ`O,5>fOOQ[,5>h,5>hOOQ[7+)j7+)jOOQ[7+)p7+)pOOQ[7+)t7+)tOOQ[7+)v7+)vO%>wQpO1G5|O%?cQ?MtO1G0zO%?mQ`O1G0zOOQO1G/s1G/sO%?xQ?MtO1G/sO?YQ`O1G/sO!)[QlO'#DmOOQO,5?P,5?POOQO-E<c-E<cOOQO,5?V,5?VOOQO-E<i-E<iO!CUQpO1G/sOOQO-E<e-E<eOOQ!0Ln1G0]1G0]OOQ!0Lf7+%u7+%uO#(ZQ`O7+%uOOQ!0Lf7+&`7+&`O?YQ`O7+&`O!CUQpO7+&`OOQO7+%x7+%xO$@yQ!0MxO7+&XOOQO7+&X7+&XO%[QlO7+&XO%@SQ!0LrO7+&XO!ByQ!0LrO7+%xO!CUQpO7+%xO%@_Q!0LrO7+&XO%@mQ!0MxO7++rO%[QlO7++rO%@}Q`O7++qO%@}Q`O7++qOOQO1G4s1G4sO9eQ`O1G4sO%AVQ`O1G4sOOQS7+%}7+%}O#(ZQ`O<<LPO4UQ!fO<<LPO%AeQ`O<<LPOOQ[<<LP<<LPO!&zQMhO<<LPO%[QlO<<LPO%AmQ`O<<LPO%AxQ!0MzO,5?aO%DTQ!0MzO,5?cO%F`Q!0MzO1G2`O%HqQ!0MzO1G2sO%J|Q!0MzO1G2uO%MXQ!fO,5?QO%[QlO,5?QOOQO-E<d-E<dO%McQ`O1G5}OOQ!0Lf<<JU<<JUO%MkQ?MtO1G0uO& rQ?MtO1G1PO& yQ?MtO1G1PO&#zQ?MtO1G1PO&$RQ?MtO1G1PO&&SQ?MtO1G1PO&(TQ?MtO1G1PO&([Q?MtO1G1PO&(cQ?MtO1G1PO&*dQ?MtO1G1PO&*kQ?MtO1G1PO&*rQ!0MxO<<JfO&,jQ?MtO1G1PO&-gQ?MvO1G1PO&.jQ?MvO'#JlO&0pQ?MtO1G1cO&0}Q?MtO1G0UO&1XQMjO,5?TOOQO-E<g-E<gO!)[QlO'#FqOOQO'#KZ'#KZOOQO1G1u1G1uO&1cQ`O1G1tO&1hQ?MtO,5?[OOOW7+'h7+'hOOOO1G/Z1G/ZO&1rQ!dO1G4xOOQ!0Lh7+(Q7+(QP!&zQMhO,5?^O!,TQMhO7+(cO&1yQ`O,5?]O9eQ`O,5?]OOQO-E<o-E<oO&2XQ`O1G6bO&2XQ`O1G6bO&2aQ`O1G6bO&2lQMjO7+'zO&2|Q!dO,5?_O&3WQ`O,5?_O!&zQMhO,5?_OOQO-E<q-E<qO&3]Q!dO1G6cO&3gQ`O1G6cO&3oQ`O1G2kO!&zQMhO1G2kOOQ!0Lb1G2i1G2iOOQ!0Lb1G2j1G2jO%3oQpO1G2iO!CUQpO1G2iOCwQ`O1G2iOOQ!0Lb1G2q1G2qO&3tQpO1G2iO&4SQ`O1G2kO$*gQ`O1G2jOCwQ`O1G2jO$$UQlO1G2kO&4[Q`O1G2jO&5OQMjO,5?aOOQ!0Lh-E<t-E<tO&5qQMjO,5?cOOQ!0Lh-E<v-E<vO!,TQMhO7++]O&5{QMjO7++]O&6VQMjO7++]OOQ!0Lh1G/c1G/cO&6dQ`O1G/cOOQ!0Lh7+'u7+'uO&6iQMjO7+'|O&6yQ!0MxO<<KXOOQ!0Lf<<KX<<KXO&7mQ`O1G0zO!&zQMhO'#IzO&7rQ`O,5@xO&9tQ!fO<<LPO!&zQMhO1G2nO&9{Q!0LrO1G2nOOQ[<<G{<<G{O!ByQ!0LrO<<G{O&:^Q!0MxO<<I{OOQ!0Lf<<I{<<I{OOQO,5?l,5?lO&;QQ`O,5?lO&;VQ`O,5?lOOQO-E=O-E=OO&;eQ`O1G6kO&;eQ`O1G6kO9kQ`O1G6kO@zQ`O<<LlOOQ[<<Ll<<LlO&;mQ`O<<LlO9uQ!0LrO<<LlO9kQ`O<<LlOOQ[<<LX<<LXO%:_Q!0MvO<<LXOOQ[<<LY<<LYO!E^Q`O<<LYO&;rQpO'#I|O&;}Q`O,5@|O!)[QlO,5@|OOQ[1G3W1G3WOOQO'#JO'#JOO9uQ!0LrO'#JOO&<VQpO,5=uOOQ[,5=u,5=uO&<^QpO'#EgO&<eQpO'#GeO&<jQ`O7+(zO&<oQ`O7+(zOOQ[7+(z7+(zO!&zQMhO7+(zO%[QlO7+(zO&<wQ`O7+(zOOQ[7+(|7+(|O9uQ!0LrO7+(|O$$qQ`O7+(|O9`Q`O7+(|O!CUQpO7+(|O&=SQ`O,5?kOOQO-E<}-E<}OOQO'#H^'#H^O&=_Q`O1G6iO9uQ!0LrO<<GqOOQ[<<Gq<<GqO@zQ`O<<GqO&=gQ`O7+,WO&=lQ`O7+,XO%[QlO7+,WO%[QlO7+,XOOQ[7+)V7+)VO&=qQ`O7+)VO&=vQlO7+)VO&=}Q`O7+)VOOQ[<<Ly<<LyOOQ[<<L{<<L{OOQ[-E=Q-E=QOOQ[1G3z1G3zO&>SQ`O,5>aOOQ[,5>c,5>cO&>XQ`O1G4QO9eQ`O7+&fO!)[QlO7+&fOOQO7+%_7+%_O&>^Q?MtO1G6ZO?YQ`O7+%_OOQ!0Lf<<Ia<<IaOOQ!0Lf<<Iz<<IzO?YQ`O<<IzOOQO<<Is<<IsO$@yQ!0MxO<<IsO%[QlO<<IsOOQO<<Id<<IdO!ByQ!0LrO<<IdO&>hQ!0LrO<<IsO&>sQ!0MxO<= ^O&?TQ`O<= ]OOQO7+*_7+*_O9eQ`O7+*_OOQ[ANAkANAkO&?]Q!fOANAkO!&zQMhOANAkO#(ZQ`OANAkO4UQ!fOANAkO&?dQ`OANAkO%[QlOANAkO&?lQ!0MzO7+'zO&A}Q!0MzO,5?aO&DYQ!0MzO,5?cO&FeQ!0MzO7+'|O&HvQ!fO1G4lO&IQQ?MtO7+&aO&KUQ?MvO,5=XO&M]Q?MvO,5=ZO&MmQ?MvO,5=XO&M}Q?MvO,5=ZO&N_Q?MvO,59uO'!eQ?MvO,5<kO'$hQ?MvO,5<mO'&|Q?MvO,5<{O'(rQ?MtO7+'kO')PQ?MtO7+'mO')^Q`O,5<]OOQO7+'`7+'`OOQ!0Lh7+*d7+*dO')cQMjO<<K}OOQO1G4w1G4wO')jQ`O1G4wO')uQ`O1G4wO'*TQ`O7++|O'*TQ`O7++|O!&zQMhO1G4yO'*]Q!dO1G4yO'*gQ`O7++}O'*oQ`O7+(VO'*zQ!dO7+(VOOQ!0Lb7+(T7+(TOOQ!0Lb7+(U7+(UO!CUQpO7+(TOCwQ`O7+(TO'+UQ`O7+(VO!&zQMhO7+(VO$*gQ`O7+(UO'+ZQ`O7+(VOCwQ`O7+(UO'+cQMjO<<NwO!,TQMhO<<NwOOQ!0Lh7+$}7+$}O'+mQ!dO,5?fOOQO-E<x-E<xO'+wQ!0MvO7+(YO!&zQMhO7+(YOOQ[AN=gAN=gO9kQ`O1G5WOOQO1G5W1G5WO',XQ`O1G5WO',^Q`O7+,VO',^Q`O7+,VO9uQ!0LrOANBWO@zQ`OANBWOOQ[ANBWANBWO',fQ`OANBWOOQ[ANAsANAsOOQ[ANAtANAtO',kQ`O,5?hOOQO-E<z-E<zO',vQ?MtO1G6hOOQO,5?j,5?jOOQO-E<|-E<|OOQ[1G3a1G3aO'-QQ`O,5=POOQ[<<Lf<<LfO!&zQMhO<<LfO&<jQ`O<<LfO'-VQ`O<<LfO%[QlO<<LfOOQ[<<Lh<<LhO9uQ!0LrO<<LhO$$qQ`O<<LhO9`Q`O<<LhO'-_QpO1G5VO'-jQ`O7+,TOOQ[AN=]AN=]O9uQ!0LrOAN=]OOQ[<= r<= rOOQ[<= s<= sO'-rQ`O<= rO'-wQ`O<= sOOQ[<<Lq<<LqO'-|Q`O<<LqO'.RQlO<<LqOOQ[1G3{1G3{O?YQ`O7+)lO'.YQ`O<<JQO'.eQ?MtO<<JQOOQO<<Hy<<HyOOQ!0LfAN?fAN?fOOQOAN?_AN?_O$@yQ!0MxOAN?_OOQOAN?OAN?OO%[QlOAN?_OOQO<<My<<MyOOQ[G27VG27VO!&zQMhOG27VO#(ZQ`OG27VO'.oQ!fOG27VO4UQ!fOG27VO'.vQ`OG27VO'/OQ?MtO<<JfO'/]Q?MvO1G2`O'1RQ?MvO,5?aO'3UQ?MvO,5?cO'5XQ?MvO1G2sO'7[Q?MvO1G2uO'9_Q?MtO<<KXO'9lQ?MtO<<I{OOQO1G1w1G1wO!,TQMhOANAiOOQO7+*c7+*cO'9yQ`O7+*cO':UQ`O<= hO':^Q!dO7+*eOOQ!0Lb<<Kq<<KqO$*gQ`O<<KqOCwQ`O<<KqO':hQ`O<<KqO!&zQMhO<<KqOOQ!0Lb<<Ko<<KoO!CUQpO<<KoO':sQ!dO<<KqOOQ!0Lb<<Kp<<KpO':}Q`O<<KqO!&zQMhO<<KqO$*gQ`O<<KpO';SQMjOANDcO';^Q!0MvO<<KtOOQO7+*r7+*rO9kQ`O7+*rO';nQ`O<= qOOQ[G27rG27rO9uQ!0LrOG27rO@zQ`OG27rO!)[QlO1G5SO';vQ`O7+,SO'<OQ`O1G2kO&<jQ`OANBQOOQ[ANBQANBQO!&zQMhOANBQO'<TQ`OANBQOOQ[ANBSANBSO9uQ!0LrOANBSO$$qQ`OANBSOOQO'#H_'#H_OOQO7+*q7+*qOOQ[G22wG22wOOQ[ANE^ANE^OOQ[ANE_ANE_OOQ[ANB]ANB]O'<]Q`OANB]OOQ[<<MW<<MWO!)[QlOAN?lOOQOG24yG24yO$@yQ!0MxOG24yO#(ZQ`OLD,qOOQ[LD,qLD,qO!&zQMhOLD,qO'<bQ!fOLD,qO'<iQ?MvO7+'zO'>_Q?MvO,5?aO'@bQ?MvO,5?cO'BeQ?MvO7+'|O'DZQMjOG27TOOQO<<M}<<M}OOQ!0LbANA]ANA]O$*gQ`OANA]OCwQ`OANA]O'DkQ!dOANA]OOQ!0LbANAZANAZO'DrQ`OANA]O!&zQMhOANA]O'D}Q!dOANA]OOQ!0LbANA[ANA[OOQO<<N^<<N^OOQ[LD-^LD-^O9uQ!0LrOLD-^O'EXQ?MtO7+*nOOQO'#Gf'#GfOOQ[G27lG27lO&<jQ`OG27lO!&zQMhOG27lOOQ[G27nG27nO9uQ!0LrOG27nOOQ[G27wG27wO'EcQ?MtOG25WOOQOLD*eLD*eOOQ[!$(!]!$(!]O#(ZQ`O!$(!]O!&zQMhO!$(!]O'EmQ!0MzOG27TOOQ!0LbG26wG26wO$*gQ`OG26wO'HOQ`OG26wOCwQ`OG26wO'HZQ!dOG26wO!&zQMhOG26wOOQ[!$(!x!$(!xOOQ[LD-WLD-WO&<jQ`OLD-WOOQ[LD-YLD-YOOQ[!)9Ew!)9EwO#(ZQ`O!)9EwOOQ!0LbLD,cLD,cO$*gQ`OLD,cOCwQ`OLD,cO'HbQ`OLD,cO'HmQ!dOLD,cOOQ[!$(!r!$(!rOOQ[!.K;c!.K;cO'HtQ?MvOG27TOOQ!0Lb!$( }!$( }O$*gQ`O!$( }OCwQ`O!$( }O'JjQ`O!$( }OOQ!0Lb!)9Ei!)9EiO$*gQ`O!)9EiOCwQ`O!)9EiOOQ!0Lb!.K;T!.K;TO$*gQ`O!.K;TOOQ!0Lb!4/0o!4/0oO!)[QlO'#DzO1PQ`O'#EXO'JuQ!fO'#JrO'J|Q!L^O'#DvO'KTQlO'#EOO'K[Q!fO'#CiO'MrQ!fO'#CiO!)[QlO'#EQO'NSQlO,5;ZO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO'#IpO(!VQ`O,5<iO!)[QlO,5;eO(!_QMhO,5;eO(#xQMhO,5;eO!)[QlO,5;wO!&zQMhO'#GmO(!_QMhO'#GmO!&zQMhO'#GoO(!_QMhO'#GoO1SQ`O'#DZO1SQ`O'#DZO!&zQMhO'#GPO(!_QMhO'#GPO!&zQMhO'#GRO(!_QMhO'#GRO!&zQMhO'#GaO(!_QMhO'#GaO!)[QlO,5:jO($PQpO'#D_O($ZQpO'#JvO!)[QlO,5@oO'NSQlO1G0uO($eQ?MtO'#CiO!)[QlO1G2PO!&zQMhO'#IuO(!_QMhO'#IuO!&zQMhO'#IwO(!_QMhO'#IwO($oQ!dO'#CrO!&zQMhO,5<tO(!_QMhO,5<tO'NSQlO1G2RO!)[QlO7+&zO!&zQMhO1G2`O(!_QMhO1G2`O!&zQMhO'#IuO(!_QMhO'#IuO!&zQMhO'#IwO(!_QMhO'#IwO!&zQMhO1G2bO(!_QMhO1G2bO'NSQlO7+'mO'NSQlO7+&aO!&zQMhOANAiO(!_QMhOANAiO(%SQ`O'#EoO(%XQ`O'#EoO(%aQ`O'#F]O(%fQ`O'#EyO(%kQ`O'#KTO(%vQ`O'#KRO(&RQ`O,5;ZO(&WQMjO,5<eO(&_Q`O'#GYO(&dQ`O'#GYO(&iQ`O,5<eO(&qQ`O,5<gO(&yQ`O,5;ZO('RQ?MtO1G1`O('YQ`O,5<tO('_Q`O,5<tO('dQ`O,5<vO('iQ`O,5<vO('nQ`O1G2RO('sQ`O1G0uO('xQMjO<<K}O((PQMjO<<K}O((WQMhO'#F|O9`Q`O'#F{OAuQ`O'#EnO!)[QlO,5;tO!3oQ`O'#GYO!3oQ`O'#GYO!3oQ`O'#G[O!3oQ`O'#G[O!,TQMhO7+(cO!,TQMhO7+(cO%.XQ!dO1G2wO%.XQ!dO1G2wO!&zQMhO,5=]O!&zQMhO,5=]",
          stateData:
            "()^~O'|OS'}OSTOS(ORQ~OPYOQYOSfOY!VOaqOdzOeyOl!POpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!uwO!xxO!|]O$W|O$niO%h}O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO&W!WO&^!XO&`!YO&b!ZO&d![O&g!]O&m!^O&s!_O&u!`O&w!aO&y!bO&{!cO(TSO(VTO(YUO(aVO(o[O~OWtO~P`OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oa!wOs!nO!S!oO!b!yO!c!vO!d!vO!|<SO#T!pO#U!pO#V!xO#W!pO#X!pO#[!zO#]!zO(U!lO(VTO(YUO(e!mO(o!sO~O(O!{O~OP]XR]X[]Xa]Xj]Xr]X!Q]X!S]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X'z]X(a]X(r]X(y]X(z]X~O!g%RX~P(qO_!}O(V#PO(W!}O(X#PO~O_#QO(X#PO(Y#PO(Z#QO~Ox#SO!U#TO(b#TO(c#VO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T<WO(VTO(YUO(aVO(o[O~O![#ZO!]#WO!Y(hP!Y(vP~P+}O!^#cO~P`OPYOQYOSfOd!jOe!iOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(VTO(YUO(aVO(o[O~Op#mO![#iO!|]O#i#lO#j#iO(T<XO!k(sP~P.iO!l#oO(T#nO~O!x#sO!|]O%h#tO~O#k#uO~O!g#vO#k#uO~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!]$_O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~Oa(fX'z(fX'w(fX!k(fX!Y(fX!_(fX%i(fX!g(fX~P1qO#S$dO#`$eO$Q$eOP(gXR(gX[(gXj(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX!_(gX%i(gX~Oa(gX'z(gX'w(gX!Y(gX!k(gXv(gX!g(gX~P4UO#`$eO~O$]$hO$_$gO$f$mO~OSfO!_$nO$i$oO$k$qO~Oh%VOj%dOk%dOp%WOr%XOs$tOt$tOz%YO|%ZO!O%]O!S${O!_$|O!i%bO!l$xO#j%cO$W%`O$t%^O$v%_O$y%aO(T$sO(VTO(YUO(a$uO(y$}O(z%POg(^P~Ol%[O~P7eO!l%eO~O!S%hO!_%iO(T%gO~O!g%mO~Oa%nO'z%nO~O!Q%rO~P%[O(U!lO~P%[O%n%vO~P%[Oh%VO!l%eO(T%gO(U!lO~Oe%}O!l%eO(T%gO~Oj$RO~O!_&PO(T%gO(U!lO(VTO(YUO`)WP~O!Q&SO!l&RO%j&VO&T&WO~P;SO!x#sO~O%s&YO!S)SX!_)SX(T)SX~O(T&ZO~Ol!PO!u&`O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO~Od&eOe&dO!x&bO%h&cO%{&aO~P<bOd&hOeyOl!PO!_&gO!u&`O!xxO!|]O%h}O%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO~Ob&kO#`&nO%j&iO(U!lO~P=gO!l&oO!u&sO~O!l#oO~O!_XO~Oa%nO'x&{O'z%nO~Oa%nO'x'OO'z%nO~Oa%nO'x'QO'z%nO~O'w]X!Y]Xv]X!k]X&[]X!_]X%i]X!g]X~P(qO!b'_O!c'WO!d'WO(U!lO(VTO(YUO~Os'UO!S'TO!['XO(e'SO!^(iP!^(xP~P@nOn'bO!_'`O(T%gO~Oe'gO!l%eO(T%gO~O!Q&SO!l&RO~Os!nO!S!oO!|<SO#T!pO#U!pO#W!pO#X!pO(U!lO(VTO(YUO(e!mO(o!sO~O!b'mO!c'lO!d'lO#V!pO#['nO#]'nO~PBYOa%nOh%VO!g#vO!l%eO'z%nO(r'pO~O!p'tO#`'rO~PChOs!nO!S!oO(VTO(YUO(e!mO(o!sO~O!_XOs(mX!S(mX!b(mX!c(mX!d(mX!|(mX#T(mX#U(mX#V(mX#W(mX#X(mX#[(mX#](mX(U(mX(V(mX(Y(mX(e(mX(o(mX~O!c'lO!d'lO(U!lO~PDWO(P'xO(Q'xO(R'zO~O_!}O(V'|O(W!}O(X'|O~O_#QO(X'|O(Y'|O(Z#QO~Ov(OO~P%[Ox#SO!U#TO(b#TO(c(RO~O![(TO!Y'WX!Y'^X!]'WX!]'^X~P+}O!](VO!Y(hX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!](VO!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~O!Y(hX~PHRO!Y([O~O!Y(uX!](uX!g(uX!k(uX(r(uX~O#`(uX#k#dX!^(uX~PJUO#`(]O!Y(wX!](wX~O!](^O!Y(vX~O!Y(aO~O#`$eO~PJUO!^(bO~P`OR#zO!Q#yO!S#{O!l#xO(aVOP!na[!naj!nar!na!]!na!p!na#R!na#n!na#o!na#p!na#q!na#r!na#s!na#t!na#u!na#v!na#x!na#z!na#{!na(r!na(y!na(z!na~Oa!na'z!na'w!na!Y!na!k!nav!na!_!na%i!na!g!na~PKlO!k(cO~O!g#vO#`(dO(r'pO!](tXa(tX'z(tX~O!k(tX~PNXO!S%hO!_%iO!|]O#i(iO#j(hO(T%gO~O!](jO!k(sX~O!k(lO~O!S%hO!_%iO#j(hO(T%gO~OP(gXR(gX[(gXj(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX~O!g#vO!k(gX~P! uOR(nO!Q(mO!l#xO#S$dO!|!{a!S!{a~O!x!{a%h!{a!_!{a#i!{a#j!{a(T!{a~P!#vO!x(rO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<pO!S${O!_$|O!i>SO!l$xO#j<vO$W%`O$t<rO$v<tO$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~O#k(xO~O![(zO!k(kP~P%[O(e(|O(o[O~O!S)OO!l#xO(e(|O(o[O~OP<ROQ<ROSfOd>OOe!iOpkOr<ROskOtkOzkO|<RO!O<RO!SWO!WkO!XkO!_!eO!i<UO!lZO!o<RO!p<RO!q<RO!s<VO!u<YO!x!hO$W!kO$n=|O(T)]O(VTO(YUO(aVO(o[O~O!]$_Oa$qa'z$qa'w$qa!k$qa!Y$qa!_$qa%i$qa!g$qa~Ol)dO~P!&zOh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O%]O!S${O!_$|O!i%bO!l$xO#j%cO$W%`O$t%^O$v%_O$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~Og(pP~P!,TO!Q)iO!g)hO!_$^X$Z$^X$]$^X$_$^X$f$^X~O!g)hO!_({X$Z({X$]({X$_({X$f({X~O!Q)iO~P!.^O!Q)iO!_({X$Z({X$]({X$_({X$f({X~O!_)kO$Z)oO$])jO$_)jO$f)pO~O![)sO~P!)[O$]$hO$_$gO$f)wO~On$zX!Q$zX#S$zX'y$zX(y$zX(z$zX~OgmXg$zXnmX!]mX#`mX~P!0SOx)yO(b)zO(c)|O~On*VO!Q*OO'y*PO(y$}O(z%PO~Og)}O~P!1WOg*WO~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<pO!S*YO!_*ZO!i>SO!l$xO#j<vO$W%`O$t<rO$v<tO$y%aO(VTO(YUO(a$uO(y$}O(z%PO~O![*^O(T*XO!k)OP~P!1uO#k*`O~O!l*aO~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<pO!S${O!_$|O!i>SO!l$xO#j<vO$W%`O$t<rO$v<tO$y%aO(T*cO(VTO(YUO(a$uO(y$}O(z%PO~O![*fO!Y)PP~P!3tOr*rOs!nO!S*hO!b*pO!c*jO!d*jO!l*aO#[*qO%`*lO(U!lO(VTO(YUO(e!mO~O!^*oO~P!5iO#S$dOn(`X!Q(`X'y(`X(y(`X(z(`X!](`X#`(`X~Og(`X$O(`X~P!6kOn*wO#`*vOg(_X!](_X~O!]*xOg(^X~Oj%dOk%dOl%dO(T&ZOg(^P~Os*{O~Og)}O(T&ZO~O!l+RO~O(T(vO~Op+VO!S%hO![#iO!_%iO!|]O#i#lO#j#iO(T%gO!k(sP~O!g#vO#k+WO~O!S%hO![+YO!](^O!_%iO(T%gO!Y(vP~Os'[O!S+[O![+ZO(VTO(YUO(e(|O~O!^(xP~P!9|O!]+]Oa)TX'z)TX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~Oa!ja!]!ja'z!ja'w!ja!Y!ja!k!jav!ja!_!ja%i!ja!g!ja~P!:tOR#zO!Q#yO!S#{O!l#xO(aVOP!ra[!raj!rar!ra!]!ra!p!ra#R!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#v!ra#x!ra#z!ra#{!ra(r!ra(y!ra(z!ra~Oa!ra'z!ra'w!ra!Y!ra!k!rav!ra!_!ra%i!ra!g!ra~P!=[OR#zO!Q#yO!S#{O!l#xO(aVOP!ta[!taj!tar!ta!]!ta!p!ta#R!ta#n!ta#o!ta#p!ta#q!ta#r!ta#s!ta#t!ta#u!ta#v!ta#x!ta#z!ta#{!ta(r!ta(y!ta(z!ta~Oa!ta'z!ta'w!ta!Y!ta!k!tav!ta!_!ta%i!ta!g!ta~P!?rOh%VOn+fO!_'`O%i+eO~O!g+hOa(]X!_(]X'z(]X!](]X~Oa%nO!_XO'z%nO~Oh%VO!l%eO~Oh%VO!l%eO(T%gO~O!g#vO#k(xO~Ob+sO%j+tO(T+pO(VTO(YUO!^)XP~O!]+uO`)WX~O[+yO~O`+zO~O!_&PO(T%gO(U!lO`)WP~O%j+}O~P;SOh%VO#`,RO~Oh%VOn,UO!_$|O~O!_,WO~O!Q,YO!_XO~O%n%vO~O!x,_O~Oe,dO~Ob,eO(T#nO(VTO(YUO!^)VP~Oe%}O~O%j!QO(T&ZO~P=gO[,jO`,iO~OPYOQYOSfOdzOeyOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!iuO!lZO!oYO!pYO!qYO!svO!xxO!|]O$niO%h}O(VTO(YUO(aVO(o[O~O!_!eO!u!gO$W!kO(T!dO~P!FyO`,iOa%nO'z%nO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oa,oOl!OO!uwO%l!OO%m!OO%n!OO~P!IcO!l&oO~O&^,uO~O!_,wO~O&o,yO&q,zOP&laQ&laS&laY&laa&lad&lae&lal&lap&lar&las&lat&laz&la|&la!O&la!S&la!W&la!X&la!_&la!i&la!l&la!o&la!p&la!q&la!s&la!u&la!x&la!|&la$W&la$n&la%h&la%j&la%l&la%m&la%n&la%q&la%s&la%v&la%w&la%y&la&W&la&^&la&`&la&b&la&d&la&g&la&m&la&s&la&u&la&w&la&y&la&{&la'w&la(T&la(V&la(Y&la(a&la(o&la!^&la&e&lab&la&j&la~O(T-PO~Oh!eX!]!RX!^!RX!g!RX!g!eX!l!eX#`!RX~O!]!eX!^!eX~P#!iO!g-UO#`-TOh(jX!]#hX!^#hX!g(jX!l(jX~O!](jX!^(jX~P##[Oh%VO!g-WO!l%eO!]!aX!^!aX~Os!nO!S!oO(VTO(YUO(e!mO~OP<ROQ<ROSfOd>OOe!iOpkOr<ROskOtkOzkO|<RO!O<RO!SWO!WkO!XkO!_!eO!i<UO!lZO!o<RO!p<RO!q<RO!s<VO!u<YO!x!hO$W!kO$n=|O(VTO(YUO(aVO(o[O~O(T<}O~P#$qO!]-[O!^(iX~O!^-^O~O!g-UO#`-TO!]#hX!^#hX~O!]-_O!^(xX~O!^-aO~O!c-bO!d-bO(U!lO~P#$`O!^-eO~P'_On-hO!_'`O~O!Y-mO~Os!{a!b!{a!c!{a!d!{a#T!{a#U!{a#V!{a#W!{a#X!{a#[!{a#]!{a(U!{a(V!{a(Y!{a(e!{a(o!{a~P!#vO!p-rO#`-pO~PChO!c-tO!d-tO(U!lO~PDWOa%nO#`-pO'z%nO~Oa%nO!g#vO#`-pO'z%nO~Oa%nO!g#vO!p-rO#`-pO'z%nO(r'pO~O(P'xO(Q'xO(R-yO~Ov-zO~O!Y'Wa!]'Wa~P!:tO![.OO!Y'WX!]'WX~P%[O!](VO!Y(ha~O!Y(ha~PHRO!](^O!Y(va~O!S%hO![.SO!_%iO(T%gO!Y'^X!]'^X~O#`.UO!](ta!k(taa(ta'z(ta~O!g#vO~P#,wO!](jO!k(sa~O!S%hO!_%iO#j.YO(T%gO~Op._O!S%hO![.[O!_%iO!|]O#i.^O#j.[O(T%gO!]'aX!k'aX~OR.cO!l#xO~Oh%VOn.fO!_'`O%i.eO~Oa#ci!]#ci'z#ci'w#ci!Y#ci!k#civ#ci!_#ci%i#ci!g#ci~P!:tOn>YO!Q*OO'y*PO(y$}O(z%PO~O#k#_aa#_a#`#_a'z#_a!]#_a!k#_a!_#_a!Y#_a~P#/sO#k(`XP(`XR(`X[(`Xa(`Xj(`Xr(`X!S(`X!l(`X!p(`X#R(`X#n(`X#o(`X#p(`X#q(`X#r(`X#s(`X#t(`X#u(`X#v(`X#x(`X#z(`X#{(`X'z(`X(a(`X(r(`X!k(`X!Y(`X'w(`Xv(`X!_(`X%i(`X!g(`X~P!6kO!].sO!k(kX~P!:tO!k.vO~O!Y.xO~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(aVO[#mia#mij#mir#mi!]#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#n#mi~P#3cO#n$OO~P#3cOP$[OR#zOr$aO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(aVO[#mia#mij#mi!]#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#r#mi~P#6QO#r$QO~P#6QOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO(aVOa#mi!]#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#v#mi~P#8oOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO(aVO(z#}Oa#mi!]#mi#z#mi#{#mi'z#mi(r#mi(y#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#x$UO~P#;VO#x#mi~P#;VO#v$SO~P#8oOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO(aVO(y#|O(z#}Oa#mi!]#mi#{#mi'z#mi(r#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#z#mi~P#={O#z$WO~P#={OP]XR]X[]Xj]Xr]X!Q]X!S]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X!]]X!^]X~O$O]X~P#@jOP$[OR#zO[<jOj<_Or<hO!Q#yO!S#{O!l#xO!p$[O#R<_O#n<[O#o<]O#p<]O#q<]O#r<^O#s<_O#t<_O#u<iO#v<`O#x<bO#z<dO#{<eO(aVO(r$YO(y#|O(z#}O~O$O.zO~P#BwO#S$dO#`<kO$Q<kO$O(gX!^(gX~P! uOa'da!]'da'z'da'w'da!k'da!Y'dav'da!_'da%i'da!g'da~P!:tO[#mia#mij#mir#mi!]#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(aVO(y#mi(z#mi~P#EyOn>YO!Q*OO'y*PO(y$}O(z%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(a#mi~P#EyO!]/OOg(pX~P!1WOg/QO~Oa$Pi!]$Pi'z$Pi'w$Pi!Y$Pi!k$Piv$Pi!_$Pi%i$Pi!g$Pi~P!:tO$]/RO$_/RO~O$]/SO$_/SO~O!g)hO#`/TO!_$cX$Z$cX$]$cX$_$cX$f$cX~O![/UO~O!_)kO$Z/WO$])jO$_)jO$f/XO~O!]<fO!^(fX~P#BwO!^/YO~O!g)hO$f({X~O$f/[O~Ov/]O~P!&zOx)yO(b)zO(c/`O~O!S/cO~O(y$}On%aa!Q%aa'y%aa(z%aa!]%aa#`%aa~Og%aa$O%aa~P#L{O(z%POn%ca!Q%ca'y%ca(y%ca!]%ca#`%ca~Og%ca$O%ca~P#MnO!]fX!gfX!kfX!k$zX(rfX~P!0SO![/lO!](^O(T/kO!Y(vP!Y)PP~P!1uOr*rO!b*pO!c*jO!d*jO!l*aO#[*qO%`*lO(U!lO(VTO(YUO~Os<zO!S/mO![+ZO!^*oO(e<yO!^(xP~P$ XO!k/nO~P#/sO!]/oO!g#vO(r'pO!k)OX~O!k/tO~O!S%hO![*^O!_%iO(T%gO!k)OP~O#k/vO~O!Y$zX!]$zX!g%RX~P!0SO!]/wO!Y)PX~P#/sO!g/yO~O!Y/{O~OpkO(T/|O~P.iOh%VOr0RO!g#vO!l%eO(r'pO~O!g+hO~Oa%nO!]0VO'z%nO~O!^0XO~P!5iO!c0YO!d0YO(U!lO~P#$`Os!nO!S0ZO(VTO(YUO(e!mO~O#[0]O~Og%aa!]%aa#`%aa$O%aa~P!1WOg%ca!]%ca#`%ca$O%ca~P!1WOj%dOk%dOl%dO(T&ZOg'mX!]'mX~O!]*xOg(^a~Og0fO~On0hO#`0gOg(_a!](_a~OR0iO!Q0iO!S0jO#S$dOn}a'y}a(y}a(z}a!]}a#`}a~Og}a$O}a~P$'pO!Q*OO'y*POn$sa(y$sa(z$sa!]$sa#`$sa~Og$sa$O$sa~P$(lO!Q*OO'y*POn$ua(y$ua(z$ua!]$ua#`$ua~Og$ua$O$ua~P$)_O#k0mO~Og%Ta!]%Ta#`%Ta$O%Ta~P!1WO!g#vO~O#k0pO~O!]+]Oa)Ta'z)Ta~OR#zO!Q#yO!S#{O!l#xO(aVOP!ri[!rij!rir!ri!]!ri!p!ri#R!ri#n!ri#o!ri#p!ri#q!ri#r!ri#s!ri#t!ri#u!ri#v!ri#x!ri#z!ri#{!ri(r!ri(y!ri(z!ri~Oa!ri'z!ri'w!ri!Y!ri!k!riv!ri!_!ri%i!ri!g!ri~P$*|Oh%VOr%XOs$tOt$tOz%YO|%ZO!O<pO!S${O!_$|O!i>SO!l$xO#j<vO$W%`O$t<rO$v<tO$y%aO(VTO(YUO(a$uO(y$}O(z%PO~Op0yO%]0zO(T0xO~P$-dO!g+hOa(]a!_(]a'z(]a!](]a~O#k1QO~O[]X!]fX!^fX~O!]1RO!^)XX~O!^1TO~O[1UO~Ob1WO(T+pO(VTO(YUO~O!_&PO(T%gO`'uX!]'uX~O!]+uO`)Wa~O!k1ZO~P!:tO[1^O~O`1_O~O#`1dO~On1gO!_$|O~O(e(|O!^)UP~Oh%VOn1pO!_1mO%i1oO~O[1zO!]1xO!^)VX~O!^1{O~O`1}Oa%nO'z%nO~O(T#nO(VTO(YUO~O#S$dO#`$eO$Q$eOP(gXR(gX[(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX~Oj2QO&[2ROa(gX~P$2}Oj2QO#`$eO&[2RO~Oa2TO~P%[Oa2VO~O&e2YOP&ciQ&ciS&ciY&cia&cid&cie&cil&cip&cir&cis&cit&ciz&ci|&ci!O&ci!S&ci!W&ci!X&ci!_&ci!i&ci!l&ci!o&ci!p&ci!q&ci!s&ci!u&ci!x&ci!|&ci$W&ci$n&ci%h&ci%j&ci%l&ci%m&ci%n&ci%q&ci%s&ci%v&ci%w&ci%y&ci&W&ci&^&ci&`&ci&b&ci&d&ci&g&ci&m&ci&s&ci&u&ci&w&ci&y&ci&{&ci'w&ci(T&ci(V&ci(Y&ci(a&ci(o&ci!^&cib&ci&j&ci~Ob2`O!^2^O&j2_O~P`O!_XO!l2bO~O&q,zOP&liQ&liS&liY&lia&lid&lie&lil&lip&lir&lis&lit&liz&li|&li!O&li!S&li!W&li!X&li!_&li!i&li!l&li!o&li!p&li!q&li!s&li!u&li!x&li!|&li$W&li$n&li%h&li%j&li%l&li%m&li%n&li%q&li%s&li%v&li%w&li%y&li&W&li&^&li&`&li&b&li&d&li&g&li&m&li&s&li&u&li&w&li&y&li&{&li'w&li(T&li(V&li(Y&li(a&li(o&li!^&li&e&lib&li&j&li~O!Y2hO~O!]!aa!^!aa~P#BwOs!nO!S!oO![2nO(e!mO!]'XX!^'XX~P@nO!]-[O!^(ia~O!]'_X!^'_X~P!9|O!]-_O!^(xa~O!^2uO~P'_Oa%nO#`3OO'z%nO~Oa%nO!g#vO#`3OO'z%nO~Oa%nO!g#vO!p3SO#`3OO'z%nO(r'pO~Oa%nO'z%nO~P!:tO!]$_Ov$qa~O!Y'Wi!]'Wi~P!:tO!](VO!Y(hi~O!](^O!Y(vi~O!Y(wi!](wi~P!:tO!](ti!k(tia(ti'z(ti~P!:tO#`3UO!](ti!k(tia(ti'z(ti~O!](jO!k(si~O!S%hO!_%iO!|]O#i3ZO#j3YO(T%gO~O!S%hO!_%iO#j3YO(T%gO~On3bO!_'`O%i3aO~Oh%VOn3bO!_'`O%i3aO~O#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'z%aa(a%aa(r%aa!k%aa!Y%aa'w%aav%aa!_%aa%i%aa!g%aa~P#L{O#k%caP%caR%ca[%caa%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'z%ca(a%ca(r%ca!k%ca!Y%ca'w%cav%ca!_%ca%i%ca!g%ca~P#MnO#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!]%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'z%aa(a%aa(r%aa!k%aa!Y%aa'w%aa#`%aav%aa!_%aa%i%aa!g%aa~P#/sO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!]%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'z%ca(a%ca(r%ca!k%ca!Y%ca'w%ca#`%cav%ca!_%ca%i%ca!g%ca~P#/sO#k}aP}a[}aa}aj}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a'z}a(a}a(r}a!k}a!Y}a'w}av}a!_}a%i}a!g}a~P$'pO#k$saP$saR$sa[$saa$saj$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa'z$sa(a$sa(r$sa!k$sa!Y$sa'w$sav$sa!_$sa%i$sa!g$sa~P$(lO#k$uaP$uaR$ua[$uaa$uaj$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua'z$ua(a$ua(r$ua!k$ua!Y$ua'w$uav$ua!_$ua%i$ua!g$ua~P$)_O#k%TaP%TaR%Ta[%Taa%Taj%Tar%Ta!S%Ta!]%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta'z%Ta(a%Ta(r%Ta!k%Ta!Y%Ta'w%Ta#`%Tav%Ta!_%Ta%i%Ta!g%Ta~P#/sOa#cq!]#cq'z#cq'w#cq!Y#cq!k#cqv#cq!_#cq%i#cq!g#cq~P!:tO![3jO!]'YX!k'YX~P%[O!].sO!k(ka~O!].sO!k(ka~P!:tO!Y3mO~O$O!na!^!na~PKlO$O!ja!]!ja!^!ja~P#BwO$O!ra!^!ra~P!=[O$O!ta!^!ta~P!?rOg']X!]']X~P!,TO!]/OOg(pa~OSfO!_4RO$d4SO~O!^4WO~Ov4XO~P#/sOa$mq!]$mq'z$mq'w$mq!Y$mq!k$mqv$mq!_$mq%i$mq!g$mq~P!:tO!Y4ZO~P!&zO!S4[O~O!Q*OO'y*PO(z%POn'ia(y'ia!]'ia#`'ia~Og'ia$O'ia~P%,sO!Q*OO'y*POn'ka(y'ka(z'ka!]'ka#`'ka~Og'ka$O'ka~P%-fO(r$YO~P#/sO!YfX!Y$zX!]fX!]$zX!g%RX#`fX~P!0SO(T=TO~P!1uO!S%hO![4_O!_%iO(T%gO!]'eX!k'eX~O!]/oO!k)Oa~O!]/oO!g#vO!k)Oa~O!]/oO!g#vO(r'pO!k)Oa~Og$|i!]$|i#`$|i$O$|i~P!1WO![4gO!Y'gX!]'gX~P!3tO!]/wO!Y)Pa~O!]/wO!Y)Pa~P#/sOP]XR]X[]Xj]Xr]X!Q]X!S]X!Y]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X~Oj%YX!g%YX~P%1VOj4lO!g#vO~Oh%VO!g#vO!l%eO~Oh%VOr4qO!l%eO(r'pO~Or4vO!g#vO(r'pO~Os!nO!S4wO(VTO(YUO(e!mO~O(y$}On%ai!Q%ai'y%ai(z%ai!]%ai#`%ai~Og%ai$O%ai~P%4vO(z%POn%ci!Q%ci'y%ci(y%ci!]%ci#`%ci~Og%ci$O%ci~P%5iOg(_i!](_i~P!1WO#`4}Og(_i!](_i~P!1WO!k5SO~Oa$oq!]$oq'z$oq'w$oq!Y$oq!k$oqv$oq!_$oq%i$oq!g$oq~P!:tO!Y5WO~O!]5XO!_)QX~P#/sOa$zX!_$zX%^]X'z$zX!]$zX~P!0SO%^5[OaoXnoX!QoX!_oX'yoX'zoX(yoX(zoX!]oX~Op5]O(T#nO~O%^5[O~Ob5cO%j5dO(T+pO(VTO(YUO!]'tX!^'tX~O!]1RO!^)Xa~O[5hO~O`5iO~O[5mO~Oa%nO'z%nO~P#/sO!]5rO#`5tO!^)UX~O!^5uO~Or5{Os!nO!S*hO!b!yO!c!vO!d!vO!|<SO#T!pO#U!pO#V!pO#W!pO#X!pO#[5zO#]!zO(U!lO(VTO(YUO(e!mO(o!sO~O!^5yO~P%:yOn6QO!_1mO%i6PO~Oh%VOn6QO!_1mO%i6PO~Ob6XO(T#nO(VTO(YUO!]'sX!^'sX~O!]1xO!^)Va~O(VTO(YUO(e6ZO~O`6_O~Oj6bO&[6cO~PNXO!k6dO~P%[Oa6fO~Oa6fO~P%[Ob2`O!^6kO&j2_O~P`O!g6mO~O!g6oOh(ji!](ji!^(ji!g(ji!l(jir(ji(r(ji~O!]#hi!^#hi~P#BwO#`6pO!]#hi!^#hi~O!]!ai!^!ai~P#BwOa%nO#`6yO'z%nO~Oa%nO!g#vO#`6yO'z%nO~O!](tq!k(tqa(tq'z(tq~P!:tO!](jO!k(sq~O!S%hO!_%iO#j7QO(T%gO~O!_'`O%i7TO~On7XO!_'`O%i7TO~O#k'iaP'iaR'ia['iaa'iaj'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia'z'ia(a'ia(r'ia!k'ia!Y'ia'w'iav'ia!_'ia%i'ia!g'ia~P%,sO#k'kaP'kaR'ka['kaa'kaj'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka'z'ka(a'ka(r'ka!k'ka!Y'ka'w'kav'ka!_'ka%i'ka!g'ka~P%-fO#k$|iP$|iR$|i[$|ia$|ij$|ir$|i!S$|i!]$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i'z$|i(a$|i(r$|i!k$|i!Y$|i'w$|i#`$|iv$|i!_$|i%i$|i!g$|i~P#/sO#k%aiP%aiR%ai[%aia%aij%air%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai'z%ai(a%ai(r%ai!k%ai!Y%ai'w%aiv%ai!_%ai%i%ai!g%ai~P%4vO#k%ciP%ciR%ci[%cia%cij%cir%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci'z%ci(a%ci(r%ci!k%ci!Y%ci'w%civ%ci!_%ci%i%ci!g%ci~P%5iO!]'Ya!k'Ya~P!:tO!].sO!k(ki~O$O#ci!]#ci!^#ci~P#BwOP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(aVO[#mij#mir#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#n#mi~P%MxO#n<[O~P%MxOP$[OR#zOr<hO!Q#yO!S#{O!l#xO!p$[O#n<[O#o<]O#p<]O#q<]O(aVO[#mij#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#r#mi~P&!QO#r<^O~P&!QOP$[OR#zO[<jOj<_Or<hO!Q#yO!S#{O!l#xO!p$[O#R<_O#n<[O#o<]O#p<]O#q<]O#r<^O#s<_O#t<_O#u<iO(aVO#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#v#mi~P&$YOP$[OR#zO[<jOj<_Or<hO!Q#yO!S#{O!l#xO!p$[O#R<_O#n<[O#o<]O#p<]O#q<]O#r<^O#s<_O#t<_O#u<iO#v<`O(aVO(z#}O#z#mi#{#mi$O#mi(r#mi(y#mi!]#mi!^#mi~O#x<bO~P&&ZO#x#mi~P&&ZO#v<`O~P&$YOP$[OR#zO[<jOj<_Or<hO!Q#yO!S#{O!l#xO!p$[O#R<_O#n<[O#o<]O#p<]O#q<]O#r<^O#s<_O#t<_O#u<iO#v<`O#x<bO(aVO(y#|O(z#}O#{#mi$O#mi(r#mi!]#mi!^#mi~O#z#mi~P&(jO#z<dO~P&(jOa#|y!]#|y'z#|y'w#|y!Y#|y!k#|yv#|y!_#|y%i#|y!g#|y~P!:tO[#mij#mir#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi!]#mi!^#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n<[O#o<]O#p<]O#q<]O(aVO(y#mi(z#mi~P&+fOn>ZO!Q*OO'y*PO(y$}O(z%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(a#mi~P&+fO#S$dOP(`XR(`X[(`Xj(`Xn(`Xr(`X!Q(`X!S(`X!l(`X!p(`X#R(`X#n(`X#o(`X#p(`X#q(`X#r(`X#s(`X#t(`X#u(`X#v(`X#x(`X#z(`X#{(`X$O(`X'y(`X(a(`X(r(`X(y(`X(z(`X!](`X!^(`X~O$O$Pi!]$Pi!^$Pi~P#BwO$O!ri!^!ri~P$*|Og']a!]']a~P!1WO!^7kO~O!]'da!^'da~P#BwO!Y7lO~P#/sO!g#vO(r'pO!]'ea!k'ea~O!]/oO!k)Oi~O!]/oO!g#vO!k)Oi~Og$|q!]$|q#`$|q$O$|q~P!1WO!Y'ga!]'ga~P#/sO!g7sO~O!]/wO!Y)Pi~P#/sO!]/wO!Y)Pi~O!Y7vO~Oh%VOr7{O!l%eO(r'pO~Oj7}O!g#vO~Or8QO!g#vO(r'pO~O!Q*OO'y*PO(z%POn'ja(y'ja!]'ja#`'ja~Og'ja$O'ja~P&4gO!Q*OO'y*POn'la(y'la(z'la!]'la#`'la~Og'la$O'la~P&5YOg(_q!](_q~P!1WO#`8SOg(_q!](_q~P!1WO!Y8TO~Og%Oq!]%Oq#`%Oq$O%Oq~P!1WOa$oy!]$oy'z$oy'w$oy!Y$oy!k$oyv$oy!_$oy%i$oy!g$oy~P!:tO!g6oO~O!]5XO!_)Qa~O!_'`OP$TaR$Ta[$Taj$Tar$Ta!Q$Ta!S$Ta!]$Ta!l$Ta!p$Ta#R$Ta#n$Ta#o$Ta#p$Ta#q$Ta#r$Ta#s$Ta#t$Ta#u$Ta#v$Ta#x$Ta#z$Ta#{$Ta(a$Ta(r$Ta(y$Ta(z$Ta~O%i7TO~P&7zO%^8XOa%[i!_%[i'z%[i!]%[i~Oa#cy!]#cy'z#cy'w#cy!Y#cy!k#cyv#cy!_#cy%i#cy!g#cy~P!:tO[8ZO~Ob8]O(T+pO(VTO(YUO~O!]1RO!^)Xi~O`8aO~O(e(|O!]'pX!^'pX~O!]5rO!^)Ua~O!^8kO~P%:yO(o!sO~P$%gO#[8lO~O!_1mO~O!_1mO%i8nO~On8qO!_1mO%i8nO~O[8vO!]'sa!^'sa~O!]1xO!^)Vi~O!k8zO~O!k8{O~O!k9OO~O!k9OO~P%[Oa9QO~O!g9RO~O!k9SO~O!](wi!^(wi~P#BwOa%nO#`9[O'z%nO~O!](ty!k(tya(ty'z(ty~P!:tO!](jO!k(sy~O%i9_O~P&7zO!_'`O%i9_O~O#k$|qP$|qR$|q[$|qa$|qj$|qr$|q!S$|q!]$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q'z$|q(a$|q(r$|q!k$|q!Y$|q'w$|q#`$|qv$|q!_$|q%i$|q!g$|q~P#/sO#k'jaP'jaR'ja['jaa'jaj'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja'z'ja(a'ja(r'ja!k'ja!Y'ja'w'jav'ja!_'ja%i'ja!g'ja~P&4gO#k'laP'laR'la['laa'laj'lar'la!S'la!l'la!p'la#R'la#n'la#o'la#p'la#q'la#r'la#s'la#t'la#u'la#v'la#x'la#z'la#{'la'z'la(a'la(r'la!k'la!Y'la'w'lav'la!_'la%i'la!g'la~P&5YO#k%OqP%OqR%Oq[%Oqa%Oqj%Oqr%Oq!S%Oq!]%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq'z%Oq(a%Oq(r%Oq!k%Oq!Y%Oq'w%Oq#`%Oqv%Oq!_%Oq%i%Oq!g%Oq~P#/sO!]'Yi!k'Yi~P!:tO$O#cq!]#cq!^#cq~P#BwO(y$}OP%aaR%aa[%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa$O%aa(a%aa(r%aa!]%aa!^%aa~On%aa!Q%aa'y%aa(z%aa~P&I_O(z%POP%caR%ca[%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca$O%ca(a%ca(r%ca!]%ca!^%ca~On%ca!Q%ca'y%ca(y%ca~P&KfOn>ZO!Q*OO'y*PO(z%PO~P&I_On>ZO!Q*OO'y*PO(y$}O~P&KfOR0iO!Q0iO!S0jO#S$dOP}a[}aj}an}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a$O}a'y}a(a}a(r}a(y}a(z}a!]}a!^}a~O!Q*OO'y*POP$saR$sa[$saj$san$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa$O$sa(a$sa(r$sa(y$sa(z$sa!]$sa!^$sa~O!Q*OO'y*POP$uaR$ua[$uaj$uan$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua$O$ua(a$ua(r$ua(y$ua(z$ua!]$ua!^$ua~On>ZO!Q*OO'y*PO(y$}O(z%PO~OP%TaR%Ta[%Taj%Tar%Ta!S%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta$O%Ta(a%Ta(r%Ta!]%Ta!^%Ta~P'&kO$O$mq!]$mq!^$mq~P#BwO$O$oq!]$oq!^$oq~P#BwO!^9lO~O$O9mO~P!1WO!g#vO!]'ei!k'ei~O!g#vO(r'pO!]'ei!k'ei~O!]/oO!k)Oq~O!Y'gi!]'gi~P#/sO!]/wO!Y)Pq~Or9tO!g#vO(r'pO~O[9vO!Y9uO~P#/sO!Y9uO~Oj9|O!g#vO~Og(_y!](_y~P!1WO!]'na!_'na~P#/sOa%[q!_%[q'z%[q!]%[q~P#/sO[:RO~O!]1RO!^)Xq~O`:VO~O#`:WO!]'pa!^'pa~O!]5rO!^)Ui~P#BwO!S:YO~O!_1mO%i:]O~O(VTO(YUO(e:bO~O!]1xO!^)Vq~O!k:eO~O!k:fO~O!k:gO~O!k:gO~P%[O#`:jO!]#hy!^#hy~O!]#hy!^#hy~P#BwO%i:oO~P&7zO!_'`O%i:oO~O$O#|y!]#|y!^#|y~P#BwOP$|iR$|i[$|ij$|ir$|i!S$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i$O$|i(a$|i(r$|i!]$|i!^$|i~P'&kO!Q*OO'y*PO(z%POP'iaR'ia['iaj'ian'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia$O'ia(a'ia(r'ia(y'ia!]'ia!^'ia~O!Q*OO'y*POP'kaR'ka['kaj'kan'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka$O'ka(a'ka(r'ka(y'ka(z'ka!]'ka!^'ka~O(y$}OP%aiR%ai[%aij%ain%air%ai!Q%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai$O%ai'y%ai(a%ai(r%ai(z%ai!]%ai!^%ai~O(z%POP%ciR%ci[%cij%cin%cir%ci!Q%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci$O%ci'y%ci(a%ci(r%ci(y%ci!]%ci!^%ci~O$O$oy!]$oy!^$oy~P#BwO$O#cy!]#cy!^#cy~P#BwO!g#vO!]'eq!k'eq~O!]/oO!k)Oy~O!Y'gq!]'gq~P#/sOr:yO!g#vO(r'pO~O[:}O!Y:|O~P#/sO!Y:|O~Og(_!R!](_!R~P!1WOa%[y!_%[y'z%[y!]%[y~P#/sO!]1RO!^)Xy~O!]5rO!^)Uq~O(T;UO~O!_1mO%i;XO~O!k;[O~O%i;aO~P&7zOP$|qR$|q[$|qj$|qr$|q!S$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q$O$|q(a$|q(r$|q!]$|q!^$|q~P'&kO!Q*OO'y*PO(z%POP'jaR'ja['jaj'jan'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja$O'ja(a'ja(r'ja(y'ja!]'ja!^'ja~O!Q*OO'y*POP'laR'la['laj'lan'lar'la!S'la!l'la!p'la#R'la#n'la#o'la#p'la#q'la#r'la#s'la#t'la#u'la#v'la#x'la#z'la#{'la$O'la(a'la(r'la(y'la(z'la!]'la!^'la~OP%OqR%Oq[%Oqj%Oqr%Oq!S%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq$O%Oq(a%Oq(r%Oq!]%Oq!^%Oq~P'&kOg%e!Z!]%e!Z#`%e!Z$O%e!Z~P!1WO!Y;eO~P#/sOr;fO!g#vO(r'pO~O[;hO!Y;eO~P#/sO!]'pq!^'pq~P#BwO!]#h!Z!^#h!Z~P#BwO#k%e!ZP%e!ZR%e!Z[%e!Za%e!Zj%e!Zr%e!Z!S%e!Z!]%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z'z%e!Z(a%e!Z(r%e!Z!k%e!Z!Y%e!Z'w%e!Z#`%e!Zv%e!Z!_%e!Z%i%e!Z!g%e!Z~P#/sOr;qO!g#vO(r'pO~O!Y;rO~P#/sOr;yO!g#vO(r'pO~O!Y;zO~P#/sOP%e!ZR%e!Z[%e!Zj%e!Zr%e!Z!S%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z$O%e!Z(a%e!Z(r%e!Z!]%e!Z!^%e!Z~P'&kOr;}O!g#vO(r'pO~Ov(fX~P1qO!Q%rO~P!)[O(U!lO~P!)[O!YfX!]fX#`fX~P%1VOP]XR]X[]Xj]Xr]X!Q]X!S]X!]]X!]fX!l]X!p]X#R]X#S]X#`]X#`fX#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X~O!gfX!k]X!kfX(rfX~P'KiOP<ROQ<ROSfOd>OOe!iOpkOr<ROskOtkOzkO|<RO!O<RO!SWO!WkO!XkO!_XO!i<UO!lZO!o<RO!p<RO!q<RO!s<VO!u<YO!x!hO$W!kO$n=|O(T)]O(VTO(YUO(aVO(o[O~O!]<fO!^$qa~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<qO!S${O!_$|O!i>TO!l$xO#j<wO$W%`O$t<sO$v<uO$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~Ol)dO~P(!_Or!eX(r!eX~P#!iOr(jX(r(jX~P##[O!^]X!^fX~P'KiO!YfX!Y$zX!]fX!]$zX#`fX~P!0SO#k<ZO~O!g#vO#k<ZO~O#`<kO~Oj<_O~O#`<{O!](wX!^(wX~O#`<kO!](uX!^(uX~O#k<|O~Og=OO~P!1WO#k=UO~O#k=VO~Og=OO(T&ZO~O!g#vO#k=WO~O!g#vO#k<|O~O$O=XO~P#BwO#k=YO~O#k=ZO~O#k=`O~O#k=aO~O#k=bO~O#k=cO~O$O=dO~P!1WO$O=eO~P!1WOl=pO~P7eOk#S#T#U#W#X#[#i#j#u$n$t$v$y%]%^%h%i%j%q%s%v%w%y%{~(OT#o!X'|(U#ps#n#qr!Q'}$]'}(T$_(e~",
          goto: "$9V)]PPPPPP)^PP)aP)rP+W/]PPPP6mPP7TPP=QPPP@tPA^PA^PPPA^PCfPA^PA^PA^PCjPCoPD^PIWPPPI[PPPPI[L_PPPLeMVPI[PI[PP! eI[PPPI[PI[P!#lI[P!'S!(X!(bP!)U!)Y!)U!,gPPPPPPP!-W!(XPP!-h!/YP!2fI[I[!2k!5w!:e!:e!>dPPP!>lI[PPPPPPPPP!A{P!CYPPI[!DkPI[PI[I[I[I[I[PI[!E}P!IXP!L_P!Lc!Lm!Lq!LqP!IUP!Lu!LuP# {P#!PI[PI[#!V#%[CjA^PA^PA^A^P#&iA^A^#({A^#+sA^#.PA^A^#.o#1T#1T#1Y#1c#1T#1nPP#1TPA^#2WA^#6VA^A^6mPPP#:[PPP#:u#:uP#:uP#;]#:uPP#;cP#;YP#;Y#;v#;Y#<b#<h#<k)aP#<n)aP#<w#<w#<wP)aP)aP)aP)aPP)aP#<}#=QP#=Q)aP#=UP#=XP)aP)aP)aP)aP)aP)a)aPP#=_#=e#=p#=v#=|#>S#>Y#>h#>n#>x#?O#?Y#?`#?p#?v#@h#@z#AQ#AW#Af#A{#Cp#DO#DV#Eq#FP#Gq#HP#HV#H]#Hc#Hm#Hs#Hy#IT#Ig#ImPPPPPPPPPPP#IsPPPPPPP#Jh#Mu$ _$ f$ nPPP$'YP$'c$*[$0u$0x$0{$1z$1}$2U$2^P$2d$2gP$3T$3X$4P$5_$5d$5zPP$6P$6V$6Z$6^$6b$6f$7b$7y$8b$8f$8i$8l$8v$8y$8}$9RR!|RoqOXst!Z#d%m&r&t&u&w,r,w2Y2]Y!vQ'`-d1m5xQ%tvQ%|yQ&T|Q&j!VS'W!e-[Q'f!iS'l!r!yU*j$|*Z*nQ+n%}S+{&V&WQ,c&dQ-b'_Q-l'gQ-t'mQ0Y*pQ1`+}Q1w,dR<x<V%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*h+W+[,o,r,w-h-p.O.U.s.z/m0Z0j0p1Q1p2Q2R2T2V2Y2]2_3O3U3j4w6Q6b6c6f6y8q9Q9[S#q]<S!r)_$Z$n'X)s-T-W/U2n4R5t6p:W:j<R<U<V<Y<Z<[<]<^<_<`<a<b<c<d<e<f<h<k<x<{<|=O=W=X=b=c>PU+O%]<p<qQ+s&PQ,e&gQ,l&oQ0v+fQ0{+hQ1W+tQ2P,jQ3^.fQ5]0zQ5c1RQ6X1xQ7V3bQ8]5dR9b7X'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*h+W+[+f,o,r,w-T-W-h-p.O.U.f.s.z/U/m0Z0j0p1Q1p2Q2R2T2V2Y2]2_2n3O3U3b3j4R4w5t6Q6b6c6f6p6y7X8q9Q9[:W:j<R<U<V<Y<Z<[<]<^<_<`<a<b<c<d<e<f<h<k<x<{<|=O=W=X=b=c>P!S!nQ!r!v!y!z$|'W'_'`'l'm'n*j*n*p*q-[-b-d-t0Y0]1m5x5z%[$ti#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*`*f*v*w+e+h,R,U.e/O/c/l/v/w/y0^0`0g0h0m1d1g1o3a4[4]4g4l4}5X5[6P7T7s7}8S8X8n9_9m9v9|:]:o:};X;a;h<i<j<l<m<n<o<r<s<t<u<v<w=P=Q=R=S=U=V=Y=Z=[=]=^=_=`=a=d=e=|>U>V>Y>ZQ&X|Q'U!eS'[%i-_Q+s&PQ,O&WQ,e&gQ0l+RQ1W+tQ1]+zQ2O,iQ2P,jQ5c1RQ5l1_Q6X1xQ6[1zQ6]1}Q8]5dQ8`5iQ8y6_Q:U8aQ:c8vQ;S:VR<z*ZrnOXst!V!Z#d%m&i&r&t&u&w,r,w2Y2]R,g&k&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'b'r(V(](d(x(z)O)s)}*h+W+[+f,o,r,w-T-W-h-p.O.U.f.s.z/U/m0Z0j0p1Q1p2Q2R2T2V2Y2]2_2n3O3U3b3j4R4w5t6Q6b6c6f6p6y7X8q9Q9[:W:j<R<U<V<Y<Z<[<]<^<_<`<a<b<c<d<e<f<h<k<x<{<|=O=W=X=b=c>O>P[#]WZ#W#Z'X(T!b%jm#h#i#l$x%e%h(^(h(i(j*Y*^*a+Y+Z+],n-U.S.Y.Z.[.^/l/o2b3Y3Z4_6o7QQ%wxQ%{yW&Q|&V&W+}Q&_!TQ'c!hQ'e!iQ(q#sS+m%|%}Q+q&PQ,^&bQ,b&dS-k'f'gQ.h(rQ1P+nQ1V+tQ1X+uQ1[+yQ1r,_S1v,c,dQ2z-lQ5b1RQ5f1UQ5k1^Q6W1wQ8[5dQ8_5hQ8c5mQ:Q8ZR;Q:R!U$zi$d%O%Q%^%_%c*R*T*`*v*w/O/v0^0`0g0h0m4]4}8S9m=|>U>V!^%yy!i!u%{%|%}'V'e'f'g'k'u*i+m+n-X-k-l-s0P0S1P2s2z3R4o4p4s7z9xQ+g%wQ,S&[Q,V&]Q,a&dQ.g(qQ1q,^U1u,b,c,dQ3c.hQ6R1rS6V1v1wQ8u6W#f>Q#v$b$c$x${)y*V*Y*f+e+h,R,U.e/c/l/w/y1d1g1o3a4[4g4l5X5[6P7T7s7}8X8n9_9v9|:]:o:};X;a;h<l<n<r<t<v=P=R=U=Y=[=^=`=d>Y>Zo>R<i<j<m<o<s<u<w=Q=S=V=Z=]=_=a=eW%Ti%V*x=|S&[!Q&iQ&]!RQ&^!SU*|%[%d=pR,Q&Y%]%Si#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*`*f*v*w+e+h,R,U.e/O/c/l/v/w/y0^0`0g0h0m1d1g1o3a4[4]4g4l4}5X5[6P7T7s7}8S8X8n9_9m9v9|:]:o:};X;a;h<i<j<l<m<n<o<r<s<t<u<v<w=P=Q=R=S=U=V=Y=Z=[=]=^=_=`=a=d=e=|>U>V>Y>ZT)z$u){V+O%]<p<qW'[!e%i*Z-_S(}#y#zQ+b%rQ+x&SS.a(m(nQ1h,WQ5Q0iR8f5r'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*h+W+[+f,o,r,w-T-W-h-p.O.U.f.s.z/U/m0Z0j0p1Q1p2Q2R2T2V2Y2]2_2n3O3U3b3j4R4w5t6Q6b6c6f6p6y7X8q9Q9[:W:j<R<U<V<Y<Z<[<]<^<_<`<a<b<c<d<e<f<h<k<x<{<|=O=W=X=b=c>P$i$^c#Y#e%q%s%u(S(Y(t(y)R)S)T)U)V)W)X)Y)Z)[)^)`)b)g)q+c+w-Y-w-|.R.T.r.u.y.{.|.}/a0n2i2l2|3T3i3n3o3p3q3r3s3t3u3v3w3x3y3z3}4O4V5U5`6r6x6}7^7_7h7i8h9U9Y9d9j9k:l;T;]<T=sT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*h+W+[+f,o,r,w-T-W-h-p.O.U.f.s.z/U/m0Z0j0p1Q1p2Q2R2T2V2Y2]2_2n3O3U3b3j4R4w5t6Q6b6c6f6p6y7X8q9Q9[:W:j<R<U<V<Y<Z<[<]<^<_<`<a<b<c<d<e<f<h<k<x<{<|=O=W=X=b=c>PQ'Y!eR2o-[!W!nQ!e!r!v!y!z$|'W'_'`'l'm'n*Z*j*n*p*q-[-b-d-t0Y0]1m5x5zR1j,YnqOXst!Z#d%m&r&t&u&w,r,w2Y2]Q&y!^Q'v!xS(s#u<ZQ+k%zQ,[&_Q,]&aQ-i'dQ-v'oS.q(x<|S0o+W=WQ0}+lQ1l,ZQ2a,yQ2c,zQ2k-VQ2x-jQ2{-nS5V0p=bQ5^1OS5a1Q=cQ6q2mQ6u2yQ6z3QQ8Y5_Q9V6sQ9W6vQ9Z6{R:i9S$d$]c#Y#e%s%u(S(Y(t(y)R)S)T)U)V)W)X)Y)Z)[)^)`)b)g)q+c+w-Y-w-|.R.T.r.u.y.|.}/a0n2i2l2|3T3i3n3o3p3q3r3s3t3u3v3w3x3y3z3}4O4V5U5`6r6x6}7^7_7h7i8h9U9Y9d9j9k:l;T;]<T=sS(o#p'iQ)P#zS+a%q.{S.b(n(pR3[.c'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*h+W+[+f,o,r,w-T-W-h-p.O.U.f.s.z/U/m0Z0j0p1Q1p2Q2R2T2V2Y2]2_2n3O3U3b3j4R4w5t6Q6b6c6f6p6y7X8q9Q9[:W:j<R<U<V<Y<Z<[<]<^<_<`<a<b<c<d<e<f<h<k<x<{<|=O=W=X=b=c>PS#q]<SQ&t!XQ&u!YQ&w![Q&x!]R2X,uQ'a!hQ+d%wQ-g'cS.d(q+gQ2v-fW3`.g.h0u0wQ6t2wW7R3]3_3c5ZU9^7S7U7WU:n9`9a9cS;_:m:pQ;m;`R;u;nU!wQ'`-dT5v1m5x!Q_OXZ`st!V!Z#d#h%e%m&i&k&r&t&u&w(j,r,w.Z2Y2]]!pQ!r'`-d1m5xT#q]<S%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*h+W+[+f,o,r,w-h-p.O.U.f.s.z/m0Z0j0p1Q1p2Q2R2T2V2Y2]2_3O3U3b3j4w6Q6b6c6f6y7X8q9Q9[S(}#y#zS.a(m(n!s=i$Z$n'X)s-T-W/U2n4R5t6p:W:j<R<U<V<Y<Z<[<]<^<_<`<a<b<c<d<e<f<h<k<x<{<|=O=W=X=b=c>PU$fd)_,lS(p#p'iU*u%R(w3|U0k*}.m7dQ5Z0vQ7S3^Q9a7VR:p9bm!tQ!r!v!y!z'`'l'm'n-d-t1m5x5zQ't!uS(f#g2SS-r'k'wQ/r*]Q0P*iQ3S-uQ4c/sQ4o0RQ4p0SQ4u0[Q7o4^S7z4q4sS8O4v4xQ9o7pQ9s7vQ9x7{Q9}8QS:x9t9uS;d:y:|S;p;e;fS;x;q;rS;|;y;zR<P;}Q#wbQ's!uS(e#g2SS(g#m+VQ+X%fQ+i%xQ+o&OU-q'k't'wQ.V(fQ/q*]Q0Q*iQ0T*kQ0|+jQ1s,`S3P-r-uQ3X._S4b/r/sQ4k/}S4n0P0[Q4r0UQ6T1tQ6|3SQ7n4^Q7r4cU7y4o4u4xQ7|4tQ8s6US9n7o7pQ9r7vQ9z8OQ9{8PQ:`8tQ:v9oS:w9s9uQ;P9}Q;Z:aS;c:x:|S;o;d;eS;w;p;rS;{;x;zQ<O;|Q<Q<PQ=l=gQ=x=qR=y=rV!wQ'`-d%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*h+W+[+f,o,r,w-h-p.O.U.f.s.z/m0Z0j0p1Q1p2Q2R2T2V2Y2]2_3O3U3b3j4w6Q6b6c6f6y7X8q9Q9[S#wz!j!r=f$Z$n'X)s-T-W/U2n4R5t6p:W:j<R<U<V<Y<Z<[<]<^<_<`<a<b<c<d<e<f<h<k<x<{<|=O=W=X=b=c>PR=l>O%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*h+W+[+f,o,r,w-h-p.O.U.f.s.z/m0Z0j0p1Q1p2Q2R2T2V2Y2]2_3O3U3b3j4w6Q6b6c6f6y7X8q9Q9[Q%fj!^%xy!i!u%{%|%}'V'e'f'g'k'u*i+m+n-X-k-l-s0P0S1P2s2z3R4o4p4s7z9xS&Oz!jQ+j%yQ,`&dW1t,a,b,c,dU6U1u1v1wS8t6V6WQ:a8u!r=g$Z$n'X)s-T-W/U2n4R5t6p:W:j<R<U<V<Y<Z<[<]<^<_<`<a<b<c<d<e<f<h<k<x<{<|=O=W=X=b=c>PQ=q=}R=r>O%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(V(](d(x(z)O)}*h+W+[+f,o,r,w-h-p.O.U.f.s.z/m0Z0j0p1Q1p2Q2R2T2V2Y2]2_3O3U3b3j4w6Q6b6c6f6y7X8q9Q9[Y#bWZ#W#Z(T!b%jm#h#i#l$x%e%h(^(h(i(j*Y*^*a+Y+Z+],n-U.S.Y.Z.[.^/l/o2b3Y3Z4_6o7QQ,m&o!p=h$Z$n)s-T-W/U2n4R5t6p:W:j<R<U<V<Y<Z<[<]<^<_<`<a<b<c<d<e<f<h<k<x<{<|=O=W=X=b=c>PR=k'XU']!e%i*ZR2q-_%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*h+W+[,o,r,w-h-p.O.U.s.z/m0Z0j0p1Q1p2Q2R2T2V2Y2]2_3O3U3j4w6Q6b6c6f6y8q9Q9[!r)_$Z$n'X)s-T-W/U2n4R5t6p:W:j<R<U<V<Y<Z<[<]<^<_<`<a<b<c<d<e<f<h<k<x<{<|=O=W=X=b=c>PQ,l&oQ0v+fQ3^.fQ7V3bR9b7X!b$Tc#Y%q(S(Y(t(y)Z)[)`)g+w-w-|.R.T.r.u/a0n2|3T3i3y5U5`6x6}7^9Y:l<T!P<a)^)q-Y.{2i2l3n3w3x3}4V6r7_7h7i8h9U9d9j9k;T;]=s!f$Vc#Y%q(S(Y(t(y)W)X)Z)[)`)g+w-w-|.R.T.r.u/a0n2|3T3i3y5U5`6x6}7^9Y:l<T!T<c)^)q-Y.{2i2l3n3t3u3w3x3}4V6r7_7h7i8h9U9d9j9k;T;]=s!^$Zc#Y%q(S(Y(t(y)`)g+w-w-|.R.T.r.u/a0n2|3T3i3y5U5`6x6}7^9Y:l<TQ4]/jz>P)^)q-Y.{2i2l3n3}4V6r7_7h7i8h9U9d9j9k;T;]=sQ>U>WR>V>X'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*h+W+[+f,o,r,w-T-W-h-p.O.U.f.s.z/U/m0Z0j0p1Q1p2Q2R2T2V2Y2]2_2n3O3U3b3j4R4w5t6Q6b6c6f6p6y7X8q9Q9[:W:j<R<U<V<Y<Z<[<]<^<_<`<a<b<c<d<e<f<h<k<x<{<|=O=W=X=b=c>PS$oh$pR4S/T'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*h+W+[+f,o,r,w-T-W-h-p.O.U.f.s.z/T/U/m0Z0j0p1Q1p2Q2R2T2V2Y2]2_2n3O3U3b3j4R4w5t6Q6b6c6f6p6y7X8q9Q9[:W:j<R<U<V<Y<Z<[<]<^<_<`<a<b<c<d<e<f<h<k<x<{<|=O=W=X=b=c>PT$kf$qQ$ifS)j$l)nR)v$qT$jf$qT)l$l)n'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*h+W+[+f,o,r,w-T-W-h-p.O.U.f.s.z/T/U/m0Z0j0p1Q1p2Q2R2T2V2Y2]2_2n3O3U3b3j4R4w5t6Q6b6c6f6p6y7X8q9Q9[:W:j<R<U<V<Y<Z<[<]<^<_<`<a<b<c<d<e<f<h<k<x<{<|=O=W=X=b=c>PT$oh$pQ$rhR)u$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*h+W+[+f,o,r,w-h-p.O.U.f.s.z/m0Z0j0p1Q1p2Q2R2T2V2Y2]2_3O3U3b3j4w6Q6b6c6f6y7X8q9Q9[!s=}$Z$n'X)s-T-W/U2n4R5t6p:W:j<R<U<V<Y<Z<[<]<^<_<`<a<b<c<d<e<f<h<k<x<{<|=O=W=X=b=c>P#glOPXZst!Z!`!o#S#d#o#{$n%m&k&n&o&r&t&u&w&{'T'b)O)s*h+[+f,o,r,w-h.f/U/m0Z0j1p2Q2R2T2V2Y2]2_3b4R4w6Q6b6c6f7X8q9Q!U%Ri$d%O%Q%^%_%c*R*T*`*v*w/O/v0^0`0g0h0m4]4}8S9m=|>U>V#f(w#v$b$c$x${)y*V*Y*f+e+h,R,U.e/c/l/w/y1d1g1o3a4[4g4l5X5[6P7T7s7}8X8n9_9v9|:]:o:};X;a;h<l<n<r<t<v=P=R=U=Y=[=^=`=d>Y>ZQ+S%aQ/b*Oo3|<i<j<m<o<s<u<w=Q=S=V=Z=]=_=a=e!U$yi$d%O%Q%^%_%c*R*T*`*v*w/O/v0^0`0g0h0m4]4}8S9m=|>U>VQ*b$zU*k$|*Z*nQ+T%bQ0U*l#f=n#v$b$c$x${)y*V*Y*f+e+h,R,U.e/c/l/w/y1d1g1o3a4[4g4l5X5[6P7T7s7}8X8n9_9v9|:]:o:};X;a;h<l<n<r<t<v=P=R=U=Y=[=^=`=d>Y>Zn=o<i<j<m<o<s<u<w=Q=S=V=Z=]=_=a=eQ=t>QQ=u>RQ=v>SR=w>T!U%Ri$d%O%Q%^%_%c*R*T*`*v*w/O/v0^0`0g0h0m4]4}8S9m=|>U>V#f(w#v$b$c$x${)y*V*Y*f+e+h,R,U.e/c/l/w/y1d1g1o3a4[4g4l5X5[6P7T7s7}8X8n9_9v9|:]:o:};X;a;h<l<n<r<t<v=P=R=U=Y=[=^=`=d>Y>Zo3|<i<j<m<o<s<u<w=Q=S=V=Z=]=_=a=enoOXst!Z#d%m&r&t&u&w,r,w2Y2]S*e${*YQ-Q'OQ-R'QR4f/w%[%Si#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*`*f*v*w+e+h,R,U.e/O/c/l/v/w/y0^0`0g0h0m1d1g1o3a4[4]4g4l4}5X5[6P7T7s7}8S8X8n9_9m9v9|:]:o:};X;a;h<i<j<l<m<n<o<r<s<t<u<v<w=P=Q=R=S=U=V=Y=Z=[=]=^=_=`=a=d=e=|>U>V>Y>ZQ,T&]Q1f,VQ5p1eR8e5qV*m$|*Z*nU*m$|*Z*nT5w1m5xS/}*h/mQ4t0ZT8P4w:YQ+i%xQ0T*kQ0|+jQ1s,`Q6T1tQ8s6UQ:`8tR;Z:a!U%Oi$d%O%Q%^%_%c*R*T*`*v*w/O/v0^0`0g0h0m4]4}8S9m=|>U>Vx*R$v)e*S*t+U/u0b0c4P4d5O5P5T7m8R:O:u=m=z={S0^*s0_#f<l#v$b$c$x${)y*V*Y*f+e+h,R,U.e/c/l/w/y1d1g1o3a4[4g4l5X5[6P7T7s7}8X8n9_9v9|:]:o:};X;a;h<l<n<r<t<v=P=R=U=Y=[=^=`=d>Y>Zn<m<i<j<m<o<s<u<w=Q=S=V=Z=]=_=a=e!d=P(u)c*[*d.i.l.p/^/j/z0t1c3f4Y4e4i5o7Y7]7t7w8U8W9q9y:P:z;O;b;g;s>W>X`=Q3{7`7c7g9e:q:t;vS=[.k3gT=]7b9h!U%Qi$d%O%Q%^%_%c*R*T*`*v*w/O/v0^0`0g0h0m4]4}8S9m=|>U>V|*T$v)e*U*s+U/f/u0b0c4P4d4y5O5P5T7m8R:O:u=m=z={S0`*t0a#f<n#v$b$c$x${)y*V*Y*f+e+h,R,U.e/c/l/w/y1d1g1o3a4[4g4l5X5[6P7T7s7}8X8n9_9v9|:]:o:};X;a;h<l<n<r<t<v=P=R=U=Y=[=^=`=d>Y>Zn<o<i<j<m<o<s<u<w=Q=S=V=Z=]=_=a=e!h=R(u)c*[*d.j.k.p/^/j/z0t1c3d3f4Y4e4i5o7Y7Z7]7t7w8U8W9q9y:P:z;O;b;g;s>W>Xd=S3{7a7b7g9e9f:q:r:t;vS=^.l3hT=_7c9irnOXst!V!Z#d%m&i&r&t&u&w,r,w2Y2]Q&f!UR,o&ornOXst!V!Z#d%m&i&r&t&u&w,r,w2Y2]R&f!UQ,X&^R1b,QsnOXst!V!Z#d%m&i&r&t&u&w,r,w2Y2]Q1n,^S6O1q1rU8m5|5}6RS:[8o8pS;V:Z:^Q;j;WR;t;kQ&m!VR,h&iR6[1zR:c8vW&Q|&V&W+}R1X+uQ&r!WR,r&sR,x&xT2Z,w2]R,|&yQ,{&yR2d,|Q'y!{R-x'ySsOtQ#dXT%ps#dQ#OTR'{#OQ#RUR'}#RQ){$uR/_){Q#UVR(Q#UQ#XWU(W#X(X.PQ(X#YR.P(YQ-]'YR2p-]Q.t(yS3k.t3lR3l.uQ-d'`R2t-dY!rQ'`-d1m5xR'j!rQ/P)eR4Q/PU#_W%h*YU(_#_(`.QQ(`#`R.Q(ZQ-`']R2r-`t`OXst!V!Z#d%m&i&k&r&t&u&w,r,w2Y2]S#hZ%eU#r`#h.ZR.Z(jQ(k#jQ.W(gW.`(k.W3V7OQ3V.XR7O3WQ)n$lR/V)nQ$phR)t$pQ$`cU)a$`-{<gQ-{<TR<g)qQ/p*]W4`/p4a7q9pU4a/q/r/sS7q4b4cR9p7r$e*Q$v(u)c)e*[*d*s*t+P+Q+U.k.l.n.o.p/^/f/h/j/u/z0b0c0t1c3d3e3f3{4P4Y4d4e4i4y4{5O5P5T5o7Y7Z7[7]7b7c7e7f7g7m7t7w8R8U8W9e9f9g9q9y:O:P:q:r:s:t:u:z;O;b;g;s;v=m=z={>W>XQ/x*dU4h/x4j7uQ4j/zR7u4iS*n$|*ZR0W*nx*S$v)e*s*t+U/u0b0c4P4d5O5P5T7m8R:O:u=m=z={!d.i(u)c*[*d.k.l.p/^/j/z0t1c3f4Y4e4i5o7Y7]7t7w8U8W9q9y:P:z;O;b;g;s>W>XU/g*S.i7`a7`3{7b7c7g9e:q:t;vQ0_*sQ3g.kU4z0_3g9hR9h7b|*U$v)e*s*t+U/f/u0b0c4P4d4y5O5P5T7m8R:O:u=m=z={!h.j(u)c*[*d.k.l.p/^/j/z0t1c3d3f4Y4e4i5o7Y7Z7]7t7w8U8W9q9y:P:z;O;b;g;s>W>XU/i*U.j7ae7a3{7b7c7g9e9f:q:r:t;vQ0a*tQ3h.lU4|0a3h9iR9i7cQ*y%UR0e*yQ5Y0tR8V5YQ+^%kR0s+^Q5s1hS8g5s:XR:X8hQ,Z&_R1k,ZQ5x1mR8j5xQ1y,eS6Y1y8wR8w6[Q1S+qW5e1S5g8^:SQ5g1VQ8^5fR:S8_Q+v&QR1Y+vQ2],wR6j2]YrOXst#dQ&v!ZQ+`%mQ,q&rQ,s&tQ,t&uQ,v&wQ2W,rS2Z,w2]R6i2YQ%opQ&z!_Q&}!aQ'P!bQ'R!cQ'q!uQ+_%lQ+k%zQ,P&XQ,g&mQ-O&|W-o'k's't'wQ-v'oQ0V*mQ0}+lQ1a,OS1|,h,kQ2e,}Q2f-QQ2g-RQ2{-nW2}-q-r-u-wQ5^1OQ5j1]Q5n1cQ6S1sQ6^2OQ6h2XU6w2|3P3SQ6z3QQ8Y5_Q8b5lQ8d5oQ8i5wQ8r6TQ8x6]S9X6x6|Q9Z6{Q:T8`Q:_8sQ:d8yQ:k9YQ;R:UQ;Y:`Q;^:lQ;i;SR;l;ZQ%zyQ'd!iQ'o!uU+l%{%|%}Q-V'VU-j'e'f'gS-n'k'uQ0O*iS1O+m+nQ2m-XS2y-k-lQ3Q-sS4m0P0SQ5_1PQ6s2sQ6v2zQ6{3RU7x4o4p4sQ9w7zR:{9xS$wi=|R*z%VU%Ui%V=|R0d*xQ$viS(u#v+hS)c$b$cQ)e$dQ*[$xS*d${*YQ*s%OQ*t%QQ+P%^Q+Q%_Q+U%cQ.k<lQ.l<nQ.n<rQ.o<tQ.p<vQ/^)yQ/f*RQ/h*TQ/j*VQ/u*`S/z*f/lQ0b*vQ0c*wl0t+e,U.e1g1o3a6P7T8n9_:]:o;X;aQ1c,RQ3d=PQ3e=RQ3f=US3{<i<jQ4P/OS4Y/c4[Q4d/vQ4e/wQ4i/yQ4y0^Q4{0`Q5O0gQ5P0hQ5T0mQ5o1dQ7Y=YQ7Z=[Q7[=^Q7]=`Q7b<mQ7c<oQ7e<sQ7f<uQ7g<wQ7m4]Q7t4gQ7w4lQ8R4}Q8U5XQ8W5[Q9e=VQ9f=QQ9g=SQ9q7sQ9y7}Q:O8SQ:P8XQ:q=ZQ:r=]Q:s=_Q:t=aQ:u9mQ:z9vQ;O9|Q;b=dQ;g:}Q;s;hQ;v=eQ=m=|Q=z>UQ={>VQ>W>YR>X>ZQ*}%]Q.m<pR7d<qnpOXst!Z#d%m&r&t&u&w,r,w2Y2]Q!fPS#fZ#oQ&|!`W'h!o*h0Z4wQ(P#SQ)Q#{Q)r$nS,k&k&nQ,p&oQ,}&{S-S'T/mQ-f'bQ.w)OQ/Z)sQ0q+[Q0w+fQ2U,oQ2w-hQ3_.fQ4U/UQ5R0jQ5}1pQ6`2QQ6a2RQ6e2TQ6g2VQ6l2_Q7W3bQ7j4RQ8p6QQ8|6bQ8}6cQ9P6fQ9c7XQ:^8qR:h9Q#[cOPXZst!Z!`!o#d#o#{%m&k&n&o&r&t&u&w&{'T'b)O*h+[+f,o,r,w-h.f/m0Z0j1p2Q2R2T2V2Y2]2_3b4w6Q6b6c6f7X8q9QQ#YWQ#eYQ%quQ%svS%uw!gS(S#W(VQ(Y#ZQ(t#uQ(y#xQ)R$OQ)S$PQ)T$QQ)U$RQ)V$SQ)W$TQ)X$UQ)Y$VQ)Z$WQ)[$XQ)^$ZQ)`$_Q)b$aQ)g$eW)q$n)s/U4RQ+c%tQ+w&RS-Y'X2nQ-w'rS-|(T.OQ.R(]Q.T(dQ.r(xQ.u(zQ.y<RQ.{<UQ.|<VQ.}<YQ/a)}Q0n+WQ2i-TQ2l-WQ2|-pQ3T.UQ3i.sQ3n<ZQ3o<[Q3p<]Q3q<^Q3r<_Q3s<`Q3t<aQ3u<bQ3v<cQ3w<dQ3x<eQ3y.zQ3z<hQ3}<kQ4O<xQ4V<fQ5U0pQ5`1QQ6r<{Q6x3OQ6}3UQ7^3jQ7_<|Q7h=OQ7i=WQ8h5tQ9U6pQ9Y6yQ9d=XQ9j=bQ9k=cQ:l9[Q;T:WQ;]:jQ<T#SR=s>PR#[WR'Z!el!tQ!r!v!y!z'`'l'm'n-d-t1m5x5zS'V!e-[U*i$|*Z*nS-X'W'_S0S*j*pQ0[*qQ2s-bQ4s0YR4x0]R({#xQ!fQT-c'`-d]!qQ!r'`-d1m5xQ#p]R'i<SR)f$dY!uQ'`-d1m5xQ'k!rS'u!v!yS'w!z5zS-s'l'mQ-u'nR3R-tT#kZ%eS#jZ%eS%km,nU(g#h#i#lS.X(h(iQ.](jQ0r+]Q3W.YU3X.Z.[.^S7P3Y3ZR9]7Qd#^W#W#Z%h(T(^*Y+Y.S/lr#gZm#h#i#l%e(h(i(j+].Y.Z.[.^3Y3Z7QS*]$x*aQ/s*^Q2S,nQ2j-UQ4^/oQ6n2bQ7p4_Q9T6oT=j'X+ZV#aW%h*YU#`W%h*YS(U#W(^U(Z#Z+Y/lS-Z'X+ZT-}(T.SV'^!e%i*ZQ$lfR)x$qT)m$l)nR4T/TT*_$x*aT*g${*YQ0u+eQ1e,UQ3].eQ5q1gQ5|1oQ7U3aQ8o6PQ9`7TQ:Z8nQ:m9_Q;W:]Q;`:oQ;k;XR;n;anqOXst!Z#d%m&r&t&u&w,r,w2Y2]Q&l!VR,g&itmOXst!U!V!Z#d%m&i&r&t&u&w,r,w2Y2]R,n&oT%lm,nR1i,WR,f&gQ&U|S+|&V&WR1[+}R+r&PT&p!W&sT&q!W&sT2[,w2]",
          nodeNames:
            " ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList in out const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration defer ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
          maxTerm: 380,
          context: My,
          nodeProps: [
            ["isolate", -8, 5, 6, 14, 37, 39, 51, 53, 55, ""],
            [
              "group",
              -26,
              9,
              17,
              19,
              68,
              207,
              211,
              215,
              216,
              218,
              221,
              224,
              234,
              237,
              243,
              245,
              247,
              249,
              252,
              258,
              264,
              266,
              268,
              270,
              272,
              274,
              275,
              "Statement",
              -34,
              13,
              14,
              32,
              35,
              36,
              42,
              51,
              54,
              55,
              57,
              62,
              70,
              72,
              76,
              80,
              82,
              84,
              85,
              110,
              111,
              120,
              121,
              136,
              139,
              141,
              142,
              143,
              144,
              145,
              147,
              148,
              167,
              169,
              171,
              "Expression",
              -23,
              31,
              33,
              37,
              41,
              43,
              45,
              173,
              175,
              177,
              178,
              180,
              181,
              182,
              184,
              185,
              186,
              188,
              189,
              190,
              201,
              203,
              205,
              206,
              "Type",
              -3,
              88,
              103,
              109,
              "ClassItem",
            ],
            [
              "openedBy",
              23,
              "<",
              38,
              "InterpolationStart",
              56,
              "[",
              60,
              "{",
              73,
              "(",
              160,
              "JSXStartCloseTag",
            ],
            [
              "closedBy",
              -2,
              24,
              168,
              ">",
              40,
              "InterpolationEnd",
              50,
              "]",
              61,
              "}",
              74,
              ")",
              165,
              "JSXEndTag",
            ],
          ],
          propSources: [Vy],
          skippedNodes: [0, 5, 6, 278],
          repeatNodeCount: 37,
          tokenData:
            "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$i&j(Z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(Z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$i&j(WpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(WpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$i&j(Wp(Z!b'|0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(X#S$i&j'}0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$i&j(Wp(Z!b'}0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$i&j!p),Q(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#v(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#v(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(V':f$i&j(Z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$i&j(Z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$i&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$d`$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$d``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$d`$i&j(Z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(Z!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$d`(Z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$i&j(Wp(Z!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$i&j(Wp(Z!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$i&j(Z!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$i&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(Z!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$i&j(WpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(WpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Wp(Z!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$i&j(o%1l(Wp(Z!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$i&j(Wp(Z!b$]#t(T,2j(e$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$i&j(Wp(Z!b$]#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$i&j(Wp(Z!b#p(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$i&j$Q(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(z+JY$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$i&j#z(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(Y';W$i&j(WpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$i&j(WpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$i&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$d`$i&j(WpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(WpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$d`(WpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!l/.^$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!k!Lf$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$i&j(Wp(Z!b(U%&f#q(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$i&j(Wp(Z!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$i&j(Wp(Z!br+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!]+Jf$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$i&j(Wp(Z!b!Q.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_![!L^$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$i&j(Wp(Z!b#o(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$i&j(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$i&j(Z!b!X7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$i&j!X7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$i&j!X7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!X7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!X7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$i&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$i&j(Z!b!X7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(Z!b!X7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(Z!b!X7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(Z!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$i&j(Z!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$i&j(Wp!X7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$i&j(Wp!X7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Wp!X7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Wp!X7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(WpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$i&j(WpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$i&j(Wp(Z!b!X7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Wp(Z!b!X7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Wp(Z!b!X7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Wp(Z!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$i&j(Wp(Z!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$i&j(Wp(Z!b(O0/l!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$i&j(Wp(Z!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$i&j(Z!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$i&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(Z!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$i&j(WpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(WpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Wp(Z!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$i&j$Q(Ch(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Z#t$i&j(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!g$b$i&j$O)Lv(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#R-<U(Wp(Z!b$n7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$k&j(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#r(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$Q(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#s(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#`*!Y$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#k(Cl$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#s(Ch$f#|$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#s(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#r(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#r(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(r(Ct$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$i&j#{(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!|$Ip$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!S0,v$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$i&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$i&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$i&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$i&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$i&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!Y#)l$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#x(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$i&j(Wp(Z!b(a+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$i&j(Wp(Z!b(T,2j$_#t(e$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$i&j(Wp(Z!b$_#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!_#Hb(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(y+JY$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!^(CdvBr$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!q7`$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$i&j(Wp(Z!b'|0/l$]#t(T,2j(e$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$i&j(Wp(Z!b'}0/l$]#t(T,2j(e$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
          tokenizers: [
            zy,
            Dy,
            Ey,
            _y,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            Yy,
            new kr(
              "$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOx~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!U~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(c~~",
              141,
              340
            ),
            new kr("j~RQYZXz{^~^O(Q~~aP!P!Qd~iO(R~~", 25, 323),
          ],
          topRules: {
            Script: [0, 7],
            SingleExpression: [1, 276],
            SingleClassItem: [2, 277],
          },
          dialects: { jsx: 0, ts: 15149 },
          dynamicPrecedences: { 80: 1, 82: 1, 94: 1, 169: 1, 199: 1 },
          specialized: [
            { term: 327, get: (n) => qy[n] || -1 },
            { term: 343, get: (n) => Wy[n] || -1 },
            { term: 95, get: (n) => Ly[n] || -1 },
          ],
          tokenPrec: 15175,
        }),
        ld = [
          ye("function ${name}(${params}) {\n	${}\n}", {
            label: "function",
            detail: "definition",
            type: "keyword",
          }),
          ye(
            "for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}",
            { label: "for", detail: "loop", type: "keyword" }
          ),
          ye("for (let ${name} of ${collection}) {\n	${}\n}", {
            label: "for",
            detail: "of loop",
            type: "keyword",
          }),
          ye("do {\n	${}\n} while (${})", {
            label: "do",
            detail: "loop",
            type: "keyword",
          }),
          ye("while (${}) {\n	${}\n}", {
            label: "while",
            detail: "loop",
            type: "keyword",
          }),
          ye(
            `try {
	\${}
} catch (\${error}) {
	\${}
}`,
            { label: "try", detail: "/ catch block", type: "keyword" }
          ),
          ye("if (${}) {\n	${}\n}", {
            label: "if",
            detail: "block",
            type: "keyword",
          }),
          ye(
            `if (\${}) {
	\${}
} else {
	\${}
}`,
            { label: "if", detail: "/ else block", type: "keyword" }
          ),
          ye(
            `class \${name} {
	constructor(\${params}) {
		\${}
	}
}`,
            { label: "class", detail: "definition", type: "keyword" }
          ),
          ye('import {${names}} from "${module}"\n${}', {
            label: "import",
            detail: "named",
            type: "keyword",
          }),
          ye('import ${name} from "${module}"\n${}', {
            label: "import",
            detail: "default",
            type: "keyword",
          }),
        ],
        By = ld.concat([
          ye("interface ${name} {\n	${}\n}", {
            label: "interface",
            detail: "definition",
            type: "keyword",
          }),
          ye("type ${name} = ${type}", {
            label: "type",
            detail: "definition",
            type: "keyword",
          }),
          ye("enum ${name} {\n	${}\n}", {
            label: "enum",
            detail: "definition",
            type: "keyword",
          }),
        ]),
        Yh = new Sf(),
        ad = new Set([
          "Script",
          "Block",
          "FunctionExpression",
          "FunctionDeclaration",
          "ArrowFunction",
          "MethodDeclaration",
          "ForStatement",
        ]);
      function vi(n) {
        return (e, t) => {
          let i = e.node.getChild("VariableDefinition");
          return i && t(i, n), !0;
        };
      }
      const Iy = ["FunctionDeclaration"],
        Gy = {
          FunctionDeclaration: vi("function"),
          ClassDeclaration: vi("class"),
          ClassExpression: () => !0,
          EnumDeclaration: vi("constant"),
          TypeAliasDeclaration: vi("type"),
          NamespaceDeclaration: vi("namespace"),
          VariableDefinition(n, e) {
            n.matchContext(Iy) || e(n, "variable");
          },
          TypeDefinition(n, e) {
            e(n, "type");
          },
          __proto__: null,
        };
      function hd(n, e) {
        let t = Yh.get(e);
        if (t) return t;
        let i = [],
          r = !0;
        function s(o, l) {
          let a = n.sliceString(o.from, o.to);
          i.push({ label: a, type: l });
        }
        return (
          e.cursor(N.IncludeAnonymous).iterate((o) => {
            if (r) r = !1;
            else if (o.name) {
              let l = Gy[o.name];
              if ((l && l(o, s)) || ad.has(o.name)) return !1;
            } else if (o.to - o.from > 8192) {
              for (let l of hd(n, o.node)) i.push(l);
              return !1;
            }
          }),
          Yh.set(e, i),
          i
        );
      }
      const zh = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/,
        cd = [
          "TemplateString",
          "String",
          "RegExp",
          "LineComment",
          "BlockComment",
          "VariableDefinition",
          "TypeDefinition",
          "Label",
          "PropertyDefinition",
          "PropertyName",
          "PrivatePropertyDefinition",
          "PrivatePropertyName",
          "JSXText",
          "JSXAttributeValue",
          "JSXOpenTag",
          "JSXCloseTag",
          "JSXSelfClosingTag",
          ".",
          "?.",
        ];
      function Ny(n) {
        let e = J(n.state).resolveInner(n.pos, -1);
        if (cd.indexOf(e.name) > -1) return null;
        let t =
          e.name == "VariableName" ||
          (e.to - e.from < 20 && zh.test(n.state.sliceDoc(e.from, e.to)));
        if (!t && !n.explicit) return null;
        let i = [];
        for (let r = e; r; r = r.parent)
          ad.has(r.name) && (i = i.concat(hd(n.state.doc, r)));
        return { options: i, from: t ? e.from : n.pos, validFor: zh };
      }
      const st = ci.define({
          name: "javascript",
          parser: jy.configure({
            props: [
              _r.add({
                IfStatement: Nn({ except: /^\s*({|else\b)/ }),
                TryStatement: Nn({ except: /^\s*({|catch\b|finally\b)/ }),
                LabeledStatement: tg,
                SwitchBody: (n) => {
                  let e = n.textAfter,
                    t = /^\s*\}/.test(e),
                    i = /^\s*(case|default)\b/.test(e);
                  return n.baseIndent + (t ? 0 : i ? 1 : 2) * n.unit;
                },
                Block: eg({ closing: "}" }),
                ArrowFunction: (n) => n.baseIndent + n.unit,
                "TemplateString BlockComment": () => null,
                "Statement Property": Nn({ except: /^\s*{/ }),
                JSXElement(n) {
                  let e = /^\s*<\//.test(n.textAfter);
                  return n.lineIndent(n.node.from) + (e ? 0 : n.unit);
                },
                JSXEscape(n) {
                  let e = /\s*\}/.test(n.textAfter);
                  return n.lineIndent(n.node.from) + (e ? 0 : n.unit);
                },
                "JSXOpenTag JSXSelfClosingTag"(n) {
                  return n.column(n.node.from) + n.unit;
                },
              }),
              Vr.add({
                "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType":
                  vf,
                BlockComment(n) {
                  return { from: n.from + 2, to: n.to - 2 };
                },
              }),
            ],
          }),
          languageData: {
            closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
            commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
            indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
            wordChars: "$",
          },
        }),
        fd = {
          test: (n) => /^JSX/.test(n.name),
          facet: wf({
            commentTokens: { block: { open: "{/*", close: "*/}" } },
          }),
        },
        ud = st.configure({ dialect: "ts" }, "typescript"),
        dd = st.configure({
          dialect: "jsx",
          props: [No.add((n) => (n.isTop ? [fd] : void 0))],
        }),
        Od = st.configure(
          {
            dialect: "jsx ts",
            props: [No.add((n) => (n.isTop ? [fd] : void 0))],
          },
          "typescript"
        );
      let pd = (n) => ({ label: n, type: "keyword" });
      const md =
          "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield"
            .split(" ")
            .map(pd),
        Uy = md.concat(
          ["declare", "implements", "private", "protected", "public"].map(pd)
        );
      function Fy(n = {}) {
        let e = n.jsx ? (n.typescript ? Od : dd) : n.typescript ? ud : st,
          t = n.typescript ? By.concat(Uy) : ld.concat(md);
        return new Uo(e, [
          st.data.of({ autocomplete: yQ(cd, vu(t)) }),
          st.data.of({ autocomplete: Ny }),
          n.jsx ? Jy : [],
        ]);
      }
      function Hy(n) {
        for (;;) {
          if (
            n.name == "JSXOpenTag" ||
            n.name == "JSXSelfClosingTag" ||
            n.name == "JSXFragmentTag"
          )
            return n;
          if (n.name == "JSXEscape" || !n.parent) return null;
          n = n.parent;
        }
      }
      function Dh(n, e, t = n.length) {
        for (let i = e?.firstChild; i; i = i.nextSibling)
          if (
            i.name == "JSXIdentifier" ||
            i.name == "JSXBuiltin" ||
            i.name == "JSXNamespacedName" ||
            i.name == "JSXMemberExpression"
          )
            return n.sliceString(i.from, Math.min(i.to, t));
        return "";
      }
      const Ky =
          typeof navigator == "object" && /Android\b/.test(navigator.userAgent),
        Jy = v.inputHandler.of((n, e, t, i, r) => {
          if (
            (Ky ? n.composing : n.compositionStarted) ||
            n.state.readOnly ||
            e != t ||
            (i != ">" && i != "/") ||
            !st.isActiveAt(n.state, e, -1)
          )
            return !1;
          let s = r(),
            { state: o } = s,
            l = o.changeByRange((a) => {
              var h;
              let { head: c } = a,
                f = J(o).resolveInner(c - 1, -1),
                u;
              if (
                (f.name == "JSXStartTag" && (f = f.parent),
                !(
                  o.doc.sliceString(c - 1, c) != i ||
                  (f.name == "JSXAttributeValue" && f.to > c)
                ))
              ) {
                if (i == ">" && f.name == "JSXFragmentTag")
                  return { range: a, changes: { from: c, insert: "</>" } };
                if (i == "/" && f.name == "JSXStartCloseTag") {
                  let d = f.parent,
                    O = d.parent;
                  if (
                    O &&
                    d.from == c - 2 &&
                    ((u = Dh(o.doc, O.firstChild, c)) ||
                      ((h = O.firstChild) === null || h === void 0
                        ? void 0
                        : h.name) == "JSXFragmentTag")
                  ) {
                    let m = `${u}>`;
                    return {
                      range: S.cursor(c + m.length, -1),
                      changes: { from: c, insert: m },
                    };
                  }
                } else if (i == ">") {
                  let d = Hy(f);
                  if (
                    d &&
                    d.name == "JSXOpenTag" &&
                    !/^\/?>|^<\//.test(o.doc.sliceString(c, c + 2)) &&
                    (u = Dh(o.doc, d, c))
                  )
                    return {
                      range: a,
                      changes: { from: c, insert: `</${u}>` },
                    };
                }
              }
              return { range: a };
            });
          return l.changes.empty
            ? !1
            : (n.dispatch([
                s,
                o.update(l, {
                  userEvent: "input.complete",
                  scrollIntoView: !0,
                }),
              ]),
              !0);
        }),
        Ti = ["_blank", "_self", "_top", "_parent"],
        Ps = ["ascii", "utf-8", "utf-16", "latin1", "latin1"],
        vs = ["get", "post", "put", "delete"],
        Ts = [
          "application/x-www-form-urlencoded",
          "multipart/form-data",
          "text/plain",
        ],
        Ce = ["true", "false"],
        Z = {},
        eb = {
          a: {
            attrs: {
              href: null,
              ping: null,
              type: null,
              media: null,
              target: Ti,
              hreflang: null,
            },
          },
          abbr: Z,
          address: Z,
          area: {
            attrs: {
              alt: null,
              coords: null,
              href: null,
              target: null,
              ping: null,
              media: null,
              hreflang: null,
              type: null,
              shape: ["default", "rect", "circle", "poly"],
            },
          },
          article: Z,
          aside: Z,
          audio: {
            attrs: {
              src: null,
              mediagroup: null,
              crossorigin: ["anonymous", "use-credentials"],
              preload: ["none", "metadata", "auto"],
              autoplay: ["autoplay"],
              loop: ["loop"],
              controls: ["controls"],
            },
          },
          b: Z,
          base: { attrs: { href: null, target: Ti } },
          bdi: Z,
          bdo: Z,
          blockquote: { attrs: { cite: null } },
          body: Z,
          br: Z,
          button: {
            attrs: {
              form: null,
              formaction: null,
              name: null,
              value: null,
              autofocus: ["autofocus"],
              disabled: ["autofocus"],
              formenctype: Ts,
              formmethod: vs,
              formnovalidate: ["novalidate"],
              formtarget: Ti,
              type: ["submit", "reset", "button"],
            },
          },
          canvas: { attrs: { width: null, height: null } },
          caption: Z,
          center: Z,
          cite: Z,
          code: Z,
          col: { attrs: { span: null } },
          colgroup: { attrs: { span: null } },
          command: {
            attrs: {
              type: ["command", "checkbox", "radio"],
              label: null,
              icon: null,
              radiogroup: null,
              command: null,
              title: null,
              disabled: ["disabled"],
              checked: ["checked"],
            },
          },
          data: { attrs: { value: null } },
          datagrid: {
            attrs: { disabled: ["disabled"], multiple: ["multiple"] },
          },
          datalist: { attrs: { data: null } },
          dd: Z,
          del: { attrs: { cite: null, datetime: null } },
          details: { attrs: { open: ["open"] } },
          dfn: Z,
          div: Z,
          dl: Z,
          dt: Z,
          em: Z,
          embed: {
            attrs: { src: null, type: null, width: null, height: null },
          },
          eventsource: { attrs: { src: null } },
          fieldset: {
            attrs: { disabled: ["disabled"], form: null, name: null },
          },
          figcaption: Z,
          figure: Z,
          footer: Z,
          form: {
            attrs: {
              action: null,
              name: null,
              "accept-charset": Ps,
              autocomplete: ["on", "off"],
              enctype: Ts,
              method: vs,
              novalidate: ["novalidate"],
              target: Ti,
            },
          },
          h1: Z,
          h2: Z,
          h3: Z,
          h4: Z,
          h5: Z,
          h6: Z,
          head: {
            children: [
              "title",
              "base",
              "link",
              "style",
              "meta",
              "script",
              "noscript",
              "command",
            ],
          },
          header: Z,
          hgroup: Z,
          hr: Z,
          html: { attrs: { manifest: null } },
          i: Z,
          iframe: {
            attrs: {
              src: null,
              srcdoc: null,
              name: null,
              width: null,
              height: null,
              sandbox: [
                "allow-top-navigation",
                "allow-same-origin",
                "allow-forms",
                "allow-scripts",
              ],
              seamless: ["seamless"],
            },
          },
          img: {
            attrs: {
              alt: null,
              src: null,
              ismap: null,
              usemap: null,
              width: null,
              height: null,
              crossorigin: ["anonymous", "use-credentials"],
            },
          },
          input: {
            attrs: {
              alt: null,
              dirname: null,
              form: null,
              formaction: null,
              height: null,
              list: null,
              max: null,
              maxlength: null,
              min: null,
              name: null,
              pattern: null,
              placeholder: null,
              size: null,
              src: null,
              step: null,
              value: null,
              width: null,
              accept: ["audio/*", "video/*", "image/*"],
              autocomplete: ["on", "off"],
              autofocus: ["autofocus"],
              checked: ["checked"],
              disabled: ["disabled"],
              formenctype: Ts,
              formmethod: vs,
              formnovalidate: ["novalidate"],
              formtarget: Ti,
              multiple: ["multiple"],
              readonly: ["readonly"],
              required: ["required"],
              type: [
                "hidden",
                "text",
                "search",
                "tel",
                "url",
                "email",
                "password",
                "datetime",
                "date",
                "month",
                "week",
                "time",
                "datetime-local",
                "number",
                "range",
                "color",
                "checkbox",
                "radio",
                "file",
                "submit",
                "image",
                "reset",
                "button",
              ],
            },
          },
          ins: { attrs: { cite: null, datetime: null } },
          kbd: Z,
          keygen: {
            attrs: {
              challenge: null,
              form: null,
              name: null,
              autofocus: ["autofocus"],
              disabled: ["disabled"],
              keytype: ["RSA"],
            },
          },
          label: { attrs: { for: null, form: null } },
          legend: Z,
          li: { attrs: { value: null } },
          link: {
            attrs: {
              href: null,
              type: null,
              hreflang: null,
              media: null,
              sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"],
            },
          },
          map: { attrs: { name: null } },
          mark: Z,
          menu: {
            attrs: { label: null, type: ["list", "context", "toolbar"] },
          },
          meta: {
            attrs: {
              content: null,
              charset: Ps,
              name: [
                "viewport",
                "application-name",
                "author",
                "description",
                "generator",
                "keywords",
              ],
              "http-equiv": [
                "content-language",
                "content-type",
                "default-style",
                "refresh",
              ],
            },
          },
          meter: {
            attrs: {
              value: null,
              min: null,
              low: null,
              high: null,
              max: null,
              optimum: null,
            },
          },
          nav: Z,
          noscript: Z,
          object: {
            attrs: {
              data: null,
              type: null,
              name: null,
              usemap: null,
              form: null,
              width: null,
              height: null,
              typemustmatch: ["typemustmatch"],
            },
          },
          ol: {
            attrs: {
              reversed: ["reversed"],
              start: null,
              type: ["1", "a", "A", "i", "I"],
            },
            children: ["li", "script", "template", "ul", "ol"],
          },
          optgroup: { attrs: { disabled: ["disabled"], label: null } },
          option: {
            attrs: {
              disabled: ["disabled"],
              label: null,
              selected: ["selected"],
              value: null,
            },
          },
          output: { attrs: { for: null, form: null, name: null } },
          p: Z,
          param: { attrs: { name: null, value: null } },
          pre: Z,
          progress: { attrs: { value: null, max: null } },
          q: { attrs: { cite: null } },
          rp: Z,
          rt: Z,
          ruby: Z,
          samp: Z,
          script: {
            attrs: {
              type: ["text/javascript"],
              src: null,
              async: ["async"],
              defer: ["defer"],
              charset: Ps,
            },
          },
          section: Z,
          select: {
            attrs: {
              form: null,
              name: null,
              size: null,
              autofocus: ["autofocus"],
              disabled: ["disabled"],
              multiple: ["multiple"],
            },
          },
          slot: { attrs: { name: null } },
          small: Z,
          source: { attrs: { src: null, type: null, media: null } },
          span: Z,
          strong: Z,
          style: { attrs: { type: ["text/css"], media: null, scoped: null } },
          sub: Z,
          summary: Z,
          sup: Z,
          table: Z,
          tbody: Z,
          td: { attrs: { colspan: null, rowspan: null, headers: null } },
          template: Z,
          textarea: {
            attrs: {
              dirname: null,
              form: null,
              maxlength: null,
              name: null,
              placeholder: null,
              rows: null,
              cols: null,
              autofocus: ["autofocus"],
              disabled: ["disabled"],
              readonly: ["readonly"],
              required: ["required"],
              wrap: ["soft", "hard"],
            },
          },
          tfoot: Z,
          th: {
            attrs: {
              colspan: null,
              rowspan: null,
              headers: null,
              scope: ["row", "col", "rowgroup", "colgroup"],
            },
          },
          thead: Z,
          time: { attrs: { datetime: null } },
          title: Z,
          tr: Z,
          track: {
            attrs: {
              src: null,
              label: null,
              default: null,
              kind: [
                "subtitles",
                "captions",
                "descriptions",
                "chapters",
                "metadata",
              ],
              srclang: null,
            },
          },
          ul: { children: ["li", "script", "template", "ul", "ol"] },
          var: Z,
          video: {
            attrs: {
              src: null,
              poster: null,
              width: null,
              height: null,
              crossorigin: ["anonymous", "use-credentials"],
              preload: ["auto", "metadata", "none"],
              autoplay: ["autoplay"],
              mediagroup: ["movie"],
              muted: ["muted"],
              controls: ["controls"],
            },
          },
          wbr: Z,
        },
        gd = {
          accesskey: null,
          class: null,
          contenteditable: Ce,
          contextmenu: null,
          dir: ["ltr", "rtl", "auto"],
          draggable: ["true", "false", "auto"],
          dropzone: ["copy", "move", "link", "string:", "file:"],
          hidden: ["hidden"],
          id: null,
          inert: ["inert"],
          itemid: null,
          itemprop: null,
          itemref: null,
          itemscope: ["itemscope"],
          itemtype: null,
          lang: [
            "ar",
            "bn",
            "de",
            "en-GB",
            "en-US",
            "es",
            "fr",
            "hi",
            "id",
            "ja",
            "pa",
            "pt",
            "ru",
            "tr",
            "zh",
          ],
          spellcheck: Ce,
          autocorrect: Ce,
          autocapitalize: Ce,
          style: null,
          tabindex: null,
          title: null,
          translate: ["yes", "no"],
          rel: [
            "stylesheet",
            "alternate",
            "author",
            "bookmark",
            "help",
            "license",
            "next",
            "nofollow",
            "noreferrer",
            "prefetch",
            "prev",
            "search",
            "tag",
          ],
          role: "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(
            " "
          ),
          "aria-activedescendant": null,
          "aria-atomic": Ce,
          "aria-autocomplete": ["inline", "list", "both", "none"],
          "aria-busy": Ce,
          "aria-checked": ["true", "false", "mixed", "undefined"],
          "aria-controls": null,
          "aria-describedby": null,
          "aria-disabled": Ce,
          "aria-dropeffect": null,
          "aria-expanded": ["true", "false", "undefined"],
          "aria-flowto": null,
          "aria-grabbed": ["true", "false", "undefined"],
          "aria-haspopup": Ce,
          "aria-hidden": Ce,
          "aria-invalid": ["true", "false", "grammar", "spelling"],
          "aria-label": null,
          "aria-labelledby": null,
          "aria-level": null,
          "aria-live": ["off", "polite", "assertive"],
          "aria-multiline": Ce,
          "aria-multiselectable": Ce,
          "aria-owns": null,
          "aria-posinset": null,
          "aria-pressed": ["true", "false", "mixed", "undefined"],
          "aria-readonly": Ce,
          "aria-relevant": null,
          "aria-required": Ce,
          "aria-selected": ["true", "false", "undefined"],
          "aria-setsize": null,
          "aria-sort": ["ascending", "descending", "none", "other"],
          "aria-valuemax": null,
          "aria-valuemin": null,
          "aria-valuenow": null,
          "aria-valuetext": null,
        },
        Qd =
          "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload"
            .split(" ")
            .map((n) => "on" + n);
      for (let n of Qd) gd[n] = null;
      class Tr {
        constructor(e, t) {
          (this.tags = Object.assign(Object.assign({}, eb), e)),
            (this.globalAttrs = Object.assign(Object.assign({}, gd), t)),
            (this.allTags = Object.keys(this.tags)),
            (this.globalAttrNames = Object.keys(this.globalAttrs));
        }
      }
      Tr.default = new Tr();
      function pi(n, e, t = n.length) {
        if (!e) return "";
        let i = e.firstChild,
          r = i && i.getChild("TagName");
        return r ? n.sliceString(r.from, Math.min(r.to, t)) : "";
      }
      function mi(n, e = !1) {
        for (; n; n = n.parent)
          if (n.name == "Element")
            if (e) e = !1;
            else return n;
        return null;
      }
      function Sd(n, e, t) {
        let i = t.tags[pi(n, mi(e))];
        return i?.children || t.allTags;
      }
      function ml(n, e) {
        let t = [];
        for (let i = mi(e); i && !i.type.isTop; i = mi(i.parent)) {
          let r = pi(n, i);
          if (r && i.lastChild.name == "CloseTag") break;
          r &&
            t.indexOf(r) < 0 &&
            (e.name == "EndTag" || e.from >= i.firstChild.to) &&
            t.push(r);
        }
        return t;
      }
      const yd = /^[:\-\.\w\u00b7-\uffff]*$/;
      function Eh(n, e, t, i, r) {
        let s = /\s*>/.test(n.sliceDoc(r, r + 5)) ? "" : ">",
          o = mi(t, !0);
        return {
          from: i,
          to: r,
          options: Sd(n.doc, o, e)
            .map((l) => ({ label: l, type: "type" }))
            .concat(
              ml(n.doc, t).map((l, a) => ({
                label: "/" + l,
                apply: "/" + l + s,
                type: "type",
                boost: 99 - a,
              }))
            ),
          validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/,
        };
      }
      function _h(n, e, t, i) {
        let r = /\s*>/.test(n.sliceDoc(i, i + 5)) ? "" : ">";
        return {
          from: t,
          to: i,
          options: ml(n.doc, e).map((s, o) => ({
            label: s,
            apply: s + r,
            type: "type",
            boost: 99 - o,
          })),
          validFor: yd,
        };
      }
      function tb(n, e, t, i) {
        let r = [],
          s = 0;
        for (let o of Sd(n.doc, t, e)) r.push({ label: "<" + o, type: "type" });
        for (let o of ml(n.doc, t))
          r.push({ label: "</" + o + ">", type: "type", boost: 99 - s++ });
        return {
          from: i,
          to: i,
          options: r,
          validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/,
        };
      }
      function ib(n, e, t, i, r) {
        let s = mi(t),
          o = s ? e.tags[pi(n.doc, s)] : null,
          l = o && o.attrs ? Object.keys(o.attrs) : [],
          a =
            o && o.globalAttrs === !1
              ? l
              : l.length
              ? l.concat(e.globalAttrNames)
              : e.globalAttrNames;
        return {
          from: i,
          to: r,
          options: a.map((h) => ({ label: h, type: "property" })),
          validFor: yd,
        };
      }
      function nb(n, e, t, i, r) {
        var s;
        let o =
            (s = t.parent) === null || s === void 0
              ? void 0
              : s.getChild("AttributeName"),
          l = [],
          a;
        if (o) {
          let h = n.sliceDoc(o.from, o.to),
            c = e.globalAttrs[h];
          if (!c) {
            let f = mi(t),
              u = f ? e.tags[pi(n.doc, f)] : null;
            c = u?.attrs && u.attrs[h];
          }
          if (c) {
            let f = n.sliceDoc(i, r).toLowerCase(),
              u = '"',
              d = '"';
            /^['"]/.test(f)
              ? ((a = f[0] == '"' ? /^[^"]*$/ : /^[^']*$/),
                (u = ""),
                (d = n.sliceDoc(r, r + 1) == f[0] ? "" : f[0]),
                (f = f.slice(1)),
                i++)
              : (a = /^[^\s<>='"]*$/);
            for (let O of c)
              l.push({ label: O, apply: u + O + d, type: "constant" });
          }
        }
        return { from: i, to: r, options: l, validFor: a };
      }
      function rb(n, e) {
        let { state: t, pos: i } = e,
          r = J(t).resolveInner(i, -1),
          s = r.resolve(i);
        for (let o = i, l; s == r && (l = r.childBefore(o)); ) {
          let a = l.lastChild;
          if (!a || !a.type.isError || a.from < a.to) break;
          (s = r = l), (o = a.from);
        }
        return r.name == "TagName"
          ? r.parent && /CloseTag$/.test(r.parent.name)
            ? _h(t, r, r.from, i)
            : Eh(t, n, r, r.from, i)
          : r.name == "StartTag"
          ? Eh(t, n, r, i, i)
          : r.name == "StartCloseTag" || r.name == "IncompleteCloseTag"
          ? _h(t, r, i, i)
          : r.name == "OpenTag" ||
            r.name == "SelfClosingTag" ||
            r.name == "AttributeName"
          ? ib(t, n, r, r.name == "AttributeName" ? r.from : i, i)
          : r.name == "Is" ||
            r.name == "AttributeValue" ||
            r.name == "UnquotedAttributeValue"
          ? nb(t, n, r, r.name == "Is" ? i : r.from, i)
          : e.explicit &&
            (s.name == "Element" || s.name == "Text" || s.name == "Document")
          ? tb(t, n, r, i)
          : null;
      }
      function sb(n) {
        let { extraTags: e, extraGlobalAttributes: t } = n,
          i = t || e ? new Tr(e, t) : Tr.default;
        return (r) => rb(i, r);
      }
      const ob = st.parser.configure({ top: "SingleExpression" }),
        bd = [
          {
            tag: "script",
            attrs: (n) => n.type == "text/typescript" || n.lang == "ts",
            parser: ud.parser,
          },
          {
            tag: "script",
            attrs: (n) => n.type == "text/babel" || n.type == "text/jsx",
            parser: dd.parser,
          },
          {
            tag: "script",
            attrs: (n) => n.type == "text/typescript-jsx",
            parser: Od.parser,
          },
          {
            tag: "script",
            attrs(n) {
              return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(
                n.type
              );
            },
            parser: ob,
          },
          {
            tag: "script",
            attrs(n) {
              return (
                !n.type ||
                /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(
                  n.type
                )
              );
            },
            parser: st.parser,
          },
          {
            tag: "style",
            attrs(n) {
              return (
                (!n.lang || n.lang == "css") &&
                (!n.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(n.type))
              );
            },
            parser: vr.parser,
          },
        ],
        xd = [
          { name: "style", parser: vr.parser.configure({ top: "Styles" }) },
        ].concat(Qd.map((n) => ({ name: n, parser: st.parser }))),
        wd = ci.define({
          name: "html",
          parser: A1.configure({
            props: [
              _r.add({
                Element(n) {
                  let e = /^(\s*)(<\/)?/.exec(n.textAfter);
                  return n.node.to <= n.pos + e[0].length
                    ? n.continue()
                    : n.lineIndent(n.node.from) + (e[2] ? 0 : n.unit);
                },
                "OpenTag CloseTag SelfClosingTag"(n) {
                  return n.column(n.node.from) + n.unit;
                },
                Document(n) {
                  if (n.pos + /\s*/.exec(n.textAfter)[0].length < n.node.to)
                    return n.continue();
                  let e = null,
                    t;
                  for (let i = n.node; ; ) {
                    let r = i.lastChild;
                    if (!r || r.name != "Element" || r.to != i.to) break;
                    e = i = r;
                  }
                  return e &&
                    !(
                      (t = e.lastChild) &&
                      (t.name == "CloseTag" || t.name == "SelfClosingTag")
                    )
                    ? n.lineIndent(e.from) + n.unit
                    : null;
                },
              }),
              Vr.add({
                Element(n) {
                  let e = n.firstChild,
                    t = n.lastChild;
                  return !e || e.name != "OpenTag"
                    ? null
                    : { from: e.to, to: t.name == "CloseTag" ? t.from : n.to };
                },
              }),
              Vf.add({ "OpenTag CloseTag": (n) => n.getChild("TagName") }),
            ],
          }),
          languageData: {
            commentTokens: { block: { open: "\x3C!--", close: "-->" } },
            indentOnInput: /^\s*<\/\w+\W$/,
            wordChars: "-._",
          },
        }),
        Kn = wd.configure({ wrap: ed(bd, xd) });
      function lb(n = {}) {
        let e = "",
          t;
        n.matchClosingTags === !1 && (e = "noMatch"),
          n.selfClosingTags === !0 && (e = (e ? e + " " : "") + "selfClosing"),
          ((n.nestedLanguages && n.nestedLanguages.length) ||
            (n.nestedAttributes && n.nestedAttributes.length)) &&
            (t = ed(
              (n.nestedLanguages || []).concat(bd),
              (n.nestedAttributes || []).concat(xd)
            ));
        let i = t
          ? wd.configure({ wrap: t, dialect: e })
          : e
          ? Kn.configure({ dialect: e })
          : Kn;
        return new Uo(i, [
          Kn.data.of({ autocomplete: sb(n) }),
          n.autoCloseTags !== !1 ? ab : [],
          Fy().support,
          dy().support,
        ]);
      }
      const Vh = new Set(
          "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(
            " "
          )
        ),
        ab = v.inputHandler.of((n, e, t, i, r) => {
          if (
            n.composing ||
            n.state.readOnly ||
            e != t ||
            (i != ">" && i != "/") ||
            !Kn.isActiveAt(n.state, e, -1)
          )
            return !1;
          let s = r(),
            { state: o } = s,
            l = o.changeByRange((a) => {
              var h, c, f;
              let u = o.doc.sliceString(a.from - 1, a.to) == i,
                { head: d } = a,
                O = J(o).resolveInner(d, -1),
                m;
              if (u && i == ">" && O.name == "EndTag") {
                let g = O.parent;
                if (
                  ((c =
                    (h = g.parent) === null || h === void 0
                      ? void 0
                      : h.lastChild) === null || c === void 0
                    ? void 0
                    : c.name) != "CloseTag" &&
                  (m = pi(o.doc, g.parent, d)) &&
                  !Vh.has(m)
                ) {
                  let Q = d + (o.doc.sliceString(d, d + 1) === ">" ? 1 : 0),
                    y = `</${m}>`;
                  return { range: a, changes: { from: d, to: Q, insert: y } };
                }
              } else if (u && i == "/" && O.name == "IncompleteCloseTag") {
                let g = O.parent;
                if (
                  O.from == d - 2 &&
                  ((f = g.lastChild) === null || f === void 0
                    ? void 0
                    : f.name) != "CloseTag" &&
                  (m = pi(o.doc, g, d)) &&
                  !Vh.has(m)
                ) {
                  let Q = d + (o.doc.sliceString(d, d + 1) === ">" ? 1 : 0),
                    y = `${m}>`;
                  return {
                    range: S.cursor(d + y.length, -1),
                    changes: { from: d, to: Q, insert: y },
                  };
                }
              }
              return { range: a };
            });
          return l.changes.empty
            ? !1
            : (n.dispatch([
                s,
                o.update(l, {
                  userEvent: "input.complete",
                  scrollIntoView: !0,
                }),
              ]),
              !0);
        }),
        hb = _.create({
          doc: `<!DOCTYPE html>
<html>
  <head>
    <style>
      body { font-family: sans-serif; background: #f0f0f0; }
      h1 { color: purple; }
    </style>
  </head>
  <body>
    <h1>Hello DevLab!</h1>
    <p>Edit this code and press Run </p>
  </body>
</html>`,
          extensions: [CS, VS, lb()],
        }),
        cb = new v({ state: hb, parent: document.getElementById("editor") });
      document.getElementById("run").addEventListener("click", () => {
        const n = cb.state.doc.toString(),
          e = document.getElementById("output"),
          t = e.contentDocument || e.contentWindow.document;
        t.open(), t.write(n), t.close();
      });
    </script>
    <style rel="stylesheet" crossorigin>
      :root {
        font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
        line-height: 1.5;
        font-weight: 400;
        color-scheme: light dark;
        color: #ffffffde;
        background-color: #242424;
        font-synthesis: none;
        text-rendering: optimizeLegibility;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
      a {
        font-weight: 500;
        color: #646cff;
        text-decoration: inherit;
      }
      a:hover {
        color: #535bf2;
      }
      body {
        margin: 0;
        display: flex;
        place-items: center;
        min-width: 320px;
        min-height: 100vh;
      }
      h1 {
        font-size: 3.2em;
        line-height: 1.1;
      }
      #app {
        max-width: 1280px;
        margin: 0 auto;
        padding: 2rem;
        text-align: center;
      }
      .logo {
        height: 6em;
        padding: 1.5em;
        will-change: filter;
        transition: filter 0.3s;
      }
      .logo:hover {
        filter: drop-shadow(0 0 2em #646cffaa);
      }
      .logo.vanilla:hover {
        filter: drop-shadow(0 0 2em #f7df1eaa);
      }
      .card {
        padding: 2em;
      }
      .read-the-docs {
        color: #888;
      }
      button {
        border-radius: 8px;
        border: 1px solid transparent;
        padding: 0.6em 1.2em;
        font-size: 1em;
        font-weight: 500;
        font-family: inherit;
        background-color: #1a1a1a;
        cursor: pointer;
        transition: border-color 0.25s;
      }
      button:hover {
        border-color: #646cff;
      }
      button:focus,
      button:focus-visible {
        outline: 4px auto -webkit-focus-ring-color;
      }
      @media (prefers-color-scheme: light) {
        :root {
          color: #213547;
          background-color: #fff;
        }
        a:hover {
          color: #747bff;
        }
        button {
          background-color: #f9f9f9;
        }
      }
    </style>
  </head>
  <body>
    <h1>Mini Code Editor</h1>
    <div id="editor" style="height: 300px; border: 1px solid #ccc"></div>
    <button id="run" style="margin-top: 10px">Run</button>
    <h2>Output:</h2>
    <iframe
      id="output"
      style="width: 100%; height: 300px; border: 1px solid #ccc"
    ></iframe>
  </body>
</html>
